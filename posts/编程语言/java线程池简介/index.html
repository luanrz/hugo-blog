<!doctype html><html lang=en dir=auto><head><script>const loadScript=(e,t)=>{var n=document.createElement("script");n.onerror=e=>{throw new URIError("The script "+e.target.src+" didn't load correctly.")},t&&(n.onload=t),document.head.insertAdjacentElement("beforeend",n),n.src=e},loadPlantUMLOnNeed=()=>{let e="language-plantuml";document.querySelectorAll("[class^="+e+"]").length>0&&loadScript("https://cdn.jsdelivr.net/gh/jmnote/plantuml-encoder@1.2.4/dist/plantuml-encoder.min.js",()=>{(function(){Array.prototype.forEach.call(document.querySelectorAll("[class^="+e+"]"),function(e){let t=document.createElement("IMG");t.loading="lazy",t.src="http://www.plantuml.com/plantuml/svg/~1"+plantumlEncoder.encode(e.innerText),e.parentNode.insertBefore(t,e),e.style.display="none"})})(),console.log("PlantUML init done")})};window.addEventListener("load",function(){loadPlantUMLOnNeed()})</script><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Java线程池简介 | luanrz's blog</title><meta name=keywords content="Java,并发"><meta name=description content="一般来说，Java中每一个任务都与其对应的线程共享生命周期，任务执行完毕后其线程也会跟着销毁，随着任务数量的增加，重复创建线程所带来的消耗所产生的性能影响也会更显著。线程池提供了一种复用多个线程的方案，以此避免无谓的线程创建，它通过管理线程们的生命周期和调度方式，为任务的批量执行提供更强的灵活性。
线程池主要是指ThreadPoolExecutor类，本文将围绕ThreadPoolExecutor类及其相关类，展开对线程池的介绍。"><meta name=author content><link rel=canonical href=https://blog.luanrz.cn/posts/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%AE%80%E4%BB%8B/><link crossorigin=anonymous href=/assets/css/stylesheet.bc1149f4a72aa4858d3a9f71462f75e5884ffe8073ea9d6d5761d5663d651e20.css integrity="sha256-vBFJ9KcqpIWNOp9xRi915YhP/oBz6p1tV2HVZj1lHiA=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://blog.luanrz.cn/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://blog.luanrz.cn/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://blog.luanrz.cn/favicon-32x32.png><link rel=apple-touch-icon href=https://blog.luanrz.cn/apple-touch-icon.png><link rel=mask-icon href=https://blog.luanrz.cn/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Java线程池简介"><meta property="og:description" content="一般来说，Java中每一个任务都与其对应的线程共享生命周期，任务执行完毕后其线程也会跟着销毁，随着任务数量的增加，重复创建线程所带来的消耗所产生的性能影响也会更显著。线程池提供了一种复用多个线程的方案，以此避免无谓的线程创建，它通过管理线程们的生命周期和调度方式，为任务的批量执行提供更强的灵活性。
线程池主要是指ThreadPoolExecutor类，本文将围绕ThreadPoolExecutor类及其相关类，展开对线程池的介绍。"><meta property="og:type" content="article"><meta property="og:url" content="https://blog.luanrz.cn/posts/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%AE%80%E4%BB%8B/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-08-20T16:54:26+00:00"><meta property="article:modified_time" content="2022-08-20T16:54:26+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Java线程池简介"><meta name=twitter:description content="一般来说，Java中每一个任务都与其对应的线程共享生命周期，任务执行完毕后其线程也会跟着销毁，随着任务数量的增加，重复创建线程所带来的消耗所产生的性能影响也会更显著。线程池提供了一种复用多个线程的方案，以此避免无谓的线程创建，它通过管理线程们的生命周期和调度方式，为任务的批量执行提供更强的灵活性。
线程池主要是指ThreadPoolExecutor类，本文将围绕ThreadPoolExecutor类及其相关类，展开对线程池的介绍。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://blog.luanrz.cn/posts/"},{"@type":"ListItem","position":2,"name":"Java线程池简介","item":"https://blog.luanrz.cn/posts/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%AE%80%E4%BB%8B/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Java线程池简介","name":"Java线程池简介","description":"一般来说，Java中每一个任务都与其对应的线程共享生命周期，任务执行完毕后其线程也会跟着销毁，随着任务数量的增加，重复创建线程所带来的消耗所产生的性能影响也会更显著。线程池提供了一种复用多个线程的方案，以此避免无谓的线程创建，它通过管理线程们的生命周期和调度方式，为任务的批量执行提供更强的灵活性。\n线程池主要是指ThreadPoolExecutor类，本文将围绕ThreadPoolExecutor类及其相关类，展开对线程池的介绍。\n","keywords":["Java","并发"],"articleBody":"一般来说，Java中每一个任务都与其对应的线程共享生命周期，任务执行完毕后其线程也会跟着销毁，随着任务数量的增加，重复创建线程所带来的消耗所产生的性能影响也会更显著。线程池提供了一种复用多个线程的方案，以此避免无谓的线程创建，它通过管理线程们的生命周期和调度方式，为任务的批量执行提供更强的灵活性。\n线程池主要是指ThreadPoolExecutor类，本文将围绕ThreadPoolExecutor类及其相关类，展开对线程池的介绍。\n一、线程池核心类之间的关系 线程池的核心类位于JUC包(即java.util.concurrent包)，该包保存了Java并发的大多数类，如：锁、阻塞队列、线程池等。\nJUC下的线程池由若干核心类，他们的关系如下所示：\n@startuml Java线程池类图 title Java线程池类图 interface Executor interface ExecutorService #Pink abstract class AbstractExecutorService class ThreadPoolExecutor #LightBlue interface ScheduledExecutorService class ScheduledThreadPoolExecutor interface Future class FutureTask interface Runnable interface Callable class Executors Executor \u003c|-- ExecutorService ExecutorService \u003c|.. AbstractExecutorService AbstractExecutorService \u003c|-- ThreadPoolExecutor ExecutorService \u003c|-- ScheduledExecutorService ThreadPoolExecutor \u003c|-- ScheduledThreadPoolExecutor ScheduledExecutorService \u003c|.. ScheduledThreadPoolExecutor ExecutorService -left-\u003e Future AbstractExecutorService -left-\u003e FutureTask Future \u003c|-- FutureTask Executor -right-\u003e Runnable ExecutorService -right-\u003e Callable Executors -right-\u003e ThreadPoolExecutor @enduml 如果将上述类限定在线程池这一使用场景下，那么它们有以下分类：\nThreadPoolExecutor类是线程池本体 ScheduledExecutorService与ScheduledThreadPoolExecutor是支持延时任务的线程池变体 Executor、ExecutorService与AbstractExecutorService是线程池的抽象定义 Runnable和Runnable是线程池执行的任务 Future和FutureTask是线程池异步执行的结果 Executors是用于创建线程池的工具 当然，Executor等接口或类还有其它的应用场景，本文只限定于线程池场景。\n二、ThreadPoolExecutor的使用 （一）定义线程池 在使用线程池之前，需要先定义ThreadPoolExecutor，ThreadPoolExecutor的主要构造函数如下所示：\npublic ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue\u003cRunnable\u003e workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) { 上述参数的含义为：\n参数 含义 int corePoolSize 核心线程容量 int maximumPoolSize 最大线程容量( = 核心线程容量 + 非核心线程容量 ) long keepAliveTime 非核心线程存活时间(如果设置了allowCoreThreadTimeOut，也对核心线程有效) TimeUnit unit 存活时间单位 BlockingQueue workQueue 等待队列 ThreadFactory threadFactory 线程创建工厂 RejectedExecutionHandler handler 饱和时的拒绝策略 核心线程池有三个抽象区域：核心线程区、非核心线程区以及等待队列。分别对应了上述的corePoolSize、maximumPoolSize以及workQueue，其中，maximumPoolSize为最大线程容量，maximumPoolSize-corePoolSize即是非核心线程容量。\n同时，最大并发数 = 最大线程容量 + 等待队列容量。\n也有，最大并发数 = 核心线程容量 + 非核心线程容量 + 等待队列容量。\n当设置完上述三个值后，线程池的处理上限也将基本确定。后续将按照核心线程池 -\u003e 等待队列 -\u003e 非核心线程池的顺序依次执行任务，有关线程池的内部逻辑，详见后文ThreadPoolExecutor原理浅析。\n一般建议直接使用ThreadPoolExecutor的构造方法来实例化线程池，这样更容易通过参数识别线程池的关键属性。当然，为了简单起见，也可以使用Executors的系列方法：newFixedThreadPool()、newSingleThreadExecutor()与newScheduledThreadPool()，下面以newFixedThreadPool()为例来初始化一个线程池：\n// 1.定义线程池 ExecutorService threadPoolExecutor = Executors.newFixedThreadPool(10); Executors的newxxxThreadPool()系列方法是对ThreadPoolExecutor构造方法的简单封装，可以用它来快速创建一个默认的线程池。但是，如果你的本地IDE环境安装了阿里巴巴的规范插件，使用Executors时可能会收到到一条警告：不建议使用Executors的newxxxThreadPool()系列方法，那是因为Executors有默认使用无界阻塞队列的情况，可能会导致内存泄露，同时，Executors掩盖了创建线程池的细节，没法快速识别线程池的关键属性。当然，最终是否要使用Executors就见仁见智了。\n（二）使用线程池 线程池有两种执行方式：同步执行与异步执行。\n1. 同步执行 同步执行会阻塞当前线程，直到任务执行完毕。\n可以使用Executor的void execute(Runnable command)方法来实现同步执行，如下所示：\n// 2. 使用线程池:同步执行 Runnable synchronousTask = new Thread(); threadPoolExecutor.execute(synchronousTask); 2. 异步执行 异步执行不会阻塞当前线程，执行的结果会存放在Future对象中，这个对象一般也是FutureTask对象。\n可以使用执行ExecutorService的submit()系列方法来异步执行，submit()有三个重载方法，如下所示：\n\u003cT\u003e Future\u003cT\u003e submit(Callable\u003cT\u003e task); \u003cT\u003e Future\u003cT\u003e submit(Runnable task, T result); Future\u003c?\u003e submit(Runnable task); 上述重载方法中，Runnable参数最终也会转换成Callable。以Future\u003c?\u003e submit(Runnable task)为例，异步执行任务的使用方法如下所示：\n// 3. 使用线程池:异步执行 Runnable asynchronousTask = new Thread(); Future\u003c?\u003e future = threadPoolExecutor.submit(asynchronousTask); //Object object = future.get(); submit()本身是异步的，最终得到future后，调用future.get()可以得到结果，此时的get()是同步的。\n（三）关闭线程池 使用完线程池后，需要将之关闭以节省资源。\n关闭线程池可以使用shutdown()或shutdownNow()，它们的区别是：shutdown()会在执行完正在运行的线程后退出，等待中的线程将被丢弃；shutdownNow()则会直接停止正在运行的线程，并将未执行的任务返回(包括正在运行的线程和等待中的线程)。\n关闭线程池的使用方法如下所示：\n// 4. 关闭线程池 threadPoolExecutor.shutdown(); //threadPoolExecutor.shutdownNow(); （四）完整的例子 上述定义线程池、使用线程池及关闭线程池的完整例子如下：\n// 1.定义线程池 ExecutorService threadPoolExecutor = Executors.newFixedThreadPool(10); // 2. 使用线程池:同步执行 Runnable synchronousTask = new Thread(); threadPoolExecutor.execute(synchronousTask); // 3. 使用线程池:异步执行 Runnable asynchronousTask = new Thread(); Future\u003c?\u003e future = threadPoolExecutor.submit(asynchronousTask); //Object object = future.get(); // 4. 关闭线程池 threadPoolExecutor.shutdown(); //threadPoolExecutor.shutdownNow(); 三、ThreadPoolExecutor原理浅析 ThreadPoolExecutor的核心处理逻辑位于execute方法中，该方法在jdk6与jdk7中有些许差异，如下所示：\njdk6及以前的execute方法 public void execute(Runnable command) { if (command == null) throw new NullPointerException(); if (poolSize \u003e= corePoolSize || !addIfUnderCorePoolSize(command)) { if (runState == RUNNING \u0026\u0026 workQueue.offer(command)) { if (runState != RUNNING || poolSize == 0) ensureQueuedTaskHandled(command); } else if (!addIfUnderMaximumPoolSize(command)) reject(command); } } jdk7及以后的execute方法 public void execute(Runnable command) { if (command == null) throw new NullPointerException(); int c = ctl.get(); if (workerCountOf(c) \u003c corePoolSize) { if (addWorker(command, true)) return; c = ctl.get(); } if (isRunning(c) \u0026\u0026 workQueue.offer(command)) { int recheck = ctl.get(); if (! isRunning(recheck) \u0026\u0026 remove(command)) reject(command); else if (workerCountOf(recheck) == 0) addWorker(null, false); } else if (!addWorker(command, false)) reject(command); } // TODO\n参考文档\n《Java并发编程的艺术 方腾飞 魏鹏 程晓明 著》 ","wordCount":"366","inLanguage":"en","datePublished":"2022-08-20T16:54:26Z","dateModified":"2022-08-20T16:54:26Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.luanrz.cn/posts/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%AE%80%E4%BB%8B/"},"publisher":{"@type":"Organization","name":"luanrz's blog","logo":{"@type":"ImageObject","url":"https://blog.luanrz.cn/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://blog.luanrz.cn/ accesskey=h title="luanrz's blog (Alt + H)">luanrz's blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://blog.luanrz.cn/ title=首页><span>首页</span></a></li><li><a href=https://blog.luanrz.cn/search/ title="搜索 (Alt + /)" accesskey=/><span>搜索</span></a></li><li><a href=https://blog.luanrz.cn/archives/ title=归档><span>归档</span></a></li><li><a href=https://blog.luanrz.cn/categories/ title=分类><span>分类</span></a></li><li><a href=https://blog.luanrz.cn/tags/ title=标签><span>标签</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Java线程池简介</h1></header><div class=post-content><p>一般来说，Java中每一个任务都与其对应的线程共享生命周期，任务执行完毕后其线程也会跟着销毁，随着任务数量的增加，重复创建线程所带来的消耗所产生的性能影响也会更显著。线程池提供了一种复用多个线程的方案，以此避免无谓的线程创建，它通过管理线程们的生命周期和调度方式，为任务的批量执行提供更强的灵活性。</p><p>线程池主要是指<code>ThreadPoolExecutor</code>类，本文将围绕<code>ThreadPoolExecutor</code>类及其相关类，展开对线程池的介绍。</p><h2 id=一线程池核心类之间的关系>一、线程池核心类之间的关系<a hidden class=anchor aria-hidden=true href=#一线程池核心类之间的关系>#</a></h2><p>线程池的核心类位于<code>JUC</code>包(即<code>java.util.concurrent</code>包)，该包保存了Java并发的大多数类，如：锁、阻塞队列、线程池等。</p><p>JUC下的线程池由若干核心类，他们的关系如下所示：</p><pre tabindex=0><code class=language-plantuml data-lang=plantuml>@startuml Java线程池类图

title Java线程池类图

interface Executor
interface ExecutorService #Pink
abstract class AbstractExecutorService
class ThreadPoolExecutor #LightBlue
interface ScheduledExecutorService
class ScheduledThreadPoolExecutor
interface Future
class FutureTask
interface Runnable
interface Callable
class Executors

Executor &lt;|-- ExecutorService
ExecutorService &lt;|.. AbstractExecutorService
AbstractExecutorService &lt;|-- ThreadPoolExecutor

ExecutorService &lt;|-- ScheduledExecutorService
ThreadPoolExecutor &lt;|-- ScheduledThreadPoolExecutor
ScheduledExecutorService &lt;|.. ScheduledThreadPoolExecutor

ExecutorService -left-&gt; Future
AbstractExecutorService -left-&gt; FutureTask
Future &lt;|-- FutureTask

Executor -right-&gt; Runnable
ExecutorService -right-&gt; Callable

Executors -right-&gt; ThreadPoolExecutor
@enduml
</code></pre><p>如果将上述类限定在线程池这一使用场景下，那么它们有以下分类：</p><ul><li><code>ThreadPoolExecutor</code>类是线程池本体</li><li><code>ScheduledExecutorService</code>与<code>ScheduledThreadPoolExecutor</code>是支持延时任务的线程池变体</li><li><code>Executor</code>、<code>ExecutorService</code>与<code>AbstractExecutorService</code>是线程池的抽象定义</li><li><code>Runnable</code>和<code>Runnable</code>是线程池执行的任务</li><li><code>Future</code>和<code>FutureTask</code>是线程池异步执行的结果</li><li><code>Executors</code>是用于创建线程池的工具</li></ul><blockquote><p>当然，<code>Executor</code>等接口或类还有其它的应用场景，本文只限定于线程池场景。</p></blockquote><h2 id=二threadpoolexecutor的使用>二、ThreadPoolExecutor的使用<a hidden class=anchor aria-hidden=true href=#二threadpoolexecutor的使用>#</a></h2><h3 id=一定义线程池>（一）定义线程池<a hidden class=anchor aria-hidden=true href=#一定义线程池>#</a></h3><p>在使用线程池之前，需要先定义<code>ThreadPoolExecutor</code>，<code>ThreadPoolExecutor</code>的主要构造函数如下所示：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#a6e22e>ThreadPoolExecutor</span><span style=color:#f92672>(</span><span style=color:#66d9ef>int</span> corePoolSize<span style=color:#f92672>,</span>
</span></span><span style=display:flex><span>                          <span style=color:#66d9ef>int</span> maximumPoolSize<span style=color:#f92672>,</span>
</span></span><span style=display:flex><span>                          <span style=color:#66d9ef>long</span> keepAliveTime<span style=color:#f92672>,</span>
</span></span><span style=display:flex><span>                          TimeUnit unit<span style=color:#f92672>,</span>
</span></span><span style=display:flex><span>                          BlockingQueue<span style=color:#f92672>&lt;</span>Runnable<span style=color:#f92672>&gt;</span> workQueue<span style=color:#f92672>,</span>
</span></span><span style=display:flex><span>                          ThreadFactory threadFactory<span style=color:#f92672>,</span>
</span></span><span style=display:flex><span>                          RejectedExecutionHandler handler<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span></code></pre></div><p>上述参数的含义为：</p><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>int corePoolSize</td><td>核心线程容量</td></tr><tr><td>int maximumPoolSize</td><td>最大线程容量( = 核心线程容量 + 非核心线程容量 )</td></tr><tr><td>long keepAliveTime</td><td>非核心线程存活时间(如果设置了allowCoreThreadTimeOut，也对核心线程有效)</td></tr><tr><td>TimeUnit unit</td><td>存活时间单位</td></tr><tr><td>BlockingQueue workQueue</td><td>等待队列</td></tr><tr><td>ThreadFactory threadFactory</td><td>线程创建工厂</td></tr><tr><td>RejectedExecutionHandler handler</td><td>饱和时的拒绝策略</td></tr></tbody></table><p>核心线程池有三个抽象区域：核心线程区、非核心线程区以及等待队列。分别对应了上述的<code>corePoolSize</code>、<code>maximumPoolSize</code>以及<code>workQueue</code>，其中，<code>maximumPoolSize</code>为最大线程容量，<code>maximumPoolSize</code>-<code>corePoolSize</code>即是非核心线程容量。</p><p>同时，<code>最大并发数 = 最大线程容量 + 等待队列容量</code>。</p><p>也有，<code>最大并发数 = 核心线程容量 + 非核心线程容量 + 等待队列容量</code>。</p><p>当设置完上述三个值后，线程池的处理上限也将基本确定。后续将按照<code>核心线程池 -> 等待队列 -> 非核心线程池</code>的顺序依次执行任务，有关线程池的内部逻辑，详见后文<a href=#%E4%B8%89threadpoolexecutor%E5%8E%9F%E7%90%86%E6%B5%85%E6%9E%90>ThreadPoolExecutor原理浅析</a>。</p><p>一般建议直接使用<code>ThreadPoolExecutor</code>的构造方法来实例化线程池，这样更容易通过参数识别线程池的关键属性。当然，为了简单起见，也可以使用<code>Executors</code>的系列方法：<code>newFixedThreadPool()</code>、<code>newSingleThreadExecutor()</code>与<code>newScheduledThreadPool()</code>，下面以<code>newFixedThreadPool()</code>为例来初始化一个线程池：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// 1.定义线程池
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>ExecutorService threadPoolExecutor <span style=color:#f92672>=</span> Executors<span style=color:#f92672>.</span><span style=color:#a6e22e>newFixedThreadPool</span><span style=color:#f92672>(</span>10<span style=color:#f92672>);</span>
</span></span></code></pre></div><p><code>Executors</code>的<code>newxxxThreadPool()</code>系列方法是对<code>ThreadPoolExecutor</code>构造方法的简单封装，可以用它来快速创建一个默认的线程池。但是，如果你的本地IDE环境安装了阿里巴巴的规范插件，使用<code>Executors</code>时可能会收到到一条警告：不建议使用<code>Executors</code>的<code>newxxxThreadPool()</code>系列方法，那是因为<code>Executors</code>有默认使用无界阻塞队列的情况，可能会导致内存泄露，同时，<code>Executors</code>掩盖了创建线程池的细节，没法快速识别线程池的关键属性。当然，最终是否要使用<code>Executors</code>就见仁见智了。</p><h3 id=二使用线程池>（二）使用线程池<a hidden class=anchor aria-hidden=true href=#二使用线程池>#</a></h3><p>线程池有两种执行方式：同步执行与异步执行。</p><h4 id=1-同步执行>1. 同步执行<a hidden class=anchor aria-hidden=true href=#1-同步执行>#</a></h4><p>同步执行会阻塞当前线程，直到任务执行完毕。</p><p>可以使用<code>Executor</code>的<code>void execute(Runnable command)</code>方法来实现同步执行，如下所示：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// 2. 使用线程池:同步执行
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>Runnable synchronousTask <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Thread<span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>threadPoolExecutor<span style=color:#f92672>.</span><span style=color:#a6e22e>execute</span><span style=color:#f92672>(</span>synchronousTask<span style=color:#f92672>);</span>
</span></span></code></pre></div><h4 id=2-异步执行>2. 异步执行<a hidden class=anchor aria-hidden=true href=#2-异步执行>#</a></h4><p>异步执行不会阻塞当前线程，执行的结果会存放在<code>Future</code>对象中，这个对象一般也是<code>FutureTask</code>对象。</p><p>可以使用执行<code>ExecutorService</code>的<code>submit()</code>系列方法来异步执行，<code>submit()</code>有三个重载方法，如下所示：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> Future<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> <span style=color:#a6e22e>submit</span><span style=color:#f92672>(</span>Callable<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> task<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> Future<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> <span style=color:#a6e22e>submit</span><span style=color:#f92672>(</span>Runnable task<span style=color:#f92672>,</span> T result<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>Future<span style=color:#f92672>&lt;?&gt;</span> submit<span style=color:#f92672>(</span>Runnable task<span style=color:#f92672>);</span>
</span></span></code></pre></div><p>上述重载方法中，<code>Runnable</code>参数最终也会转换成<code>Callable</code>。以<code>Future&lt;?> submit(Runnable task)</code>为例，异步执行任务的使用方法如下所示：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// 3. 使用线程池:异步执行
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>Runnable asynchronousTask <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Thread<span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>Future<span style=color:#f92672>&lt;?&gt;</span> future <span style=color:#f92672>=</span> threadPoolExecutor<span style=color:#f92672>.</span><span style=color:#a6e22e>submit</span><span style=color:#f92672>(</span>asynchronousTask<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span><span style=color:#75715e>//Object object = future.get();
</span></span></span></code></pre></div><p><code>submit()</code>本身是异步的，最终得到<code>future</code>后，调用<code>future.get()</code>可以得到结果，此时的<code>get()</code>是同步的。</p><h3 id=三关闭线程池>（三）关闭线程池<a hidden class=anchor aria-hidden=true href=#三关闭线程池>#</a></h3><p>使用完线程池后，需要将之关闭以节省资源。</p><p>关闭线程池可以使用<code>shutdown()</code>或<code>shutdownNow()</code>，它们的区别是：<code>shutdown()</code>会在执行完正在运行的线程后退出，等待中的线程将被丢弃；<code>shutdownNow()</code>则会直接停止正在运行的线程，并将未执行的任务返回(包括正在运行的线程和等待中的线程)。</p><p>关闭线程池的使用方法如下所示：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// 4. 关闭线程池
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>threadPoolExecutor<span style=color:#f92672>.</span><span style=color:#a6e22e>shutdown</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span><span style=color:#75715e>//threadPoolExecutor.shutdownNow();
</span></span></span></code></pre></div><h3 id=四完整的例子>（四）完整的例子<a hidden class=anchor aria-hidden=true href=#四完整的例子>#</a></h3><p>上述定义线程池、使用线程池及关闭线程池的完整例子如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// 1.定义线程池
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>ExecutorService threadPoolExecutor <span style=color:#f92672>=</span> Executors<span style=color:#f92672>.</span><span style=color:#a6e22e>newFixedThreadPool</span><span style=color:#f92672>(</span>10<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 2. 使用线程池:同步执行
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>Runnable synchronousTask <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Thread<span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>threadPoolExecutor<span style=color:#f92672>.</span><span style=color:#a6e22e>execute</span><span style=color:#f92672>(</span>synchronousTask<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 3. 使用线程池:异步执行
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>Runnable asynchronousTask <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Thread<span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>Future<span style=color:#f92672>&lt;?&gt;</span> future <span style=color:#f92672>=</span> threadPoolExecutor<span style=color:#f92672>.</span><span style=color:#a6e22e>submit</span><span style=color:#f92672>(</span>asynchronousTask<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span><span style=color:#75715e>//Object object = future.get();
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 4. 关闭线程池
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>threadPoolExecutor<span style=color:#f92672>.</span><span style=color:#a6e22e>shutdown</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span><span style=color:#75715e>//threadPoolExecutor.shutdownNow();
</span></span></span></code></pre></div><h2 id=三threadpoolexecutor原理浅析>三、ThreadPoolExecutor原理浅析<a hidden class=anchor aria-hidden=true href=#三threadpoolexecutor原理浅析>#</a></h2><p><code>ThreadPoolExecutor</code>的核心处理逻辑位于<code>execute</code>方法中，该方法在jdk6与jdk7中有些许差异，如下所示：</p><ol><li>jdk6及以前的<code>execute</code>方法</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Java data-lang=Java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>execute</span><span style=color:#f92672>(</span>Runnable command<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>command <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> NullPointerException<span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>poolSize <span style=color:#f92672>&gt;=</span> corePoolSize <span style=color:#f92672>||</span> <span style=color:#f92672>!</span>addIfUnderCorePoolSize<span style=color:#f92672>(</span>command<span style=color:#f92672>))</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>runState <span style=color:#f92672>==</span> RUNNING <span style=color:#f92672>&amp;&amp;</span> workQueue<span style=color:#f92672>.</span><span style=color:#a6e22e>offer</span><span style=color:#f92672>(</span>command<span style=color:#f92672>))</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>runState <span style=color:#f92672>!=</span> RUNNING <span style=color:#f92672>||</span> poolSize <span style=color:#f92672>==</span> 0<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>                ensureQueuedTaskHandled<span style=color:#f92672>(</span>command<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> <span style=color:#f92672>(!</span>addIfUnderMaximumPoolSize<span style=color:#f92672>(</span>command<span style=color:#f92672>))</span>
</span></span><span style=display:flex><span>            reject<span style=color:#f92672>(</span>command<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><ol start=2><li>jdk7及以后的<code>execute</code>方法</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Java data-lang=Java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>execute</span><span style=color:#f92672>(</span>Runnable command<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>command <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> NullPointerException<span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> c <span style=color:#f92672>=</span> ctl<span style=color:#f92672>.</span><span style=color:#a6e22e>get</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>workerCountOf<span style=color:#f92672>(</span>c<span style=color:#f92672>)</span> <span style=color:#f92672>&lt;</span> corePoolSize<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>addWorker<span style=color:#f92672>(</span>command<span style=color:#f92672>,</span> <span style=color:#66d9ef>true</span><span style=color:#f92672>))</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>        c <span style=color:#f92672>=</span> ctl<span style=color:#f92672>.</span><span style=color:#a6e22e>get</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>isRunning<span style=color:#f92672>(</span>c<span style=color:#f92672>)</span> <span style=color:#f92672>&amp;&amp;</span> workQueue<span style=color:#f92672>.</span><span style=color:#a6e22e>offer</span><span style=color:#f92672>(</span>command<span style=color:#f92672>))</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> recheck <span style=color:#f92672>=</span> ctl<span style=color:#f92672>.</span><span style=color:#a6e22e>get</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#f92672>(!</span> isRunning<span style=color:#f92672>(</span>recheck<span style=color:#f92672>)</span> <span style=color:#f92672>&amp;&amp;</span> remove<span style=color:#f92672>(</span>command<span style=color:#f92672>))</span>
</span></span><span style=display:flex><span>            reject<span style=color:#f92672>(</span>command<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>workerCountOf<span style=color:#f92672>(</span>recheck<span style=color:#f92672>)</span> <span style=color:#f92672>==</span> 0<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>            addWorker<span style=color:#f92672>(</span><span style=color:#66d9ef>null</span><span style=color:#f92672>,</span> <span style=color:#66d9ef>false</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> <span style=color:#f92672>(!</span>addWorker<span style=color:#f92672>(</span>command<span style=color:#f92672>,</span> <span style=color:#66d9ef>false</span><span style=color:#f92672>))</span>
</span></span><span style=display:flex><span>        reject<span style=color:#f92672>(</span>command<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><p>// TODO</p><blockquote><p>参考文档</p></blockquote><ol><li>《Java并发编程的艺术 方腾飞 魏鹏 程晓明 著》</li></ol></div><footer class=post-footer><ul class=post-tags><li><a href=https://blog.luanrz.cn/tags/java/>Java</a></li><li><a href=https://blog.luanrz.cn/tags/%E5%B9%B6%E5%8F%91/>并发</a></li></ul><nav class=paginav><a class=prev href=https://blog.luanrz.cn/posts/%E7%94%9F%E6%B4%BB%E6%9D%82%E8%AE%B0/%E7%AC%AC%E4%B8%80%E6%AC%A1%E9%9D%A2%E8%AF%95%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95%E4%B8%8E%E8%A6%81%E7%82%B9%E6%A2%B3%E7%90%86/><span class=title>« Prev</span><br><span>第一次面试过程记录与要点梳理</span></a>
<a class=next href=https://blog.luanrz.cn/posts/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/java%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E7%AE%80%E4%BB%8B/><span class=title>Next »</span><br><span>Java阻塞队列简介</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2022 <a href=https://blog.luanrz.cn/>luanrz's blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>