<!doctype html><html lang=en dir=auto><head><script>const loadScript=(e,t)=>{var n=document.createElement("script");n.onerror=e=>{throw new URIError("The script "+e.target.src+" didn't load correctly.")},t&&(n.onload=t),document.head.insertAdjacentElement("beforeend",n),n.src=e},loadPlantUMLOnNeed=()=>{let e="language-plantuml";document.querySelectorAll("[class^="+e+"]").length>0&&loadScript("https://cdn.jsdelivr.net/gh/jmnote/plantuml-encoder@1.2.4/dist/plantuml-encoder.min.js",()=>{(function(){Array.prototype.forEach.call(document.querySelectorAll("[class^="+e+"]"),function(e){let t=document.createElement("IMG");t.loading="lazy",t.src="http://www.plantuml.com/plantuml/svg/~1"+plantumlEncoder.encode(e.innerText),e.parentNode.insertBefore(t,e),e.style.display="none"})})(),console.log("PlantUML init done")})};window.addEventListener("load",function(){loadPlantUMLOnNeed()})</script><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>JVM双亲委派模型浅析 | luanrz's blog</title><meta name=keywords content="Java,JVM"><meta name=description content="双亲委派(Parents Delegation)，一言以蔽之，就是：在Java虚拟机中，将类的加载行为委派给父级(双亲)类加载器的过程。
接下来将逐一介绍Java8及Java9中的类加载器，并根据类加载器的组织结构，描述双亲委派的实现过程。"><meta name=author content><link rel=canonical href=https://blog.luanrz.cn/posts/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/jvm%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B%E6%B5%85%E6%9E%90/><link crossorigin=anonymous href=/assets/css/stylesheet.bc1149f4a72aa4858d3a9f71462f75e5884ffe8073ea9d6d5761d5663d651e20.css integrity="sha256-vBFJ9KcqpIWNOp9xRi915YhP/oBz6p1tV2HVZj1lHiA=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://blog.luanrz.cn/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://blog.luanrz.cn/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://blog.luanrz.cn/favicon-32x32.png><link rel=apple-touch-icon href=https://blog.luanrz.cn/apple-touch-icon.png><link rel=mask-icon href=https://blog.luanrz.cn/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="JVM双亲委派模型浅析"><meta property="og:description" content="双亲委派(Parents Delegation)，一言以蔽之，就是：在Java虚拟机中，将类的加载行为委派给父级(双亲)类加载器的过程。
接下来将逐一介绍Java8及Java9中的类加载器，并根据类加载器的组织结构，描述双亲委派的实现过程。"><meta property="og:type" content="article"><meta property="og:url" content="https://blog.luanrz.cn/posts/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/jvm%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B%E6%B5%85%E6%9E%90/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-06-16T08:51:45+00:00"><meta property="article:modified_time" content="2022-06-16T08:51:45+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="JVM双亲委派模型浅析"><meta name=twitter:description content="双亲委派(Parents Delegation)，一言以蔽之，就是：在Java虚拟机中，将类的加载行为委派给父级(双亲)类加载器的过程。
接下来将逐一介绍Java8及Java9中的类加载器，并根据类加载器的组织结构，描述双亲委派的实现过程。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://blog.luanrz.cn/posts/"},{"@type":"ListItem","position":2,"name":"JVM双亲委派模型浅析","item":"https://blog.luanrz.cn/posts/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/jvm%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B%E6%B5%85%E6%9E%90/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"JVM双亲委派模型浅析","name":"JVM双亲委派模型浅析","description":"双亲委派(Parents Delegation)，一言以蔽之，就是：在Java虚拟机中，将类的加载行为委派给父级(双亲)类加载器的过程。\n接下来将逐一介绍Java8及Java9中的类加载器，并根据类加载器的组织结构，描述双亲委派的实现过程。\n","keywords":["Java","JVM"],"articleBody":"双亲委派(Parents Delegation)，一言以蔽之，就是：在Java虚拟机中，将类的加载行为委派给父级(双亲)类加载器的过程。\n接下来将逐一介绍Java8及Java9中的类加载器，并根据类加载器的组织结构，描述双亲委派的实现过程。\n一、概念范围 首先，明确一下“双亲委派”这个概念的上下文，双亲委派一般只在Java虚拟机类加载过程中讨论，全文默认遵循此上下文。\n同时，Java虚拟机“类加载”一般包括“加载”、“验证”、“准备”、“解析”、“初始化”几个阶段，这里出现了两个“加载”的概念，狭义的“加载”是广义的“类加载”的一部分，全文默认描述的是广义的“类加载”。\n二、类加载器 类加载器的组织结构是双亲委派的基础，双亲委派是多个类加载器之间的一种行为，更具体来说，是父类加载器与子类加载器之间的行为(“父子关系”乍一看会以为两个类加载器是继承关系，但其实它们是组合关系，详见下述ClassLoader类图)。\n一般来说，所有类加载器都继承自ClassLoader类(Java8中启动类加载器除外，其由虚拟机原生C++提供)。\n（一）Java8类加载器 Java8及以下版本中常用的类加载器有以下几个：\n启动类加载器(Bootstrap ClassLoader)：加载${JAVA_HOME}/lib下指定的类库(如：rt.jar)。由虚拟机原生C++实现，没有对应的Java类。 扩展类加载器(Extension ClassLoader)：加载${AVA_HOME}/lib/ext下所有的类库。由ExtClassLoader类实现。 应用程序类加载器(Application ClassLoader)：加载用户类路径(ClassPath)下所有的类库。由AppClassLoader类实现。 自定义类加载器(User ClassLoader)：加载用户自定义的类库。由用户手动继承ClassLoader类的自定义类加载器实现。 Java8常用ClassLoader的类图如下所示：\n@startuml ClassLoader类图(Java8版本) title ClassLoader类图(Java8版本) footer 适用于Java8及以下版本的常用ClassLoader类图 abstract class ClassLoader #Pink { + ClassLoader parent # Class\u003c?\u003e loadClass(String name, boolean resolve) } class SecureClassLoader class URLClassLoader class Launcher class ExtClassLoader #Pink class AppClassLoader #Pink class BootClassLoader #Pink note top of BootClassLoader Java8中并不存在BootClassLoader类， 启动类加载器由Java虚拟机C++原生支持， 这里仅用于占位，便于理解 endnote ClassLoader \u003c|-- SecureClassLoader SecureClassLoader \u003c|-- URLClassLoader URLClassLoader \u003c|-- ExtClassLoader URLClassLoader \u003c|-- AppClassLoader Launcher +-- ExtClassLoader Launcher +-- AppClassLoader AppClassLoader -\u003e ExtClassLoader ExtClassLoader -\u003e BootClassLoader @enduml 阅读源码可以发现，ExtClassLoader与AppClassLoader均是Launcher类的内部类，且它们的实例化过程均在Launcher的构造方法里面，如下所示(精简了部分语句)：\npublic class Launcher { private ClassLoader loader; public Launcher() { // 实例化ExtClassLoader ClassLoader extcl extcl = ExtClassLoader.getExtClassLoader(); // 实例化AppClassLoader loader = AppClassLoader.getAppClassLoader(extcl); } } 在实例化ExtClassLoader时，它的parent属性将被设置为null，这表示ExtClassLoader的父类加载器为null(这里的null有特殊意义，在后续双亲委派的实现过程源码部分将会介绍)。\n在实例化AppClassLoader时，它的parent属性将被设置为ExtClassLoader，这表示AppClassLoader的父类加载器为ExtClassLoader。\n（二）Java9类加载器 Java9新增的模块化导致源码结构发生重大变更，其类加载器也跟着发生了部分变化：\n平台类加载器(PlatformClassLoader)替换掉了Java8中的扩展类加载器(Extension ClassLoader)。 定义了Java8中不存在的启动类加载器(Bootstrap ClassLoader)。 启动类加载器、平台类加载器、应用程序类加载器不再是单向的依赖关系(详见下述类图)。 Java9常用ClassLoader的类图如下所示：\n@startuml ClassLoader类图(Java9版本) title ClassLoader类图(Java9版本) footer 适用于Java9及以上版本的常用ClassLoader类图 abstract class ClassLoader #Pink class SecureClassLoader class BuiltinClassLoader class ClassLoaders class PlatformClassLoader #Pink class AppClassLoader #Pink class BootClassLoader #Pink ClassLoader \u003c|-- SecureClassLoader SecureClassLoader \u003c|-- BuiltinClassLoader BuiltinClassLoader \u003c|-- PlatformClassLoader BuiltinClassLoader \u003c|-- AppClassLoader BuiltinClassLoader \u003c|-- BootClassLoader ClassLoaders +-- BootClassLoader ClassLoaders +-- PlatformClassLoader ClassLoaders +-- AppClassLoader AppClassLoader --\u003e PlatformClassLoader PlatformClassLoader --\u003e BootClassLoader PlatformClassLoader -\u003e AppClassLoader AppClassLoader -\u003e BootClassLoader @enduml 三、双亲委派的实现过程 根据前文描述，大部分类加载器都存在父级类加载器(即ClassLoader的parent属性对应的值)。基于此，ClassLoader.loadClass()源码描述了双亲委派是如何实现的，如下所示：\nprotected Class\u003c?\u003e loadClass(String name, boolean resolve) throws ClassNotFoundException { synchronized (getClassLoadingLock(name)) { // 首先，检查这个类是否已经被加载了 Class\u003c?\u003e c = findLoadedClass(name); if (c == null) { long t0 = System.nanoTime(); try { if (parent != null) { // 如果父类加载器非空，就执行父类加载器的加载行为 // ！！！此处为双亲委派的核心逻辑！！！ c = parent.loadClass(name, false); } else { // 如果父类加载器为空，就执行启动类加载器的加载行为(前提是name有效) c = findBootstrapClassOrNull(name); } } catch (ClassNotFoundException e) {} if (c == null) { // 如果父类加载器无法加载时，执行本类加载器自身的类加载行为 long t1 = System.nanoTime(); c = findClass(name); } } if (resolve) { resolveClass(c); } return c; } } 上述源码中最核心的一个点在于：类加载器会优先从它的父类加载器中去执行加载行为，父类加载器无法加载时，才会执行当前类加载器的加载行为。这也是“双亲委派”这个词的含义，即，将类加载行为首先委派给双亲(parent属性对应的父类加载器)。\n具体来说，根据双亲委派原则，指定给应用程序类加载器的类，会委派给父级的扩展类加载器中去加载，接着，扩展类加载器又会将之委派给启动类加载器去加载，最终所有的类都会到顶层启动类加载器，只有在父类加载器无法加载时，才会反过来让子类加载器去加载。\n所以，当一个类进入类加载流程时，它的加载位置的优先级为：启动类加载器 \u003e 扩展类加载器\u003e 应用程序类加载器。\n上述例子适用于Java8，Java9也是类似的步骤。\n四、破坏双亲委派 在某些场景，需要父类加载器去请求子类加载器完成类加载行为(如JNDI、JDBC)，或者对代码热替换即模块热部署有需求(如OSGI)，都可以不遵循双亲委派的原则，实现自定义的类加载顺序。类似于这种的场景，都可以称之为“破坏双亲委派”。\n五、总结 类加载器主要分为为“启动类加载器”、“扩展类加载器(平台类加载器)”、“应用程序类加载器”及“自定义类加载器”。\n大部分类加载器都有父类加载器，类加载器会优先从它的父类加载器中去执行加载行为，这一过程被称之为“双亲委派”。在某些场景，可以破坏双亲委派。\n参考文档\n《深入理解Java虚拟机第3版 周志明 著》 ","wordCount":"285","inLanguage":"en","datePublished":"2022-06-16T08:51:45Z","dateModified":"2022-06-16T08:51:45Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.luanrz.cn/posts/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/jvm%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B%E6%B5%85%E6%9E%90/"},"publisher":{"@type":"Organization","name":"luanrz's blog","logo":{"@type":"ImageObject","url":"https://blog.luanrz.cn/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://blog.luanrz.cn/ accesskey=h title="luanrz's blog (Alt + H)">luanrz's blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://blog.luanrz.cn/ title=首页><span>首页</span></a></li><li><a href=https://blog.luanrz.cn/search/ title="搜索 (Alt + /)" accesskey=/><span>搜索</span></a></li><li><a href=https://blog.luanrz.cn/archives/ title=归档><span>归档</span></a></li><li><a href=https://blog.luanrz.cn/categories/ title=分类><span>分类</span></a></li><li><a href=https://blog.luanrz.cn/tags/ title=标签><span>标签</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>JVM双亲委派模型浅析</h1></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e4%b8%80%e6%a6%82%e5%bf%b5%e8%8c%83%e5%9b%b4 aria-label=一、概念范围>一、概念范围</a></li><li><a href=#%e4%ba%8c%e7%b1%bb%e5%8a%a0%e8%bd%bd%e5%99%a8 aria-label=二、类加载器>二、类加载器</a><ul><li><a href=#%e4%b8%80java8%e7%b1%bb%e5%8a%a0%e8%bd%bd%e5%99%a8 aria-label=（一）Java8类加载器>（一）Java8类加载器</a></li><li><a href=#%e4%ba%8cjava9%e7%b1%bb%e5%8a%a0%e8%bd%bd%e5%99%a8 aria-label=（二）Java9类加载器>（二）Java9类加载器</a></li></ul></li><li><a href=#%e4%b8%89%e5%8f%8c%e4%ba%b2%e5%a7%94%e6%b4%be%e7%9a%84%e5%ae%9e%e7%8e%b0%e8%bf%87%e7%a8%8b aria-label=三、双亲委派的实现过程>三、双亲委派的实现过程</a></li><li><a href=#%e5%9b%9b%e7%a0%b4%e5%9d%8f%e5%8f%8c%e4%ba%b2%e5%a7%94%e6%b4%be aria-label=四、破坏双亲委派>四、破坏双亲委派</a></li><li><a href=#%e4%ba%94%e6%80%bb%e7%bb%93 aria-label=五、总结>五、总结</a></li></ul></div></details></div><div class=post-content><p><strong>双亲委派</strong>(Parents Delegation)，一言以蔽之，就是：在Java虚拟机中，将类的加载行为<strong>委派</strong>给父级(<strong>双亲</strong>)类加载器的过程。</p><p>接下来将逐一介绍Java8及Java9中的类加载器，并根据类加载器的组织结构，描述双亲委派的实现过程。</p><h2 id=一概念范围>一、概念范围<a hidden class=anchor aria-hidden=true href=#一概念范围>#</a></h2><p>首先，明确一下“双亲委派”这个概念的上下文，双亲委派一般只在<strong>Java虚拟机类加载过程</strong>中讨论，全文默认遵循此上下文。</p><p>同时，Java虚拟机“类加载”一般包括“加载”、“验证”、“准备”、“解析”、“初始化”几个阶段，这里出现了两个“加载”的概念，狭义的“加载”是广义的“类加载”的一部分，全文默认描述的是广义的“类加载”。</p><h2 id=二类加载器>二、类加载器<a hidden class=anchor aria-hidden=true href=#二类加载器>#</a></h2><p>类加载器的组织结构是双亲委派的基础，双亲委派是多个类加载器之间的一种行为，更具体来说，是父类加载器与子类加载器之间的行为(“父子关系”乍一看会以为两个类加载器是继承关系，但其实它们是组合关系，详见下述ClassLoader类图)。</p><p>一般来说，所有类加载器都继承自ClassLoader类(Java8中启动类加载器除外，其由虚拟机原生C++提供)。</p><h3 id=一java8类加载器>（一）Java8类加载器<a hidden class=anchor aria-hidden=true href=#一java8类加载器>#</a></h3><p>Java8及以下版本中常用的类加载器有以下几个：</p><ul><li>启动类加载器(Bootstrap ClassLoader)：加载<code>${JAVA_HOME}/lib</code>下指定的类库(如：rt.jar)。由虚拟机原生C++实现，没有对应的Java类。</li><li>扩展类加载器(Extension ClassLoader)：加载<code>${AVA_HOME}/lib/ext</code>下所有的类库。由ExtClassLoader类实现。</li><li>应用程序类加载器(Application ClassLoader)：加载<code>用户类路径(ClassPath)</code>下所有的类库。由AppClassLoader类实现。</li><li>自定义类加载器(User ClassLoader)：加载<code>用户自定义</code>的类库。由用户手动继承ClassLoader类的自定义类加载器实现。</li></ul><p>Java8常用ClassLoader的类图如下所示：</p><pre tabindex=0><code class=language-plantuml data-lang=plantuml>@startuml ClassLoader类图(Java8版本)

title ClassLoader类图(Java8版本)
footer 适用于Java8及以下版本的常用ClassLoader类图

abstract class ClassLoader #Pink {
    + ClassLoader parent
    # Class&lt;?&gt; loadClass(String name, boolean resolve)
}
class SecureClassLoader
class URLClassLoader
class Launcher
class ExtClassLoader #Pink
class AppClassLoader #Pink
class BootClassLoader #Pink
note top of BootClassLoader
Java8中并不存在BootClassLoader类，
启动类加载器由Java虚拟机C++原生支持，
这里仅用于占位，便于理解
endnote

ClassLoader &lt;|-- SecureClassLoader 
SecureClassLoader &lt;|-- URLClassLoader
URLClassLoader &lt;|-- ExtClassLoader
URLClassLoader &lt;|-- AppClassLoader

Launcher +-- ExtClassLoader
Launcher +-- AppClassLoader

AppClassLoader -&gt; ExtClassLoader
ExtClassLoader -&gt; BootClassLoader


@enduml
</code></pre><p>阅读源码可以发现，<code>ExtClassLoader</code>与<code>AppClassLoader</code>均是<code>Launcher</code>类的内部类，且它们的实例化过程均在<code>Launcher</code>的构造方法里面，如下所示(精简了部分语句)：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Java data-lang=Java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Launcher</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> ClassLoader loader<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>Launcher</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 实例化ExtClassLoader
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        ClassLoader extcl extcl <span style=color:#f92672>=</span> ExtClassLoader<span style=color:#f92672>.</span><span style=color:#a6e22e>getExtClassLoader</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 实例化AppClassLoader
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        loader <span style=color:#f92672>=</span> AppClassLoader<span style=color:#f92672>.</span><span style=color:#a6e22e>getAppClassLoader</span><span style=color:#f92672>(</span>extcl<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><p>在实例化ExtClassLoader时，它的parent属性将被设置为null，这表示<strong>ExtClassLoader的父类加载器为null</strong>(这里的null有特殊意义，在后续<a href=#%E4%B8%89%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E7%9A%84%E5%AE%9E%E7%8E%B0%E8%BF%87%E7%A8%8B>双亲委派的实现过程</a>源码部分将会介绍)。</p><p>在实例化AppClassLoader时，它的parent属性将被设置为ExtClassLoader，这表示<strong>AppClassLoader的父类加载器为ExtClassLoader</strong>。</p><h3 id=二java9类加载器>（二）Java9类加载器<a hidden class=anchor aria-hidden=true href=#二java9类加载器>#</a></h3><p>Java9新增的模块化导致源码结构发生重大变更，其类加载器也跟着发生了部分变化：</p><ul><li>平台类加载器(PlatformClassLoader)替换掉了Java8中的扩展类加载器(Extension ClassLoader)。</li><li>定义了Java8中不存在的启动类加载器(Bootstrap ClassLoader)。</li><li>启动类加载器、平台类加载器、应用程序类加载器不再是单向的依赖关系(详见下述类图)。</li></ul><p>Java9常用ClassLoader的类图如下所示：</p><pre tabindex=0><code class=language-plantuml data-lang=plantuml>@startuml ClassLoader类图(Java9版本)

title ClassLoader类图(Java9版本)
footer 适用于Java9及以上版本的常用ClassLoader类图

abstract class ClassLoader #Pink
class SecureClassLoader
class BuiltinClassLoader
class ClassLoaders
class PlatformClassLoader #Pink
class AppClassLoader #Pink
class BootClassLoader #Pink

ClassLoader &lt;|-- SecureClassLoader 
SecureClassLoader &lt;|-- BuiltinClassLoader
BuiltinClassLoader &lt;|-- PlatformClassLoader
BuiltinClassLoader &lt;|-- AppClassLoader
BuiltinClassLoader &lt;|-- BootClassLoader

ClassLoaders +-- BootClassLoader
ClassLoaders +-- PlatformClassLoader
ClassLoaders +-- AppClassLoader

AppClassLoader --&gt; PlatformClassLoader
PlatformClassLoader --&gt; BootClassLoader
PlatformClassLoader -&gt; AppClassLoader
AppClassLoader -&gt; BootClassLoader

@enduml
</code></pre><h2 id=三双亲委派的实现过程>三、双亲委派的实现过程<a hidden class=anchor aria-hidden=true href=#三双亲委派的实现过程>#</a></h2><p>根据前文描述，大部分类加载器都存在父级类加载器(即ClassLoader的parent属性对应的值)。基于此，<code>ClassLoader.loadClass()</code>源码描述了双亲委派是如何实现的，如下所示：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Java data-lang=Java><span style=display:flex><span><span style=color:#66d9ef>protected</span> Class<span style=color:#f92672>&lt;?&gt;</span> loadClass<span style=color:#f92672>(</span>String name<span style=color:#f92672>,</span> <span style=color:#66d9ef>boolean</span> resolve<span style=color:#f92672>)</span> <span style=color:#66d9ef>throws</span> ClassNotFoundException <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>synchronized</span> <span style=color:#f92672>(</span>getClassLoadingLock<span style=color:#f92672>(</span>name<span style=color:#f92672>))</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 首先，检查这个类是否已经被加载了
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        Class<span style=color:#f92672>&lt;?&gt;</span> c <span style=color:#f92672>=</span> findLoadedClass<span style=color:#f92672>(</span>name<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>c <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>long</span> t0 <span style=color:#f92672>=</span> System<span style=color:#f92672>.</span><span style=color:#a6e22e>nanoTime</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>try</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>parent <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// 如果父类加载器非空，就执行父类加载器的加载行为
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    <span style=color:#75715e>// ！！！此处为双亲委派的核心逻辑！！！
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    c <span style=color:#f92672>=</span> parent<span style=color:#f92672>.</span><span style=color:#a6e22e>loadClass</span><span style=color:#f92672>(</span>name<span style=color:#f92672>,</span> <span style=color:#66d9ef>false</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>                <span style=color:#f92672>}</span> <span style=color:#66d9ef>else</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// 如果父类加载器为空，就执行启动类加载器的加载行为(前提是name有效)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    c <span style=color:#f92672>=</span> findBootstrapClassOrNull<span style=color:#f92672>(</span>name<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>                <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>}</span> <span style=color:#66d9ef>catch</span> <span style=color:#f92672>(</span>ClassNotFoundException e<span style=color:#f92672>)</span> <span style=color:#f92672>{}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>c <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>// 如果父类加载器无法加载时，执行本类加载器自身的类加载行为
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#66d9ef>long</span> t1 <span style=color:#f92672>=</span> System<span style=color:#f92672>.</span><span style=color:#a6e22e>nanoTime</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>                c <span style=color:#f92672>=</span> findClass<span style=color:#f92672>(</span>name<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>resolve<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>            resolveClass<span style=color:#f92672>(</span>c<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> c<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><p>上述源码中最核心的一个点在于：<strong>类加载器会优先从它的父类加载器中去执行加载行为，父类加载器无法加载时，才会执行当前类加载器的加载行为</strong>。这也是“双亲委派”这个词的含义，即，将类加载行为首先委派给双亲(parent属性对应的父类加载器)。</p><p>具体来说，根据双亲委派原则，指定给应用程序类加载器的类，会委派给父级的扩展类加载器中去加载，接着，扩展类加载器又会将之委派给启动类加载器去加载，最终所有的类都会到顶层启动类加载器，只有在父类加载器无法加载时，才会反过来让子类加载器去加载。</p><p>所以，当一个类进入类加载流程时，它的加载位置的优先级为：启动类加载器 > 扩展类加载器> 应用程序类加载器。</p><blockquote><p>上述例子适用于Java8，Java9也是类似的步骤。</p></blockquote><h2 id=四破坏双亲委派>四、破坏双亲委派<a hidden class=anchor aria-hidden=true href=#四破坏双亲委派>#</a></h2><p>在某些场景，需要父类加载器去请求子类加载器完成类加载行为(如JNDI、JDBC)，或者对代码热替换即模块热部署有需求(如OSGI)，都可以不遵循双亲委派的原则，实现自定义的类加载顺序。类似于这种的场景，都可以称之为“破坏双亲委派”。</p><h2 id=五总结>五、总结<a hidden class=anchor aria-hidden=true href=#五总结>#</a></h2><p>类加载器主要分为为“启动类加载器”、“扩展类加载器(平台类加载器)”、“应用程序类加载器”及“自定义类加载器”。</p><p>大部分类加载器都有父类加载器，类加载器会优先从它的父类加载器中去执行加载行为，这一过程被称之为“双亲委派”。在某些场景，可以破坏双亲委派。</p><blockquote><p>参考文档</p></blockquote><ol><li>《深入理解Java虚拟机第3版 周志明 著》</li></ol></div><footer class=post-footer><ul class=post-tags><li><a href=https://blog.luanrz.cn/tags/java/>Java</a></li><li><a href=https://blog.luanrz.cn/tags/jvm/>JVM</a></li></ul><nav class=paginav><a class=prev href=https://blog.luanrz.cn/posts/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/java%E6%8A%80%E8%83%BD%E6%A0%91/><span class=title>« Prev</span><br><span>Java技能树</span></a>
<a class=next href=https://blog.luanrz.cn/posts/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/maven%E4%BE%9D%E8%B5%96%E6%9C%BA%E5%88%B6%E6%B5%85%E6%9E%90/><span class=title>Next »</span><br><span>Maven依赖机制浅析</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2022 <a href=https://blog.luanrz.cn/>luanrz's blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>