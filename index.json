[{"content":"Hugo是使用Go语言实现的静态博客生成工具，它的构建速度比Hexo更快。\n一、安装Hugo 以Linux与Mac为例，Hugo安装指令如下所示：\npacman -S hugo # ArchLinux brew install hugo #MacOS 在命令行输入hugo version，正确显示了版本号，即证明安装成功了。更详细的安装过程可参见hugo官方安装教程\n二、初始Hugo化项目 （一）新建站点 hugo new site hugodemo cd hugodemo git init （二）新建文章 hugo new posts/hello.md 新建文章时，会依据archetypes/default.md为模版创建文件，文件将被放在content文件夹下面，hello.md的内容如下所示：\n--- title: \u0026#34;Hello\u0026#34; date: 2022-10-17T21:07:47+08:00 draft: true --- （三）增加主题 主题位于themes文件夹下，可以使用Git子模块导入喜欢的主题，以PaperMod主题为例：\ngit submodule add --depth=1 https://github.com/adityatelange/hugo-PaperMod.git themes/PaperMod git submodule update --init --recursive # 仅在后续重新拉取hugodemo项目时，才需要执行此命令 （四）启动Hugo hugo server -t PaperMod -D server指令表示启动Hugo服务。\n-t(--theme)指定了主题名，后续也可以在配置文件中指定主题。\n-D(--buildDrafts)表示编译文章头部的draft标识为true的草稿文章，刚刚创建的hello.md就是一篇草稿文章。\n（五）访问站点 在终端执行curl http://localhost:1313，或在浏览器中访问http://localhost:1313，即可看到应用启动成功，刚刚写的第一篇hello文章显示在了首页。\n三、配置PaperMod主题 未经配置的PaperMod页面还不太完整，下面将简单介绍PaperMod主题的配置过程。\n首先，将根目录的config.toml重命名为config.yml，并将其中的= 换成:。随后，继续编辑config.yml，完整的配置文件如下：\nbaseURL: \u0026#34;https://blog.luanrz.cn/\u0026#34; languageCode: \u0026#34;zh-cn\u0026#34; title: luanrz\u0026#39;s blog paginate: 5 theme: PaperMod # 右上角菜单项 menu: main: - identifier: home name: 首页 url: / weight: 10 - identifier: search name: 搜索 url: /search/ weight: 20 - identifier: archives name: 归档 url: /archives/ weight: 30 - identifier: categories name: 分类 url: /categories/ weight: 40 - identifier: tags name: 标签 url: /tags/ weight: 50 # 与Search搭配使用 outputs: home: - HTML - RSS - JSON # 必填，不加此节点Search无法使用 params: defaultTheme: auto # 主题颜色：auto、dark、light disableSpecial1stPost: true # 在Regular模式下禁用Home-Info区域，该开关在Home-Info模式和Profile模式无意义 hideSummary: true # 隐藏文章列表项的概述信息 hidemeta: true # 隐藏文章列表项的元数据，如：ReadingTime、WordCount等等 ShowReadingTime: true # 显示读完的预计时间（hidemeta为false才有意义） ShowWordCount: true # 显示统计字数（hidemeta为false才有意义） ShowCodeCopyButtons: true # 显示代码中的复制按钮 ShowPostNavLinks: true # 显示文章中上一篇和下一篇的链接 ShowBreadCrumbs: false # 显示面包屑导航 showtoc: false # 显示目录 tocopen: false # 显示的目录默认处于打开状态（showtoc为true才有意义） label: text: \u0026#34;luanrz\u0026#39;s blog\u0026#34; # 左上角logo区域的文字，如果不填将以全局的title值为准 # Home-Info homeInfoParams: Title: \u0026#34;luanrz的个人博客\u0026#34; # Home-Info区域的标题 Content: \u0026#34;“心有所向，日服一日，必有精进”\u0026#34; # Home-Info区域的内容 socialIcons: - name: bilibili # B站 url: \u0026#34;https://space.bilibili.com/31949997\u0026#34; - name: github # Github url: \u0026#34;https://github.com/luanrz\u0026#34; 上述配置中有两个菜单项需要新建对应的文件，如下所示：\n新建archives.md以支持归档功能\nvim content/archive.md --- title: \u0026#34;Archives\u0026#34; layout: \u0026#34;archives\u0026#34; url: \u0026#34;/archives/\u0026#34; --- 新建search.md以支持搜索功能\nvim content/search.md --- title: \u0026#34;Search\u0026#34; layout: \u0026#34;search\u0026#34; placeholder: \u0026#34;输入关键字搜索文章\u0026#34; --- 最后，再次重启项目，可以看到首页已经焕然一新。\n四、Hexo的迁移建议 此章节适用于希望将老的Hexo的博客全部迁移到新的Hugo的场景。\n（一）文章结构微调 首先，Hexo文章头部的描述信息大多数可以直接平移，无需额外修改。但Hugo的description不支持markdown及html语法，建议将对应的description信息挪到文章正文。\n同时，Hugo不支持Hexo的Tabs标签语法，可以删掉对应的Tabs标签或使用hugo对应Shortcodes语法。\n（二）内部超链接 Hugo中Markdown对应的标题生成超链接锚点时，会执行下述操作：将大写字母替换成小写字母、将、与（）等符号去掉。\n以## （一）PaperMod为例，它的超链接锚点会变成一papermod，如果要在文章内部引用它，可以使用[The PaperMod](#一papermod)\n（三）支持PlantUML PlantUML是一种文本画图的工具，Hexo的Next主题原生支持PlantUML。Hugo现在还没有原生支持PlantUML，根据其github的讨论记录，可能后续会支持。\n现在的解决方案是自定义js，将PlantUML文本传输到http://plantuml.com/在线生成图片并回写到页面。可参考下述自定义脚本：\n\u0026lt;!-- 引入自定义脚本，渲染plantuml（此种方式引入脚本不太优雅，后续寻找更合适的方式） --\u0026gt; \u0026lt;!-- 参见 https://ttys3.dev/post/add-plantuml-support-to-hugo/ 与 https://mogeko.me/posts/zh-cn/083/ --\u0026gt; \u0026lt;script\u0026gt; const loadScript = (url, onloadFunction) =\u0026gt; { var newScript = document.createElement(\u0026#34;script\u0026#34;); newScript.onerror = (oError) =\u0026gt; { throw new URIError(\u0026#34;The script \u0026#34; + oError.target.src + \u0026#34; didn\u0026#39;t load correctly.\u0026#34;); }; if (onloadFunction) { newScript.onload = onloadFunction; } document.head.insertAdjacentElement(\u0026#39;beforeend\u0026#39;, newScript); newScript.src = url; } const loadPlantUMLOnNeed = () =\u0026gt; { let plantumlPrefix = \u0026#34;language-plantuml\u0026#34;; if (document.querySelectorAll(\u0026#34;[class^=\u0026#34; + plantumlPrefix + \u0026#34;]\u0026#34;).length \u0026gt; 0) { loadScript(\u0026#39;https://cdn.jsdelivr.net/gh/jmnote/plantuml-encoder@1.2.4/dist/plantuml-encoder.min.js\u0026#39;, () =\u0026gt; { (function () { Array.prototype.forEach.call(document.querySelectorAll(\u0026#34;[class^=\u0026#34; + plantumlPrefix + \u0026#34;]\u0026#34;), function (code) { let image = document.createElement(\u0026#34;IMG\u0026#34;); image.loading = \u0026#39;lazy\u0026#39;; // Lazy loading image.src = \u0026#39;http://www.plantuml.com/plantuml/svg/~1\u0026#39; + plantumlEncoder.encode(code.innerText); code.parentNode.insertBefore(image, code); code.style.display = \u0026#39;none\u0026#39;; }); })(); console.log(\u0026#34;PlantUML init done\u0026#34;); }) } } window.addEventListener(\u0026#39;load\u0026#39;, function (event) { // load PlantUML loadPlantUMLOnNeed(); }) \u0026lt;/script\u0026gt; 参考文档\nHugo官方入门手册 PaperMod安装教程 给Hugo博客添加PlantUML支持 在Hugo博客上使用PlantUML ","permalink":"https://blog.luanrz.cn/posts/%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/hugo%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/","summary":"Hugo是使用Go语言实现的静态博客生成工具，它的构建速度比Hexo更快。\n一、安装Hugo 以Linux与Mac为例，Hugo安装指令如下所示：\npacman -S hugo # ArchLinux brew install hugo #MacOS 在命令行输入hugo version，正确显示了版本号，即证明安装成功了。更详细的安装过程可参见hugo官方安装教程\n二、初始Hugo化项目 （一）新建站点 hugo new site hugodemo cd hugodemo git init （二）新建文章 hugo new posts/hello.md 新建文章时，会依据archetypes/default.md为模版创建文件，文件将被放在content文件夹下面，hello.md的内容如下所示：\n--- title: \u0026#34;Hello\u0026#34; date: 2022-10-17T21:07:47+08:00 draft: true --- （三）增加主题 主题位于themes文件夹下，可以使用Git子模块导入喜欢的主题，以PaperMod主题为例：\ngit submodule add --depth=1 https://github.com/adityatelange/hugo-PaperMod.git themes/PaperMod git submodule update --init --recursive # 仅在后续重新拉取hugodemo项目时，才需要执行此命令 （四）启动Hugo hugo server -t PaperMod -D server指令表示启动Hugo服务。\n-t(--theme)指定了主题名，后续也可以在配置文件中指定主题。\n-D(--buildDrafts)表示编译文章头部的draft标识为true的草稿文章，刚刚创建的hello.md就是一篇草稿文章。\n（五）访问站点 在终端执行curl http://localhost:1313，或在浏览器中访问http://localhost:1313，即可看到应用启动成功，刚刚写的第一篇hello文章显示在了首页。\n三、配置PaperMod主题 未经配置的PaperMod页面还不太完整，下面将简单介绍PaperMod主题的配置过程。\n首先，将根目录的config.toml重命名为config.yml，并将其中的= 换成:。随后，继续编辑config.yml，完整的配置文件如下：\nbaseURL: \u0026#34;https://blog.luanrz.cn/\u0026#34; languageCode: \u0026#34;zh-cn\u0026#34; title: luanrz\u0026#39;s blog paginate: 5 theme: PaperMod # 右上角菜单项 menu: main: - identifier: home name: 首页 url: / weight: 10 - identifier: search name: 搜索 url: /search/ weight: 20 - identifier: archives name: 归档 url: /archives/ weight: 30 - identifier: categories name: 分类 url: /categories/ weight: 40 - identifier: tags name: 标签 url: /tags/ weight: 50 # 与Search搭配使用 outputs: home: - HTML - RSS - JSON # 必填，不加此节点Search无法使用 params: defaultTheme: auto # 主题颜色：auto、dark、light disableSpecial1stPost: true # 在Regular模式下禁用Home-Info区域，该开关在Home-Info模式和Profile模式无意义 hideSummary: true # 隐藏文章列表项的概述信息 hidemeta: true # 隐藏文章列表项的元数据，如：ReadingTime、WordCount等等 ShowReadingTime: true # 显示读完的预计时间（hidemeta为false才有意义） ShowWordCount: true # 显示统计字数（hidemeta为false才有意义） ShowCodeCopyButtons: true # 显示代码中的复制按钮 ShowPostNavLinks: true # 显示文章中上一篇和下一篇的链接 ShowBreadCrumbs: false # 显示面包屑导航 showtoc: false # 显示目录 tocopen: false # 显示的目录默认处于打开状态（showtoc为true才有意义） label: text: \u0026#34;luanrz\u0026#39;s blog\u0026#34; # 左上角logo区域的文字，如果不填将以全局的title值为准 # Home-Info homeInfoParams: Title: \u0026#34;luanrz的个人博客\u0026#34; # Home-Info区域的标题 Content: \u0026#34;“心有所向，日服一日，必有精进”\u0026#34; # Home-Info区域的内容 socialIcons: - name: bilibili # B站 url: \u0026#34;https://space.","title":"Hugo快速上手"},{"content":"HashMap是Java中一种常见的集合实现，在不同的jdk版本中，HashMap的实现也不同。本文将以jdk8为主，从源码层面简单分析一下HashMap的存储结构与读写过程，最后简单介绍一下高并发下HashMap的使用方法。\n一、前言 Java有三种常见的集合：List、Set与Map，本文将介绍的HashMap是Map集合的一种实现，HashMap在集合中的位置如下所示：\n@startuml Java三大集合类图 title Java三大集合类图 interface Collection interface List interface Set interface Map class ArrayList class LinkedList class HashSet class HashMap #Pink Collection \u0026lt;|-- List Collection \u0026lt;|-- Set List \u0026lt;|.. ArrayList List \u0026lt;|.. LinkedList Set \u0026lt;|.. HashSet Map \u0026lt;|.. HashMap @enduml Map有四个主要的实现，它们的关系如下所示：\n@startuml Map类图 title Map类图 interface Map class HashMap #Pink class LinkedHashMap #LightBlue class TreeMap #LightBlue class Hashtable #LightBlue abstract AbstractMap interface NavigableMap interface SortedMap Map \u0026lt;|.. AbstractMap AbstractMap \u0026lt;|-- HashMap HashMap \u0026lt;|-- LinkedHashMap Map \u0026lt;|-- SortedMap SortedMap \u0026lt;|-- NavigableMap NavigableMap \u0026lt;|.. TreeMap AbstractMap \u0026lt;|-- TreeMap Map \u0026lt;|.. Hashtable @enduml Hashtable是老版的HashMap，已不被建议使用;LinkedHashMap可以保证先写入的元素优先读取;TreeMap可以按照键进行排序。本文主要介绍HashMap，剩下的三个实现类不会涉及。\n二、HashMap的存储结构 jdk7及以前版本中，HashMap的数据存储结构为数组 + 链表，该结构可以有效解决哈希冲突，通常将之称为链地址法。(也可以使用开放定址法解决哈希冲突，这种方法一般只使用数组结构)\njdk8及以后版本中，HashMap的数据存储结构为数组 + 链表/红黑树，出于性能考虑，jdk8的HsahMap新增了红黑树。在一定情况下链表与红黑树会相互转换(参见下文)。\n当前jdk版本为18，后续版本如有变更，请以实际版本为准。\n接下来看一看HashMap存储结构的源码定义。\n数组 transient Node\u0026lt;K,V\u0026gt;[] table; table定义是HashMap存储结构的关键，它是一个以Node为元素的数组，其中Node元素可以是一个链表节点，也可以是一个红黑树节点(TreeNode)。\n链表节点 static class Node\u0026lt;K,V\u0026gt; implements Map.Entry\u0026lt;K,V\u0026gt; { final int hash; final K key; V value; Node\u0026lt;K,V\u0026gt; next; } 链表节点Node是一个单向的链表，它的next属性指向下一个Node元素。\n红黑树节点 static final class TreeNode\u0026lt;K,V\u0026gt; extends LinkedHashMap.Entry\u0026lt;K,V\u0026gt; { TreeNode\u0026lt;K,V\u0026gt; parent; // red-black tree links TreeNode\u0026lt;K,V\u0026gt; left; TreeNode\u0026lt;K,V\u0026gt; right; TreeNode\u0026lt;K,V\u0026gt; prev; // needed to unlink next upon deletion boolean red; } 红黑树节点TreeNode在Node的基础上增加了红黑树的相关属性:父节点、左右孩子节点等等。\n三、HashMap的读写过程 HashMap的put和get方法可以实现元素的读写。\n（一）HashMap的写操作过程 HashMap的put方法的源码如下所示：\npublic V put(K key, V value) { return putVal(hash(key), key, value, false, true); } final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) { Node\u0026lt;K,V\u0026gt;[] tab; Node\u0026lt;K,V\u0026gt; p; int n, i; if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; if ((p = tab[i = (n - 1) \u0026amp; hash]) == null) tab[i] = newNode(hash, key, value, null); else { Node\u0026lt;K,V\u0026gt; e; K k; if (p.hash == hash \u0026amp;\u0026amp; ((k = p.key) == key || (key != null \u0026amp;\u0026amp; key.equals(k)))) e = p; else if (p instanceof TreeNode) e = ((TreeNode\u0026lt;K,V\u0026gt;)p).putTreeVal(this, tab, hash, key, value); else { for (int binCount = 0; ; ++binCount) { if ((e = p.next) == null) { p.next = newNode(hash, key, value, null); if (binCount \u0026gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); break; } if (e.hash == hash \u0026amp;\u0026amp; ((k = e.key) == key || (key != null \u0026amp;\u0026amp; key.equals(k)))) break; p = e; } } if (e != null) { // existing mapping for key V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue; } } ++modCount; if (++size \u0026gt; threshold) resize(); afterNodeInsertion(evict); return null; } 根据上述源码，HashMap的写过程主要会执行以下操作：\n初始化table空间 如果数组没有发生hash冲突时：直接将新节点放入数组中 如果数组发生hash冲突时： 如果待存放的节点与冲突节点一样：直接返回冲突节点 如果待存放的节点是TreeNode类型：进行红黑树插入操作 否则：进行链表插入操作，并按需执行红黑树转化 后续处理 红黑树转化的转换条件如下所示：\nif (binCount \u0026gt;= TREEIFY_THRESHOLD - 1) treeifyBin(tab, hash); 当链表节点数超过TREEIFY_THRESHOLD(默认为8)时，执行treeify操作，将链表转换成红黑树。该过程一般发生在put等方法中。\n同时，当红黑树节点数低于UNTREEIFY_THRESHOLD(默认为6)时，执行untreeify操作，将红黑树退化成链表。该过程一般发生remove或resize等方法时。\n（二）HashMap的读操作过程 HashMap的get方法的源码如下所示：\npublic V get(Object key) { Node\u0026lt;K,V\u0026gt; e; return (e = getNode(hash(key), key)) == null ? null : e.value; } final Node\u0026lt;K,V\u0026gt; getNode(int hash, Object key) { Node\u0026lt;K,V\u0026gt;[] tab; Node\u0026lt;K,V\u0026gt; first, e; int n; K k; if ((tab = table) != null \u0026amp;\u0026amp; (n = tab.length) \u0026gt; 0 \u0026amp;\u0026amp; (first = tab[(n - 1) \u0026amp; hash]) != null) { if (first.hash == hash \u0026amp;\u0026amp; // always check first node ((k = first.key) == key || (key != null \u0026amp;\u0026amp; key.equals(k)))) return first; if ((e = first.next) != null) { if (first instanceof TreeNode) return ((TreeNode\u0026lt;K,V\u0026gt;)first).getTreeNode(hash, key); do { if (e.hash == hash \u0026amp;\u0026amp; ((k = e.key) == key || (key != null \u0026amp;\u0026amp; key.equals(k)))) return e; } while ((e = e.next) != null); } } return null; } 可以看到，HashMap的读操作的寻址链路，和写操作基本一致，这里就不再赘述了。\n四、高并发下的HashMap HashMap不是线程安全的，这意味着，高并发下多个线程同时读写同一个HashMap时，会产生数据不一致的问题。有以下了两种方式可以避免这种情况：\n使用SynchronizedMap类(通过Collections的synchronizedMap方法构造) 使用ConcurrentHashMap类 手动加锁与HashTable也可以实现类似功能，但不太建议使用。\n下面将简单介绍一下上述两种方法的使用。\n（一）使用SynchronizedMap类支持HashMap的高并发 如果想复用已有的HashMap对象，可以使用Collections.synchronizedMap(Map m)方法将其包裹起来即可，如下所示：\nMap synchronizedMap = Collections.synchronizedMap(new HashMap()); synchronizedMap方法会返回一个SynchronizedMap实例，SynchronizedMap的所有方法都是用synchronized进行了修饰，以get方法为例：\npublic V get(Object key) { synchronized (mutex) {return m.get(key);} // mutex表示传入的HashMap实例 } （二）使用ConcurrentHashMap类支持HashMap的高并发 与synchronizedMap相比，ConcurrentHashMap有更高的性能。ConcurrentHashMap的实例化过程如下所示：\nMap concurrentMap = new ConcurrentHashMap\u0026lt;\u0026gt;(); ConcurrentHashMap的实现方法在jdk7与jdk8中也有较大差异，此处暂不做展开说明。\n五、总结 本文主要介绍了以下几个点：\nHashMap是Java三大集合Map的一种实现，Map的四个实现分别是HashMap、Hashtable、LinkedHashMap及TreeMap。 HashMap的存储结构为数组 + 链表/红黑树，链表和红黑树在一定情况下可以相互转换(适用于jdk8)。 HashMap的读写顺序分别是:数组 -\u0026gt; 红黑树 -\u0026gt; 链表。 HashMap的高并发场景下，可以使用SynchronizedMap与ConcurrentHashMap类。 有关HashMap更详细的内容暂时没有涉及，如hash索引生成方式、链表与红黑树转化treeify与untreeify的实现方式、红黑树的细节等等，后续将按需探讨。\n参考文档\nHashMap (Java Platform SE 8 ) Java 8系列之重新认识HashMap ","permalink":"https://blog.luanrz.cn/posts/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/hashmap%E5%8E%9F%E7%90%86%E6%B5%85%E6%9E%90/","summary":"\u003cp\u003eHashMap是Java中一种常见的集合实现，在不同的jdk版本中，HashMap的实现也不同。本文将以jdk8为主，从源码层面简单分析一下HashMap的存储结构与读写过程，最后简单介绍一下高并发下HashMap的使用方法。\u003c/p\u003e","title":"HashMap原理浅析"},{"content":"今天经历了工作后的第一次面试，发现自己有很多知识点没有掌握。接下来将复盘一下整个面试过程，并梳理一下后续查漏补缺的要点。\n一、面试过程 自我介绍\n名字、公司、工作年限、技术栈、项目职责、最近负责的重点事项、其它\n面试官介绍公司需要的技术要点\n高可用、云原生、K8S、服务网格、流量治理、分布式数据库、分布式调度、分布式数据同步等\nPrometheus的搭建方式（简历中有写Prometheus）\n使用原生包搭建，未维护在k8s中。\n最近做的项目的主要功能、技术要点以及难点\n性能测试过程中发现高并发下“socket reset”与调用接口过慢的现象。使用okhttp替换RestTemplate原生的HttpClient和单例的RestTemplate解决问题\n使用okhttp替换HttpClient的原因\nHttpClient默认是短连接、okhttp默认是长连接，高并发下可以复用连接资源\n（IO相关）对IO中的netty有了解吗，讲一下netty中比较重要的三个组成部分（channel、buffer），如何实现请求复用\n性能测试中使用netty模拟底层服务。组成部分与请求复用方式不太清楚。\n（微服务相关）使用的SpringCloud原生还是Alibaba\n使用SpringCloud原生（Eureka那一套）\nEureka的自我保护机制与心跳机制\n不太清楚（纯使用，没有了解底层原理）\n除了使用Eureka还使用了什么\ngateway、redission\n（分布式锁相关）有了解过redis与redission的区别吗，redission如何解决分布式锁不靠谱的问题，红锁算法有了解过吗\n不太清楚。\nredission主要是用在哪个业务场景\n订单加锁时的分布式锁场景\n如何保证最终一致性（redisson可能会不靠谱）\n定时任务判断状态\n（集合相关）HashMap的数据结构（数组、链表、红黑树等）\n不太清楚\n（JVM相关）JVM的整体组成（内存区域）\n栈、堆（其它的因为紧张没想起来）\n栈的组成和使用场景\n栈报错了方法的出口与局部变量表等内容，存放对象的引用。\n了解栈帧吗\n不太了解\n有设置过JVM参数吗？如何判断这些值的范围\n有设置过最大堆的最小空间与初始空间以及线程栈的空间\n如何设置这些值暂时不太清楚\n能讲一下K8S几个重要的组件吗？etcd了解吗？（阅读博客后）\ndeployment、service、pod等（这里答错了，面试官想问apiserver，这个暂时没有了解），etcd不了解\n（Java锁相关）能讲一下Synchronized与ReentrantLock的区别吗？它们两个都是公平锁吗？知道ReentrantLock的可重入、可中断、可轮询相关概念吗？（阅读博客后）\nSynchronized是Java原生提供的语法，Lock是jdk5后新增的语法，它们大部分场景能否通用，Lock有更强的灵活性。\nReentrantLock可以通过fair参数设置公平性，Synchronized的公平性不太清楚（不公平锁）\n可重入是指一个线程可以同时持有多次锁，在递归场景经常遇到，他的重入次数与重出次数要相等时，锁才会释放。可中断与可轮询两个概念还不太清楚，\n（数据库相关）了解MySql的索引吗，知道B+树吗\n不太清楚。\n二、要点分析 梳理一下上述问题，主要涉及到以下几个要点：\n自我介绍\n最近做的项目的主要功能、技术要点以及难点。并根据回答的情况针对性提问。\nIO相关（如netty的原理）\n集合相关（如HashMap的原理）\n多线程相关（如Java锁中，Lock与Synchronized的区别、ReentrantLock的公平性、可重入、可中断、可轮询）\n微服务相关（如Eureka的自我保护机制与心跳机制）\n分布式相关（如redission分布式锁、最终一致性的实现方式）\nJVM相关（如JVM的内存区域、栈的使用场景、栈帧的概念、JVM参数的设置与值的选择依据）\n容器相关（如K8S的几个组件、以及etcd）\n数据库相关（如MySql的索引与B+树）\n三、查漏补缺 上述涉及到原理的部分知之甚少，这也导致了很大一部分的回答都是“不太清楚”。虽然面试官人很好一直在鼓励式提问，但还是掩盖不了自己很菜的事实。这是一次宝贵的面试经历，后面需要继续学习此次理解不够深的地方，并在后面重新作答。\n如果再来一次，上面的问题能答得上来吗？\n// TODO 重新作答（限定时间：两周）\n根据上述要点，划分为以下几个专题：\nNetty请求复用实现机制浅析\nHashMap原理浅析\n再探ReentrantLock：公平性、可重入、可中断、可轮询\nEureka的自我保护机制与心跳机制浅析\n分布式锁redission简介\nJVM内存区域简介\n之前总结过，需要继续优化与完善\nkubernetes体系结构简介\nMySql索引与B+树简介\n","permalink":"https://blog.luanrz.cn/posts/%E7%94%9F%E6%B4%BB%E6%9D%82%E8%AE%B0/%E7%AC%AC%E4%B8%80%E6%AC%A1%E9%9D%A2%E8%AF%95%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95%E4%B8%8E%E8%A6%81%E7%82%B9%E6%A2%B3%E7%90%86/","summary":"\u003cp\u003e今天经历了工作后的第一次面试，发现自己有很多知识点没有掌握。接下来将复盘一下整个面试过程，并梳理一下后续查漏补缺的要点。\u003c/p\u003e","title":"第一次面试过程记录与要点梳理"},{"content":"一般来说，Java中每一个任务都与其对应的线程共享生命周期，任务执行完毕后其线程也会跟着销毁，随着任务数量的增加，重复创建线程所带来的消耗所产生的性能影响也会更显著。线程池提供了一种复用多个线程的方案，以此避免无谓的线程创建，它通过管理线程们的生命周期和调度方式，为任务的批量执行提供更强的灵活性。\n线程池主要是指ThreadPoolExecutor类，本文将围绕ThreadPoolExecutor类及其相关类，展开对线程池的介绍。\n一、线程池核心类之间的关系 线程池的核心类位于JUC包(即java.util.concurrent包)，该包保存了Java并发的大多数类，如：锁、阻塞队列、线程池等。\nJUC下的线程池由若干核心类，他们的关系如下所示：\n@startuml Java线程池类图 title Java线程池类图 interface Executor interface ExecutorService #Pink abstract class AbstractExecutorService class ThreadPoolExecutor #LightBlue interface ScheduledExecutorService class ScheduledThreadPoolExecutor interface Future class FutureTask interface Runnable interface Callable class Executors Executor \u0026lt;|-- ExecutorService ExecutorService \u0026lt;|.. AbstractExecutorService AbstractExecutorService \u0026lt;|-- ThreadPoolExecutor ExecutorService \u0026lt;|-- ScheduledExecutorService ThreadPoolExecutor \u0026lt;|-- ScheduledThreadPoolExecutor ScheduledExecutorService \u0026lt;|.. ScheduledThreadPoolExecutor ExecutorService -left-\u0026gt; Future AbstractExecutorService -left-\u0026gt; FutureTask Future \u0026lt;|-- FutureTask Executor -right-\u0026gt; Runnable ExecutorService -right-\u0026gt; Callable Executors -right-\u0026gt; ThreadPoolExecutor @enduml 如果将上述类限定在线程池这一使用场景下，那么它们有以下分类：\nThreadPoolExecutor类是线程池本体 ScheduledExecutorService与ScheduledThreadPoolExecutor是支持延时任务的线程池变体 Executor、ExecutorService与AbstractExecutorService是线程池的抽象定义 Runnable和Runnable是线程池执行的任务 Future和FutureTask是线程池异步执行的结果 Executors是用于创建线程池的工具 当然，Executor等接口或类还有其它的应用场景，本文只限定于线程池场景。\n二、ThreadPoolExecutor的使用 （一）定义线程池 在使用线程池之前，需要先定义ThreadPoolExecutor，ThreadPoolExecutor的主要构造函数如下所示：\npublic ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue\u0026lt;Runnable\u0026gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) { 上述参数的含义为：\n参数 含义 int corePoolSize 核心线程容量 int maximumPoolSize 最大线程容量( = 核心线程容量 + 非核心线程容量 ) long keepAliveTime 非核心线程存活时间(如果设置了allowCoreThreadTimeOut，也对核心线程有效) TimeUnit unit 存活时间单位 BlockingQueue workQueue 等待队列 ThreadFactory threadFactory 线程创建工厂 RejectedExecutionHandler handler 饱和时的拒绝策略 核心线程池有三个抽象区域：核心线程区、非核心线程区以及等待队列。分别对应了上述的corePoolSize、maximumPoolSize以及workQueue，其中，maximumPoolSize为最大线程容量，maximumPoolSize-corePoolSize即是非核心线程容量。\n同时，最大并发数 = 最大线程容量 + 等待队列容量。\n也有，最大并发数 = 核心线程容量 + 非核心线程容量 + 等待队列容量。\n当设置完上述三个值后，线程池的处理上限也将基本确定。后续将按照核心线程池 -\u0026gt; 等待队列 -\u0026gt; 非核心线程池的顺序依次执行任务，有关线程池的内部逻辑，详见后文ThreadPoolExecutor原理浅析。\n一般建议直接使用ThreadPoolExecutor的构造方法来实例化线程池，这样更容易通过参数识别线程池的关键属性。当然，为了简单起见，也可以使用Executors的系列方法：newFixedThreadPool()、newSingleThreadExecutor()与newScheduledThreadPool()，下面以newFixedThreadPool()为例来初始化一个线程池：\n// 1.定义线程池 ExecutorService threadPoolExecutor = Executors.newFixedThreadPool(10); Executors的newxxxThreadPool()系列方法是对ThreadPoolExecutor构造方法的简单封装，可以用它来快速创建一个默认的线程池。但是，如果你的本地IDE环境安装了阿里巴巴的规范插件，使用Executors时可能会收到到一条警告：不建议使用Executors的newxxxThreadPool()系列方法，那是因为Executors有默认使用无界阻塞队列的情况，可能会导致内存泄露，同时，Executors掩盖了创建线程池的细节，没法快速识别线程池的关键属性。当然，最终是否要使用Executors就见仁见智了。\n（二）使用线程池 线程池有两种执行方式：同步执行与异步执行。\n1. 同步执行 同步执行会阻塞当前线程，直到任务执行完毕。\n可以使用Executor的void execute(Runnable command)方法来实现同步执行，如下所示：\n// 2. 使用线程池:同步执行 Runnable synchronousTask = new Thread(); threadPoolExecutor.execute(synchronousTask); 2. 异步执行 异步执行不会阻塞当前线程，执行的结果会存放在Future对象中，这个对象一般也是FutureTask对象。\n可以使用执行ExecutorService的submit()系列方法来异步执行，submit()有三个重载方法，如下所示：\n\u0026lt;T\u0026gt; Future\u0026lt;T\u0026gt; submit(Callable\u0026lt;T\u0026gt; task); \u0026lt;T\u0026gt; Future\u0026lt;T\u0026gt; submit(Runnable task, T result); Future\u0026lt;?\u0026gt; submit(Runnable task); 上述重载方法中，Runnable参数最终也会转换成Callable。以Future\u0026lt;?\u0026gt; submit(Runnable task)为例，异步执行任务的使用方法如下所示：\n// 3. 使用线程池:异步执行 Runnable asynchronousTask = new Thread(); Future\u0026lt;?\u0026gt; future = threadPoolExecutor.submit(asynchronousTask); //Object object = future.get(); submit()本身是异步的，最终得到future后，调用future.get()可以得到结果，此时的get()是同步的。\n（三）关闭线程池 使用完线程池后，需要将之关闭以节省资源。\n关闭线程池可以使用shutdown()或shutdownNow()，它们的区别是：shutdown()会在执行完正在运行的线程后退出，等待中的线程将被丢弃；shutdownNow()则会直接停止正在运行的线程，并将未执行的任务返回(包括正在运行的线程和等待中的线程)。\n关闭线程池的使用方法如下所示：\n// 4. 关闭线程池 threadPoolExecutor.shutdown(); //threadPoolExecutor.shutdownNow(); （四）完整的例子 上述定义线程池、使用线程池及关闭线程池的完整例子如下：\n// 1.定义线程池 ExecutorService threadPoolExecutor = Executors.newFixedThreadPool(10); // 2. 使用线程池:同步执行 Runnable synchronousTask = new Thread(); threadPoolExecutor.execute(synchronousTask); // 3. 使用线程池:异步执行 Runnable asynchronousTask = new Thread(); Future\u0026lt;?\u0026gt; future = threadPoolExecutor.submit(asynchronousTask); //Object object = future.get(); // 4. 关闭线程池 threadPoolExecutor.shutdown(); //threadPoolExecutor.shutdownNow(); 三、ThreadPoolExecutor原理浅析 ThreadPoolExecutor的核心处理逻辑位于execute方法中，该方法在jdk6与jdk7中有些许差异，如下所示：\njdk6及以前的execute方法 public void execute(Runnable command) { if (command == null) throw new NullPointerException(); if (poolSize \u0026gt;= corePoolSize || !addIfUnderCorePoolSize(command)) { if (runState == RUNNING \u0026amp;\u0026amp; workQueue.offer(command)) { if (runState != RUNNING || poolSize == 0) ensureQueuedTaskHandled(command); } else if (!addIfUnderMaximumPoolSize(command)) reject(command); } } jdk7及以后的execute方法 public void execute(Runnable command) { if (command == null) throw new NullPointerException(); int c = ctl.get(); if (workerCountOf(c) \u0026lt; corePoolSize) { if (addWorker(command, true)) return; c = ctl.get(); } if (isRunning(c) \u0026amp;\u0026amp; workQueue.offer(command)) { int recheck = ctl.get(); if (! isRunning(recheck) \u0026amp;\u0026amp; remove(command)) reject(command); else if (workerCountOf(recheck) == 0) addWorker(null, false); } else if (!addWorker(command, false)) reject(command); } // TODO\n参考文档\n《Java并发编程的艺术 方腾飞 魏鹏 程晓明 著》 ","permalink":"https://blog.luanrz.cn/posts/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%AE%80%E4%BB%8B/","summary":"\u003cp\u003e一般来说，Java中每一个任务都与其对应的线程共享生命周期，任务执行完毕后其线程也会跟着销毁，随着任务数量的增加，重复创建线程所带来的消耗所产生的性能影响也会更显著。线程池提供了一种复用多个线程的方案，以此避免无谓的线程创建，它通过管理线程们的生命周期和调度方式，为任务的批量执行提供更强的灵活性。\u003c/p\u003e\n\u003cp\u003e线程池主要是指\u003ccode\u003eThreadPoolExecutor\u003c/code\u003e类，本文将围绕\u003ccode\u003eThreadPoolExecutor\u003c/code\u003e类及其相关类，展开对线程池的介绍。\u003c/p\u003e","title":"Java线程池简介"},{"content":"Java阻塞队列是一种可以实现阻塞插入和阻塞移除的特殊队列，它被广泛应用于生产者消费者模式。如在线程池中，可以使用LinkedBlockingQueue与SynchronousQueue等阻塞队列来生产与消费线程对象。\n下面将简单介绍Java中常用的几个阻塞队列。\n一、阻塞队列汇总 阻塞队列位于JUC包(即java.util.concurrent包)，该包保存了Java并发的大多数类，如：锁、阻塞队列、线程池等。\nJUC下的阻塞队列共有3个接口与7个实现类，他们的关系如下所示：\n@startuml Java阻塞队列类图 title Java阻塞队列类图 class ArrayBlockingQueue interface BlockingDeque interface BlockingQueue class DelayQueue class LinkedBlockingDeque class LinkedBlockingQueue class LinkedTransferQueue class PriorityBlockingQueue class SynchronousQueue interface TransferQueue BlockingQueue \u0026lt;|.. ArrayBlockingQueue BlockingQueue \u0026lt;|-- BlockingDeque BlockingQueue \u0026lt;|.. DelayQueue BlockingQueue \u0026lt;|.. LinkedBlockingQueue BlockingQueue \u0026lt;|.. PriorityBlockingQueue BlockingQueue \u0026lt;|.. SynchronousQueue BlockingQueue \u0026lt;|-- TransferQueue BlockingDeque \u0026lt;|.. LinkedBlockingDeque TransferQueue \u0026lt;|.. LinkedTransferQueue @enduml 上述类图中，BlockingQueue是阻塞队列的顶层接口，BlockingDeque与TransferQueue则是继承自BlockingQueue的两个用于实现特殊功能的接口。剩下的7个阻塞队列实现类均实现了上述3个接口，它们如下所示：\n阻塞队列类 JDK版本 有界性 ArrayBlockingQueue 5 有界(bounded) LinkedBlockingQueue 5 有界(optionally-bounded) PriorityBlockingQueue 5 无界(unbounded) DelayQueue 5 无界(unbounded) SynchronousQueue 5 - LinkedBlockingDeque 6 有界(optionally-bounded) LinkedTransferQueue 7 无界(unbounded) 除了阻塞队列外，JUC包下还有一个非阻塞队列：ConcurrentLinkedQueue，该类不在本节讨论之中。\n二、阻塞队列概述 （一）阻塞队列的抽象定义：BlockingQueue BlockingQueue定义了阻塞队列的抽象结构，所有的阻塞队列都需要实现它。BlockingQueue的核心方法如下所示：\n方法 抛出异常 返回特殊值 阻塞 超时阻塞 插入 add(e) offer(e) put(e) offer(e, time, unit) 移除 remove() poll() take() poll(time, unit) 检查 element() peek() - - 在对队列执行以下三种操作时：\n在队列满时插入元素：使用add、offer、put插入方法 在队列空时移除元素：使用remove、poll、take移除方法 在队列空时检查元素：使用element、peek检查方法 一定会执行失败，此时根据使用方法的不同，可能会出现以下四种情况：\n抛出异常 返回特殊值(如null或false) 阻塞 超时阻塞 其中，只有阻塞与超时阻塞的4个方法是BlockingQueue接口独有的(这也是阻塞队列需要重点关注的方法)，而抛出异常与返回特殊值的6个方法则是继承自Queue接口。后续讲到的几种具体的阻塞队列实现，都需要实现上述方法。\n（二）常规阻塞队列：ArrayBlockingQueue与LinkedBlockingQueue ArrayBlockingQueue是使用数组实现的有界(bounded)阻塞队列，LinkedBlockingQueue是使用链表实现的有界(optionally-bounded)阻塞队列。它们都符合普通队列的FIFO(first-in-first-out，先入先出)原则：新增元素时在队尾插入，移除元素时从队首删除，队首的元素存在时间最长，队尾元素存在时间最短。\n为了实现阻塞插入或阻塞移除，ArrayBlockingQueue与LinkedBlockingQueue均使用ReentrantLock锁来实现同步，当队列满时或队列空时，执行阻塞的插入或移除操作(如:put或take)，会导致持有锁的线程将进入自旋等待状态，而其它线程因为无法获取到锁，也将进入等待状态，直到队列非满或非空时，等待状态才可以解除。\n其中，ArrayBlockingQueue只有一个锁，可以通过构造函数的fair参数来指定该锁的公平性。而LinkedBlockingQueue则有两个锁：takeLock与putLock，它们都是默认的非公平锁，takeLock可以由take、poll等方法持有，putLock可以由put、offe等方法持有。\nLinkedBlockingQueue可以用来实现FixedThreadPool线程池(详见Executors的newFixedThreadPool(int nThreads)方法)。\n在大多数并发应用中，LinkedBlockingQueue比ArrayBlockingQueue有更高的吞吐量，但有更低的性能可预测性(Linked queues typically have higher throughput than array-based queues but less predictable performance in most concurrent applications.)\n（三）优先阻塞队列：PriorityBlockingQueue与DelayQueue PriorityBlockingQueue和DelayQueue都是使用PriorityQueue实现的无界(unbounded)阻塞队列，它们都使用ReentrantLock锁来实现同步。\n其中，PriorityBlockingQueue可以通过Comparator来自定义队列元素的优先级。DelayQueue通过Delayed泛型元素实现延时获取元素。DelayQueue可以用来设计缓存系统与定时任务调度。\n（四）无容量阻塞队列：SynchronousQueue SynchronousQueue是一个没有任何容量的阻塞队列(其capacity值为0)，每一个插入操作都必须等待另一个线程对应的移除操作，反之亦然。SynchronousQueue使用ReentrantLock锁来实现同步，可以通过fair参数来指定该锁的公平性。\nSynchronousQueue可以用来实现CachedThreadPool线程池(详见Executors的newCachedThreadPool()方法)。\n（五）双向阻塞队列：BlockingDeque与LinkedBlockingDeque LinkedBlockingDeque是使用双向链表实现的有界(optionally-bounded)阻塞队列，它实现了BlockingDeque接口。LinkedBlockingDeque使用ReentrantLock锁来实现同步。\nLinkedBlockingDeque可以用来实现工作窃取模式(即ForkJoin系列类)。\n（六）Transfer阻塞队列：TransferQueue与LinkedTransferQueue LinkedTransferQueue是使用链表实现的无界(unbounded)阻塞队列，它实现了TransferQueue接口。\n可以将LinkedTransferQueue看作是LinkedBlockingQueue与SynchronousQueue的结合。LinkedTransferQueue的transfer方法会优先将生产者传入的元素立刻传输给消费者，此过程类似于SynchronousQueue。如果没有对应的消费者生产者传入的元素，会将之放到队列中，此过程类似于LinkedTransferQueue。\n三、总结 JUC包下定义了10个阻塞队列相关的接口或类。简单将它们分下类如下所示：\nBlockingQueue作为顶层接口定义了阻塞队列的阻塞队列 ArrayBlockingQueue与LinkedBlockingQueue是两个最基础的阻塞队列实现 PriorityBlockingQueue与DelayQueue是实现了优先级与延时获取的阻塞队列 SynchronousQueue是不存储元素并直接传递元素的阻塞队列 LinkedBlockingDeque是实现了BlockingDeque接口的双向阻塞队列 LinkedTransferQueue是实现了TransferQueue接口的阻塞队列，可以将其看作LinkedBlockingQueue与SynchronousQueue的结合。 本文更偏向于阻塞队列基础概念的简介，很多内容只是一笔带过，没有详细介绍，由于理解有限，上述内容可能会有偏差，后续将按需修改或增加相关内容。\n锁是阻塞队列的基础，上面提到的大部分阻塞队列都是使用ReentrantLock锁来实现同步。同时，阻塞队列又是线程池的基础，有关线程池的内容，将在后续介绍。\n参考文档\n《Java并发编程的艺术 方腾飞 魏鹏 程晓明 著》 ","permalink":"https://blog.luanrz.cn/posts/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/java%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E7%AE%80%E4%BB%8B/","summary":"\u003cp\u003eJava阻塞队列是一种可以实现\u003cstrong\u003e阻塞插入\u003c/strong\u003e和\u003cstrong\u003e阻塞移除\u003c/strong\u003e的特殊队列，它被广泛应用于生产者消费者模式。如在线程池中，可以使用\u003ccode\u003eLinkedBlockingQueue\u003c/code\u003e与\u003ccode\u003eSynchronousQueue\u003c/code\u003e等阻塞队列来生产与消费线程对象。\u003c/p\u003e\n\u003cp\u003e下面将简单介绍Java中常用的几个阻塞队列。\u003c/p\u003e","title":"Java阻塞队列简介"},{"content":"Java锁(Lock)是实现Java线程安全的一种手段，它通过加锁和解锁的过程来实现线程间的同步，以保证多线程在竞争同一个公共资源时数据读写的正确性。\n本文将首先阐明Lock在Java线程安全中的位置，随后将简单介绍Lock类之间的关系，最后将简单介绍Java锁的抽象定义与具体实现。\n一、前言 保证Java线程安全有三种方式：阻塞(互斥)同步、非阻塞同步、无同步。本文将要介绍的锁(Lock)可以是阻塞同步(如：ReentrantReadWriteLock的写操作)，也可以是非阻塞同步(如：StampedLock的tryOptimisticRead读操作)，下面将简单介绍一下这三种方式。\n互斥同步是悲观锁，悲观锁意味着“悲观地认为资源大概率会被同时访问，所以采取先加锁再操作数据的策略”，常见的实现方法是synchronized与部分Lock类，一般情况下，Lock与synchronized可以相互替换。\n非阻塞同步是乐观锁，乐观锁意味着“乐观地认为资源大概率不会被同时访问，所以采取先操作数据再判断并发状态的策略”，常见的实现方法是CAS原子操作(如：Atomic系列类)。乐观锁虽然带有锁字，但其实并没有真正加锁与解锁的过程，只是用来和悲观锁加以区分，因此也可以将之称之为无锁同步。\n除了互斥同步与非阻塞同步两种同步方案外，还有一种无同步方案，常见的实现方法是ThreadLocal与volatile等。\n二、Lock类之间的关系 与Java锁相关的10个类都在java.util.concurrent.locks包下面，它们之间的关系如下所示：\n@startuml Java锁类图 title Java锁类图 abstract class AbstractOwnableSynchronizer abstract class AbstractQueuedSynchronizer #Pink abstract class AbstractQueuedLongSynchronizer interface Condition interface Lock class LockSupport interface ReadWriteLock class ReentrantLock #Pink class ReentrantReadWriteLock #Pink class StampedLock Lock --|\u0026gt; ReentrantLock Lock --+ ReentrantReadWriteLock Lock --+ StampedLock ReentrantLock +-- AbstractQueuedSynchronizer ReentrantReadWriteLock +-- AbstractQueuedSynchronizer ReentrantReadWriteLock \u0026lt;|-- ReadWriteLock AbstractQueuedSynchronizer +-- Condition AbstractQueuedSynchronizer --\u0026gt; LockSupport AbstractOwnableSynchronizer -|\u0026gt; AbstractQueuedSynchronizer AbstractOwnableSynchronizer --|\u0026gt; AbstractQueuedLongSynchronizer @enduml 上述大部分类都是在jdk5中新增的，其中AbstractOwnableSynchronizer与AbstractQueuedLongSynchronizer在jdk6中新增，StampedLock在jdk8中新增。\nLock接口是锁的原型，队列同步器AbstractQueuedSynchronizer(AQS)是锁的实现基础，可重入锁ReentrantLock、读写锁ReentrantReadWriteLock与增强型读写锁StampedLock是锁的三种具体实现。\n三、Java锁的抽象定义 Lock接口定义了锁的使用方法，AQS类定义了锁的实现规范。\n（一）Lock接口 在jdk5之前，一般使用synchronized关键字实现同步，jdk5后，Lock也成为了一种更灵活的可选项。这里的Lock是广义的Lock，指的是java.util.concurrent.locks包的集合，狭义的Lock接口是这个集合中的一个元素，本小节介绍的是狭义的Lock接口。\njdk后续版本，java团队从虚拟机层面对synchronized关键字做了一系列优化，如：适应性自旋、锁消除、锁膨胀、轻量级锁、偏向锁等。\nLock接口有以下主要方法：\nlock：获取锁(加锁) tryLock：尝试获取锁 unlock：释放锁 下面罗列了jdk官方文档中两种使用锁的模板：\n使用lock与unlock Lock lock = ...; //定义并实例化锁 lock.lock(); // 获取锁 try { // 操作被锁保护的资源 } finally { lock.unlock(); // 释放锁 } 使用tryLock与unlock Lock lock = ...; //定义并实例化锁 if (lock.tryLock()) { // 尝试获取锁：成功 try { // 操作被锁保护的资源 } finally { lock.unlock(); // 释放锁 } } else { // 尝试获取锁：失败 // 执行其它流程 } （二）AQS类 队列同步器AbstractQueuedSynchronizer(AQS)是Java锁的基础，后续即将介绍的三种Java锁都有对应的AQS内部类实现。\nAQS中有两个关键的数据元素：\n同步状态 同步队列 其中，同步状态是一个volatile int类型的值，该值可以表示为持有锁的个数(如2表示持有2个锁，0表示不持有锁)。AQS使用getState、setState及compareAndSetState这三个方法来获取或修改state值。同时，同步队列是一个以自定义元素Node为节点的双向链表结构，该队列可以保存同步阻塞时的节点信息。\nAQS通过acquire及release系列方法来修改上述两个数据元素，来达到同步控制的目的。在这个过程中，有5个模板方法：tryAcquire、tryRelease、tryAcquireShared、tryReleaseShared、isHeldExclusively，它们默认会抛出UnsupportedOperationException异常，AQS的实现类需要去自定义它们的逻辑。\n上面引出来了AQS中定义的一些关键方法，它们和Lock接口中的方法存在一定的依赖关系。从锁的使用到锁的实现，有以下两条调用链路：\n加锁：Lock.lock() \u0026ndash;\u0026gt; AQS.acquire() \u0026ndash;\u0026gt; AQS.tryAcquire() \u0026ndash;\u0026gt; xxx 解锁：Lock.unlock() \u0026ndash;\u0026gt; AQS.release() \u0026ndash;\u0026gt; AQS.tryRelease() \u0026ndash;\u0026gt; xxx Lock实现类的加锁和解锁过程通过AQS类来实现，Lock与AQS共同组成了Java锁的抽象定义，为后面的Java锁的具体实现做好了铺垫。\n四、Java锁的具体实现 （一）可重入锁 ReentrantLock是一个可重入的互斥锁，它与synchronized有相同的基础行为和语义，但比synchronized更有扩展性。\n上面提到了两个概念，“互斥”与“可重入”，接下来将分别简单介绍这两个词的含义：\n互斥：ReentrantLock只能被一个线程所持有，当这个线程调用lock方法获得锁，并且没有调用unlock方法释放锁时，其它线程将无法获取该锁，只能处于等待状态。\n可重入：持有锁的线程可以反复获得这个锁(比如在递归场景中)，这意味着当前线程可以重复进入被加锁的区域，而无需等待锁释放。每次执行lock方法都会导致同步状态state的值加1，执行unlock方法则会减1，lock与unlock成对生效时，才会最终释放当前线程的锁。\nReentrantLock通过构造函数中的fair来决定创建公平锁(FairSync)或非公平锁(NonfairSync)，默认为非公平锁。公平锁能够保证等待越久的线程越能优先获取到锁(通过hasQueuedPredecessors方法实现)，从而保证不同线程在获取锁阻塞时等待时间的公平性。一言以蔽之，非公平锁可以插队(不保证顺序)，而公平锁一般不能插队(保证FIFO的顺序)\n下面以一个简单的例子说明一下ReentrantLock的使用方法：\nclass StatusHolder { private int status; private final Lock lock = new ReentrantLock(); // 以传统的synchronized的方式同步修改状态 public void changeStatusWithSynchronized(int status) { synchronized (this) { this.status = status; } } // 以Lock.lock()的方式同步修改状态 public void changeStatusWithLock(int status) { lock.lock(); try { this.status = status; } finally { lock.unlock(); } } // 以Lock.tryLock()的方式同步修改状态 public void changeStatusWithTryLock(int status) { if (lock.tryLock()) { try { this.status = status; } finally { lock.unlock(); } } else { // 获取锁失败，执行其它流程 } } } 上面使用三种方法来实现“修改状态”这一功能。作为对比，第一种使用的是传统的synchronized方式，第二种与第三种则是ReentrantLock的方式。synchronized与ReentrantLock在某些情况下可以互相替换，但ReentrantLock灵活度更高(比如可以实现超时等待)。\n（二）读写锁 ReadWriteLock接口维护了一对读锁和写锁。读锁可以被多个线程共享（非互斥），而写锁只能被一个线程持有（互斥）。这一特性也表明了ReadWriteLock更适合用于读多写少的场景。\n根据读写锁的排列组合，有以下四种情况：\n一个线程持有读锁后，另一个线程尝试获取读锁 一个线程持有读锁后，另一个线程尝试获取写锁 一个线程持有写锁后，另一个线程尝试获取读锁 一个线程持有写锁后，另一个线程尝试获取写锁 ReadWriteLock中仅有第一个场景的同时读操作是共享的（这也是使用读写锁时大概率会发生的场景），其它三种情况一般情况下都是互斥的。\nReadWriteLock当前有两个实现类：ReentrantReadWriteLock与StampedLock。ReentrantReadWriteLock是可重入的读写锁，它在读写锁的基础上支持重入操作。StampedLock是增强型的读写锁，它支持在读的过程中执行写操作（也即是上述排列组合的第2中情况），使用乐观读锁与悲观读锁的组合可以避免同时读写造成的脏读现象。同时，StampedLock是不可重入的。\n接下来将以ReentrantReadWriteLock为例介绍读写锁的简单使用方法：\nclass StatusHolder { private int status; private final ReadWriteLock readWriteLock = new ReentrantReadWriteLock(); private final Lock readLock = readWriteLock.readLock(); private final Lock writeLock = readWriteLock.writeLock(); // 写入状态 public void writeStatus(int status) { writeLock.lock(); // 加写锁 try { this.status = status; } finally { writeLock.unlock(); } } // 读取状态 public int readState(int status) { readLock.lock(); // 加读锁 try { return status; } finally { readLock.unlock(); } } } StampedLock的使用方法与ReentrantReadWriteLock类似，只需要在进行读操作时，优先使用乐观读锁读取数据，并校验此过程中是否有写操作，如果校验成功，直接使用乐观锁的结果；反之，则获取悲观读锁再次读取数据，以避免脏读。\n四、总结 至此，有关Java锁的基础内容已经介绍完毕。前面首先介绍了锁在线程安全中的重要性，并列出了Java并发包中与锁的相互关系，随后分别介绍了具体的几个核心类：Lock与AQS是Java锁的抽象定义，而可重入锁与读写锁则是两种Java锁的具体实现。\n本文更偏向于基础概念的简介，源码的实现细节暂时没有涉及，由于理解有限，上述内容可能会有偏差，后续将按需修改或增加相关内容。\n同时，上述介绍的Java锁只适用于单机环境，分布式环境则使用分布式锁实现同步。有关分布式锁的内容，将在后续介绍。\n参考文档\n《深入理解Java虚拟机第3版 周志明 著》 《Java并发编程的艺术 方腾飞 魏鹏 程晓明 著》 廖雪峰的官方网站-多线程 ","permalink":"https://blog.luanrz.cn/posts/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/java%E9%94%81%E7%AE%80%E4%BB%8B/","summary":"\u003cp\u003eJava锁(Lock)是实现Java线程安全的一种手段，它通过加锁和解锁的过程来实现线程间的同步，以保证多线程在竞争同一个公共资源时数据读写的正确性。\u003c/p\u003e\n\u003cp\u003e本文将首先阐明\u003ca href=\"#%E4%B8%80%E5%89%8D%E8%A8%80\"\u003eLock在Java线程安全中的位置\u003c/a\u003e，随后将简单介绍\u003ca href=\"#%E4%BA%8Clock%E7%B1%BB%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB\"\u003e\u003ccode\u003eLock\u003c/code\u003e类之间的关系\u003c/a\u003e，最后将简单介绍Java锁的\u003ca href=\"#%E4%B8%89java%E9%94%81%E7%9A%84%E6%8A%BD%E8%B1%A1%E5%AE%9A%E4%B9%89\"\u003e抽象定义\u003c/a\u003e与\u003ca href=\"#%E5%9B%9Bjava%E9%94%81%E7%9A%84%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0\"\u003e具体实现\u003c/a\u003e。\u003c/p\u003e","title":"Java锁简介"},{"content":"出于安全或性能等原因，公司将开发环境部署在了内网云环境中，内网云环境与外网完全隔离，且所有的开发环境资源（如数据库、Redis等）只能通过内网云环境访问，本地物理机无法直接访问这些测试资源，只能通过RDP协议间接访问内网云环境中的桌面，这给开发工作带来了极大的不便。为了能够直接在本地物理机进行开发，接下来将介绍4种远程开发的方法：\n使用nginx反向代理持续暴露远程资源 使用ssh转发临时暴露资源 使用Microsoft的Visual-Studio-Code远程开发工具 使用Jetbrains的Projector或Gateway远程开发工具 本文中的远程开发指的是：通过本机访问远程资源的过程。其中，“本机”是指本地物理机，“远程”是指内网云环境（假定远程主机的ip为172.6.6.6，操作系统为ubtunu，用户名为ubuntu）。\n一、nginx反向代理 在远程环境配置nginx相关服务的反向代理策略，便可以在本机访问那些只能在远程环境访问的资源了。具体配置方式如下：\n如果不加特殊说明，下述操作均在远程环境中进行！\n安装nginx\nsudo apt install nginx 配置nginx\nsudo vim /etc/nginx/nginx.conf load_module /usr/lib/nginx/modules/ngx_stream_module.so; events { } http { server { listen 80; server_name http.resource.com; location / { proxy_pass http://http.resource.com:80; } } server { listen 443; server_name https.resource.com; ssl on; ssl_certificate /etc/nginx/nginx.crt; # sudo openssl req -x509 -nodes -days 36500 -newkey rsa:2048 -keyout /etc/nginx/nginx.key -out /etc/nginx/nginx.crt ssl_certificate_key /etc/nginx/nginx.key; location / { proxy_pass https://https.resource.com:443; } } } stream { server { listen 6666; proxy_pass tcp.resource.com:6666; } } 启用nginx服务\nsudo systemctl start nginx sudo systemctl enable nginx 在本机配置hosts\nsudo vim /etc/hosts 172.6.6.6 http.resource.com 172.6.6.6 https.resource.com 172.6.6.6 tcp.resource.com 在本机访问远程资源\ncurl http://http.resource.com curl https://https.resource.com telnet tcp.resource.com 6666 二、ssh转发 ssh转发分为本地转发与远程转发两种方式：\n本地转发：在本地开一个端口，并通过这个端口访问远程服务，适用于将远程资源转发到本地的情况（这里的远程资源包括远程主机自己的服务资源，也包括远程主机能够访问到的其它主机的服务资源）。 远程转发：在远程开一个端口，并通过这个端口访问本地服务，适用于将本地资源转发到远程的情况（这里的本地资源包括本地主机自己的服务资源，也包括本地主机能够访问到的其它主机的服务资源，如：外网资源等）。 （一）ssh本地转发 在本机启用本地转发\nssh -L 8080:http.resource.com:80 ubuntu@172.6.6.6 -N -L表明启用ssh本地转发。这里将http.resource.com:80远程资源转发到了本机的8080端口。\n在本机配置hosts\nsudo vim /etc/hosts 127.0.0.1 http.resource.com 在本机访问远程资源\ncurl http://http.resource.com:8080 （二）ssh远程转发 在本机启用远程转发\nssh -R 8080:www.baidu.com:443 ubuntu@172.6.6.6 -N -R表明启用ssh远程转发。这里将www.baidu.com:443本机资源转发到了远程的8080端口。\n在远程环境配置hosts\nsudo vim /etc/hosts 127.0.0.1 www.baidu.com 在远程环境访问本地（外网）资源\ncurl https://www.baidu.com:8080 三、vscode远程开发 Visual-Studio-Code（vscode）可以通过Remote插件（主要是Remote-SSH插件）来进行远程开发。\n安装Remote插件\n在本机vscode的扩展中搜索Remote，找到对应项安装即可。\n在本机下载vscode-server\n正常情况下，首次使用Remote连接远程环境时，远程环境会自动下载服务端vscode，但由于当前的远程环境没有外网的网络策略，因此，需要本地下载服务端vscode之后传输到远程环境进行离线安装。\nexport VSCODE_COMMIT_ID=$(code -v | sed -n \u0026#39;2p\u0026#39;) # 如果vscode的commit_id获取失败，请打开vscode，点击帮助，再点击关于，手动获取commit_id wget https://update.code.visualstudio.com/commit:$VSCODE_COMMIT_ID/server-linux-x64/stable -O vscode-server-linux-x64-$VSCODE_COMMIT_ID.tar.gz # 下载vscode-server scp vscode-server-linux-x64-$VSCODE_COMMIT_ID.tar.gz ubuntu@172.6.6.6:/home/ubuntu # 上传vscode-server 在远程环境离线安装vscode-server\nexport VSCODE_COMMIT_ID=$(ls ~/vscode-server-linux-x64-* | cut -d \u0026#39;-\u0026#39; -f 5 | cut -d \u0026#39;.\u0026#39; -f 1) mkdir -p ~/.vscode-server/bin/ cd ~/.vscode-server/bin/ mv ~/vscode-server-linux-x64-*.tar.gz . tar zxvf vscode-server-linux-x64-*.tar.gz mv vscode-server-linux-x64 $VSCODE_COMMIT_ID 在本机vscode中连接远程环境\n在vscode中点击远程资源管理器，在SSH Target项点击+，输入ssh ubuntu@172.6.6.6 -A，回车，选择/home/xxx/.ssh/conf，回车。在SSH Target下的172.6.6.6项点击右边图标，进入远程环境\n至此，后续所有开发操作均和本地vscode操作一致了，如果需要支持特定语言，则需要安装对应插件（如：java）。\n四、jetbrains远程开发 Jetbrains旗下有两款远程开发方案：Projetctor及Gateway。\n（一）Projetctor远程开发 在远程环境安装projetctor服务端\ndocker pull jetbrains/projector-idea-c docker run --rm -p 8887:8887 -it jetbrains/projector-idea-c 有三种方式安装projetctor服务端：python方式（projector-installer）、idea插件方式projector-server-plugin、docker方式（projector-docker），这里以docker方式为例。\n如果云环境无法访问docker仓库，可以使用ssh远程转发临时代理docker仓库\n在本机连接projetctor服务\n有两种方式可以连接projetctor服务：\nWeb Client：直接在浏览器中输入http://172.6.6.6:8887即可访问远程IDE。 Native App：安装projectorr-client客户端，并通过客户端访问远程IDE。 （二）Gateway远程开发 详见Gateway官方教程。\n","permalink":"https://blog.luanrz.cn/posts/%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/%E8%BF%9C%E7%A8%8B%E5%BC%80%E5%8F%91%E7%9A%844%E7%A7%8D%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/","summary":"\u003cp\u003e出于安全或性能等原因，公司将开发环境部署在了内网云环境中，内网云环境与外网完全隔离，且所有的开发环境资源（如数据库、Redis等）只能通过内网云环境访问，本地物理机无法直接访问这些测试资源，只能通过RDP协议间接访问内网云环境中的桌面，这给开发工作带来了极大的不便。为了能够直接在本地物理机进行开发，接下来将介绍4种远程开发的方法：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e使用nginx反向代理持续暴露远程资源\u003c/li\u003e\n\u003cli\u003e使用ssh转发临时暴露资源\u003c/li\u003e\n\u003cli\u003e使用Microsoft的Visual-Studio-Code远程开发工具\u003c/li\u003e\n\u003cli\u003e使用Jetbrains的Projector或Gateway远程开发工具\u003c/li\u003e\n\u003c/ol\u003e","title":"远程开发的4种解决方案"},{"content":"kubernetes（k8s）是容器编排的利器。\n本文将介绍kubernetes本地环境的安装与基础使用，包括：创建集群、部署应用、故障排除、暴露服务、缩放应用、更新应用等内容，这里面大部分内容都来自于Kubernetes官方教程。\nkubernetes环境至少需要以下前置条件：\nLinux系统（本文以ArchLinux为例，包管理器为pacman，apt与yum等同理。也可以使用Mac、Window） 虚拟化环境（本文以docker为例，也可以使用其它虚拟化平台） 一、创建集群 本地测试环境可以使用minikube创建单节点集群，生产环境可以使用docker创建多节点集群，下面将分别介绍这两种方式。\nminikube是一个入门级的单节点kubernetes集群，麻雀虽小，五脏俱全。\n启动docker\nsudo systemctl start docker 在minikube中docker不是必选项，也可以使用virtualbox等驱动\n安装minikube\nsudo pacman -S minikube 启动minikube\nminikube start --image-mirror-country=\u0026#39;cn\u0026#39; minikube指定--image-mirror-country='cn'参数将从阿里云下载依赖，感谢alibaba的贡献\n查看minikube版本\nminikube version // TODO\n二、部署应用 查看kubernetes版本\nkubectl version 查看集群节点\nkubectl get nodes 创建deployment\nkubectl create deployment kubernetes-bootcamp --image=gcr.io/2/kubernetes-bootcamp:v1 创建deployment时会自动创建一个包含对应容器的pod，一个deployment也可以有多个pod（后面缩放应用章节将会介绍这种情况）\n同时，pod是kubernetes管理的最小单元。一个工作节点（node）可以包含多个pod，一个pod可以包含多个容器\ngcr.io被墙了，启动应该会报错，但问题不大，先假装它启动成功了\n查看deployment状态\nkubectl get deployments 此时，deployment中的应用只允许集群内部的其它pod或者service访问，为了在外部能够访问，可以选择暴露应用，也可以使用proxy\n启用proxy\nkubectl proxy 执行此命令需要另开一个终端来常驻proxy服务\n通过porxy访问集群内部服务\ncurl http://localhost:8001/version export POD_NAME=$(kubectl get pods | grep kubernetes-bootcamp | awk \u0026#39;{print $1}\u0026#39;) # 获取pod名 export POD_NAME=$(kubectl get pods -o go-template --template \u0026#39;{{range .items}}{{.metadata.name}}{{\u0026#34;\\n\u0026#34;}}{{end}}\u0026#39;) # 获取pod名的官方写法，与上面等价，两者取其一即可 curl http://localhost:8001/api/v1/namespaces/default/pods/$POD_NAME/ 三、故障排除 检查应用配置\nkubectl get nodes kubectl describe pods 使用proxy访问集群内部服务\n参见上一小节\n查看容器日志\nkubectl describe pods 容器启动了才会有日志\n在容器中执行命令\nkubectl exec $POD_NAME -- env # POD_NAME在前面定义了 kubectl exec -ti $POD_NAME -- bash 四、暴露应用 创建service\nkubectl get pods # 确认应用正在运行 kubectl get services # 查看service状态 kubectl expose deployment/kubernetes-bootcamp --type=\u0026#34;NodePort\u0026#34; --port 8080 # 创建service kubectl get services # 再次查看service状态 kubectl describe services/kubernetes-bootcamp # 查看刚刚新建的service的描述信息 export NODE_PORT=$(kubectl get services/kubernetes-bootcamp -o go-template=\u0026#39;{{(index .spec.ports 0).nodePort}}\u0026#39;) # 获取暴露出来的节点端口 curl $(minikube ip):$NODE_PORT # 在外面通过service暴露的端口访问应用，如果创建集群时用的不是minikube，则$(minikube ip)需要换成对应的节点ip 使用expose指令来创建service\n使用标签\nkubectl describe deployment # 查看deployment自动创建的Labels kubectl get pods -l app=kubernetes-bootcamp # 通过Label来查看pod kubectl get services -l app=kubernetes-bootcamp # 通过Label来查看service export POD_NAME=$(kubectl get pods -o go-template --template \u0026#39;{{range .items}}{{.metadata.name}}{{\u0026#34;\\n\u0026#34;}}{{end}}\u0026#39;) # 获取pod名 kubectl label pods $POD_NAME version=v1 # 为pod增加Label kubectl describe pods $POD_NAME # 查看pod中的Labels kubectl get pods -l version=v1 # 再次通过Label来查看pod，不过这次条件变成了version=v1 使用label指令来增加标签，使用-l参数来使用标签\n删除service\nkubectl delete service -l app=kubernetes-bootcamp # 通过Lable删除service kubectl get services # 查看service是否被删除 curl $(minikube ip):$NODE_PORT # 验证外部能否访问应用（不能） kubectl exec -ti $POD_NAME -- curl localhost:8080 # 验证内部能否访问应用（能） 使用delete指令来删除service，deployment等同理\n五、缩放应用 扩展deployment中的pod\nkubectl get deployments # 查看deployment状态 kubectl get rs # 查看deployment所创建的pod副本集合 kubectl scale deployments/kubernetes-bootcamp --replicas=4 # 将pod副本个数扩展到4 kubectl get deployments # 再次查看deployment状态 kubectl get pods -o wide # 查看pod状态 kubectl describe deployments/kubernetes-bootcamp # 在deployment描述信息中查看Event与Replicas 使用scale指令来缩放应用副本\n负载均衡\nkubectl describe services/kubernetes-bootcamp # 查看service暴露的ip和端口 export NODE_PORT=$(kubectl get services/kubernetes-bootcamp -o go-template=\u0026#39;{{(index .spec.ports 0).nodePort}}\u0026#39;) # 获取暴露出来的节点端口（和前面一样） curl $(minikube ip):$NODE_PORT # 通过暴露的ip和端口访问应用 无须额外配置，使用scale指令扩展的应用自动支持负载均衡\n缩小deployment中的pod\nkubectl scale deployments/kubernetes-bootcamp --replicas=2 # 将pod副本个数扩展到2（减少2个） kubectl get deployments # 查看deployment状态 kubectl get pods -o wide # 查看pod状态 扩展或缩小deployment中的本质是：将pod数调整到指定数目\n六、更新应用 更新应用到指定版本\nkubectl get deployments # 查看deployment状态 kubectl get pods -o wide # 查看pod状态 kubectl describe pods # 查看pod描述信息 kubectl set image deployments/kubernetes-bootcamp kubernetes-bootcamp=jocatalin/kubernetes-bootcamp:v2 # 将镜像版本设置为v2，并开始滚动更新 使用set image指令来更新应用到指定版本\n验证更新\nkubectl describe services/kubernetes-bootcamp # 查看service暴露的ip和端口（和前面一样） export NODE_PORT=$(kubectl get services/kubernetes-bootcamp -o go-template=\u0026#39;{{(index .spec.ports 0).nodePort}}\u0026#39;) # 获取暴露出来的节点端口（和前面一样） curl $(minikube ip):$NODE_PORT # 通过暴露的ip和端口访问应用 kubectl rollout status deployments/kubernetes-bootcamp # 查看更新状态 kubectl describe pods # 查看pod中的镜像是否是最新版本 使用rollout status指令查看更新状态\n回滚应用到上一版本\nkubectl set image deployments/kubernetes-bootcamp kubernetes-bootcamp=gcr.io/google-samples/kubernetes-bootcamp:v10 # 将镜像版本设置为v10，并开始滚动更新 kubectl get deployments # 查看deployment状态 kubectl get pods # 查看pod状态 kubectl describe pods # 查看pod描述信息，在Events中找到ImagePullBackOff的原因：v10版本不存在 kubectl rollout undo deployments/kubernetes-bootcamp # 回滚到上一个稳定版本 kubectl get pods # 再次查看pod状态 kubectl describe pods # 再次查看pod描述信息 使用rollout undo指令来回滚应用到上一版本\n","permalink":"https://blog.luanrz.cn/posts/%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/kubernetes%E5%85%A5%E9%97%A8/","summary":"\u003cp\u003ekubernetes（k8s）是容器编排的利器。\u003c/p\u003e\n\u003cp\u003e本文将介绍kubernetes本地环境的安装与基础使用，包括：创建集群、部署应用、故障排除、暴露服务、缩放应用、更新应用等内容，这里面大部分内容都来自于\u003ca href=\"https://kubernetes.io/zh-cn/docs/tutorials/\"\u003eKubernetes官方教程\u003c/a\u003e。\u003c/p\u003e","title":"kubernetes入门"},{"content":"Java内存模型（Java Memory Model，JMM）是Java多线程读写共享内存中的一种规范，该规范支持了synchronized、volatile、final、Lock等Java并发工具。\n前面介绍了JVM内存区域，JVM内存区域和Java内存模型是不同层次对内存的划分，Java内存模型侧重描述内存数据在多线程下的读写规则，一般关注并发编程下线程如何正确读写共享数据。\n一、定义 Java内存模型在JSR133规范（JSR133草案、JSR133、JSR133-中文版）中有详细的数学定义（JSR133第7小节），本文无意照本宣科引入复杂的数学概念（其实是因为看不懂囧，逃~），这里给出它的一个简单的定义（JSR133第4小节）：Java内存模型是描述Java共享变量“可见性”的一组规则，该规则阐明了一个线程对共享变量的的写操作，何时能被另一个线程观察（读）到。\nJSR草案中也提到了“有序性”、“原子性”等概念，它们可以辅佐“可见性”实现正确的并发。\n二、内存交互 JMM有主内存和工作内存两个概念，主内存全局共享，工作内存线程独享。主内存可以类比为JVM内存区域中的“堆”，工作内存可以类比为JVM内存区域中的“栈”，但请注意，这样的类比只是便于理解，它们本身并不是相同的概念。\n工作内存保存了主内存的变量副本，后续所有对变量的读写都在工作线程中进行，同时，本地内存的读写操作也将与主内存交互，由于这种交互机制的存在，不同线程对同一个变量的读写可能会发生延迟或紊乱，这也是多线程下JMM“可见性”需要解决的问题。\n内存交互简单来说就是工作内存与主内存的同步读写，更宽泛来说，就涉及到8种操作，如下所示：\n@startuml JMM内存间交互时序图 title JMM内存间交互时序图 autonumber participant Java线程 participant 工作内存 participant 主内存 activate 主内存 activate 工作内存 activate Java线程 主内存 -\u0026gt;\u0026gt; 主内存:lock 主内存 -\u0026gt;\u0026gt; 工作内存: read 工作内存 -\u0026gt;\u0026gt; 工作内存: load 工作内存 -\u0026gt;\u0026gt; Java线程: use Java线程 -\u0026gt;\u0026gt; 工作内存: assign 工作内存 -\u0026gt;\u0026gt; 工作内存: store 工作内存 -\u0026gt;\u0026gt; 主内存: write 主内存 -\u0026gt;\u0026gt; 主内存:unlock @enduml 三、volatile的可见性特征 volatile，英文原意为“易变的”、“易失的”，这表明了工作内存中的volatile变量是不确定的，使得线程读写volatile变量时不相信当前本地内存中的值，而是立马去读写主内存中的值。结合上述内存交互的过程，volatile变量的读写有两个过程：\n线程往本地内存中更新一个volatile变量时，会立刻将之写到主内存中去。 线程从本地内存读取一个volatile变量时，会先将之设置为无效，并立刻从主内存中读取。 上述过程保证了volatile的可见性：一个线程对volatile变量的修改对其它线程是马上可以被观察（读）到的。\n同时，volatile也可以禁止重排序，当然，这个特性就和可见性没什么关系了。\n四、总结 全文围绕“可见性”这个概念介绍了三点：JMM是描述Java共享变量“可见性”的一组规则，“可见性”问题普遍存在于主内存与共享内存的交互过程中，volatile是实现共享内存的“可见性”的一种方式。\nJMM涉及到的概念众多，“可见性”显然只是其中一个，JMM中的“有序性”、“原子性”、“指令重排序”、“内存屏障”、“先行发生原则（Happens-Before）”等这些概念，以及Final、synchronized、Lock与JMM的关系，由于视野受限，当前暂时无法一一介绍，关于JMM的知识点个人还在持续学习中，上述内容存在理解偏差或需要补充的地方，后续将实时更新。\n参考文档\n《深入理解Java虚拟机第3版 周志明 著》 《Java并发编程的艺术 方腾飞 魏鹏 程晓明 著》 Java Memory Model - LangNerd JSR 133 (Java Memory Model) FAQ ","permalink":"https://blog.luanrz.cn/posts/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E7%AE%80%E4%BB%8B/","summary":"\u003cp\u003eJava内存模型（Java Memory Model，JMM）是Java多线程读写共享内存中的一种规范，该规范支持了\u003ccode\u003esynchronized\u003c/code\u003e、\u003ccode\u003evolatile\u003c/code\u003e、\u003ccode\u003efinal\u003c/code\u003e、\u003ccode\u003eLock\u003c/code\u003e等Java并发工具。\u003c/p\u003e\n\u003cp\u003e前面介绍了JVM内存区域，JVM内存区域和Java内存模型是不同层次对内存的划分，Java内存模型侧重描述内存数据在多线程下的读写规则，一般关注\u003cstrong\u003e并发\u003c/strong\u003e编程下线程如何正确读写共享数据。\u003c/p\u003e","title":"Java内存模型简介"},{"content":"JVM内存区域（JVM内存结构，JVM内存布局）是Java虚拟机运行时数据的位置划分，其主要包括：程序计数器、虚拟机栈、本地方法栈、堆、方法区。\n后面将介绍Java内存模型，JVM内存区域和Java内存模型是不同层次对内存的划分，JVM内存区域侧重描述内存数据的结构布局，一般关注垃圾回收（GC）及OOM问题。\n一、前言 Java虚拟机将内存划分为几个区域：程序计数器、虚拟机栈、本地方法栈、堆、方法区。其中程序计数器、虚拟机栈、本地方法栈都是线程私有的区域，而堆、方法区都是线程共享的区域。\n除了以上的内存区域，Java虚拟机还可以使用“直接内存”，Java8中使用元空间替换了Java7位于方法区的永久代，元空间就是在“直接内存”中分配。\n本文中JVM的实现都是以HotSpot为例，如：永久代就是HotSpot的专属概念。\n二、JVM内存区域的数据内容 接下来将分别介绍这几个区域的部分数据内容：\n程序计数器（Program Counter Register）：程序计数器保存了当前程序所处的位置，通过改变程序计数器的值可以实现流程控制（分支、循环、跳转、异常处理、线程恢复等）。\n虚拟机栈（VM Stack）：虚拟机栈保存了方法出口、局部变量表等数据，局部变量表又保存了对象引用等数据，如对于Object obj = new Object()来说，obj这个变量就作为Object对象的引用就存放在局部变量表中。\n本地方法栈（Native Method Stack）：本地方法栈与虚拟机栈功能类似，其区别是虚拟机栈适用于Java方法，而本地方法栈适用于Native方法。\n堆（Heap）：堆保存了对象实例等数据，如对于之前虚拟机栈描述中的Object obj = new Object()来说，new出来的Object对象的实例数据就存放在堆中。Java堆是垃圾回收（GC）的重点关注位置，常说的“分代收集”（老年代，新生代）也大部分发生在堆中（这里之所以说是大部分是因为永久代是在方法区中实现）。\n方法区（Method Area）：方法区保存了类型信息、常量、静态变量等数据，运行时常量池是方法区的一部分。Java7在方法区上实现了“永久代”，Java8后就没有“永久代”这个概念了，而是使用“元空间”替代之。\n三、JVM内存区域的参数配置 我们可以在执行Java程序之前指定参数来改变JVM内存区域的大小及行为，常用的参数如下：\n-Xmnsize：设置堆的新生代（nursery）的最大空间与初始空间，如：java -Xmn256m Hello。它等价于-XX:NewSize。 -Xmssize：设置堆的最小空间与初始空间，如：java -Xms6m Hello。它部分等价于-XX:InitalHeapSize（设置堆的初始空间）。 -Xmxsize：设置堆的最大空间，如：java -Xmx80m Hello。它等价于-XX:MaxHeapSize。Xms与Xmx一般设置成相同的值。 -Xsssize：设置线程栈的空间，如：java -Xss1m Hello。它等价于-XX:ThreadStackSize。 四、JVM内存区域的常见异常 当Java程序无法申请到足够的内存时，便会抛出内存溢出异常（OutofMemoryError，OOM）。OOM可以发生在Java虚拟机栈、本地方法栈、Java堆及方法区，换言之，除了程序计数器的其它所有JVM内存区域都可能发生OOM异常。\n当Java程序请求的栈深度大于虚拟机允许的深度，便会抛出栈溢出异常（StackOverflowError）。根据描述可以知道，栈溢出异常一般只会发生在Java虚拟机栈和本地方法栈。\n各JVM内存区域可能会遇到异常的场景如下所示：\n场景 异常 原因 无节制地创建对象 堆的内存溢出异常 对象在堆中分配空间，对象过多可能会导致堆空间不足 递归调用，并且永不退出 栈的栈溢出异常 方法调用会执行入栈操作，递归调用而不退出会无限入栈，导致栈深度过大 无节制地定义大量局部变量 栈的内存溢出异常 局部变量在局部变量表中分配空间，局部变量表位于栈，局部变量过多可能会导致栈空间不足 无节制地创建线程 栈的内存溢出异常 创建线程所需的栈空间固定，线程越多，所需的栈空间也就越大，线程过多可能会导致栈空间不足 无节制地分配直接内存 直接内存的内存溢出 可使用的直接内存为物理总内存减去虚拟机分配的内存，直接内存可能会被用尽 参考文档\n《深入理解Java虚拟机第3版 周志明 著》 ","permalink":"https://blog.luanrz.cn/posts/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/jvm%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E7%AE%80%E4%BB%8B/","summary":"\u003cp\u003eJVM内存区域（JVM内存结构，JVM内存布局）是Java虚拟机运行时数据的位置划分，其主要包括：程序计数器、虚拟机栈、本地方法栈、堆、方法区。\u003c/p\u003e\n\u003cp\u003e后面将介绍Java内存模型，JVM内存区域和Java内存模型是不同层次对内存的划分，JVM内存区域侧重描述内存数据的结构布局，一般关注\u003cstrong\u003e垃圾回收\u003c/strong\u003e（GC）及\u003cstrong\u003eOOM\u003c/strong\u003e问题。\u003c/p\u003e","title":"JVM内存区域简介"},{"content":"梳理Java开发所需的技能点，用于指导后续的学习路线，并提供系统性的查漏补缺方式。\n@startmindmap Java技能树 * Java技能 ** Java基础 *** IO *** 集合 *** 多线程 **** 理论基础 ***** Java内存模型(JMM) **** 锁 ***** 队列同步器(AQS) ***** Lock接口及其实现类与支持类 **** 并发工具 ***** 集合：ConcurrentHashMap、ConcurrentLinkedQueue、BlockingQueue相关类 ***** 工作窃取：ForkJoin相关类 ***** CAS原子操作：Atomic相关类 ***** 流程控制与数据交换：CountDownLatch、Semaphore、Exchanger **** 线程池 *** JVM **** JVM内存结构 **** 垃圾回收(GC) **** 类加载机制 **** 性能调优 ** 理论基础 *** 设计模式 *** 数据结构与算法 ** 开发框架 *** Spring(SpringMVC、SpringBoot、SpringCloud、SpringDataJPA) *** 数据库(Hibernate、Mybatis) *** 服务调用(Dubbo) ** 数据库 *** 数据库基础 **** 事务 *** MySql *** Oracle ** 中间件 *** 缓存 **** Redis **** Memcache **** Guava **** Ehcache *** 消息 **** Kafka **** RabbitMQ *** 部署 **** Apache **** Nginx **** Tomcat **** Jboss *** 搜索引擎 **** Elasticsearch *** 协调服务 **** ZooKeeper ** 运维 *** Linux *** 脚本 **** Python **** Shell *** 容器 **** Docker **** Kubernetes *** CI/CD **** Jenkins ** 分布式架构 *** 基础概念 **** CAP ***** 一致性(Consistency) ***** 可用性(Availability) ***** 分区容错性(Partition tolerance) **** 三高 ***** 高并发 ***** 高性能 ***** 高可用 *** 分布式服务(微服务治理) **** 服务注册与发现 ***** Nacos ***** Eureka **** 服务调用 ***** Feign ***** RPC(Dubbo) **** 负载均衡 ***** SpringCloudLoadBalancer ***** Ribbon **** 配置管理 ***** SpringCloudConfig ***** Nacos **** 网关 ***** SpringCloudGateway ***** Zuul **** 熔断降级 ***** SpringCloudCircuitBreaker ***** Sentinel ***** Hystrix ***** Resilience4j *** 分布式缓存 *** 分布式事务 *** 分布式锁 ** 工具 *** Git *** Maven @endmindmap 上图中，相同的概念会尽量放在一起，但根据关注点的不同，相同的概念也可能会体现在不同的节点下面（如：Redis可以同时出现在中间件与分布式缓存中，中间件中的Redis更关注Redis的基础特性，而分布式缓存更关注Redis的分布式特性）。\n有部分概念比较相近，需要注意它们之间的区别，如：多线程下的Java内存模型与JVM下的JVM内存结构，两者不是同一个概念。\n同时，由于技术的快速发展与个人视野的局限性，上图内容还不是很完善，后续将按需动态更新。\n参考文档\n《深入理解Java虚拟机第3版 周志明 著》 《Java并发编程的艺术 方腾飞 魏鹏 程晓明 著》 ","permalink":"https://blog.luanrz.cn/posts/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/java%E6%8A%80%E8%83%BD%E6%A0%91/","summary":"\u003cp\u003e梳理Java开发所需的技能点，用于指导后续的学习路线，并提供系统性的查漏补缺方式。\u003c/p\u003e","title":"Java技能树"},{"content":"双亲委派(Parents Delegation)，一言以蔽之，就是：在Java虚拟机中，将类的加载行为委派给父级(双亲)类加载器的过程。\n接下来将逐一介绍Java8及Java9中的类加载器，并根据类加载器的组织结构，描述双亲委派的实现过程。\n一、概念范围 首先，明确一下“双亲委派”这个概念的上下文，双亲委派一般只在Java虚拟机类加载过程中讨论，全文默认遵循此上下文。\n同时，Java虚拟机“类加载”一般包括“加载”、“验证”、“准备”、“解析”、“初始化”几个阶段，这里出现了两个“加载”的概念，狭义的“加载”是广义的“类加载”的一部分，全文默认描述的是广义的“类加载”。\n二、类加载器 类加载器的组织结构是双亲委派的基础，双亲委派是多个类加载器之间的一种行为，更具体来说，是父类加载器与子类加载器之间的行为(“父子关系”乍一看会以为两个类加载器是继承关系，但其实它们是组合关系，详见下述ClassLoader类图)。\n一般来说，所有类加载器都继承自ClassLoader类(Java8中启动类加载器除外，其由虚拟机原生C++提供)。\n（一）Java8类加载器 Java8及以下版本中常用的类加载器有以下几个：\n启动类加载器(Bootstrap ClassLoader)：加载${JAVA_HOME}/lib下指定的类库(如：rt.jar)。由虚拟机原生C++实现，没有对应的Java类。 扩展类加载器(Extension ClassLoader)：加载${AVA_HOME}/lib/ext下所有的类库。由ExtClassLoader类实现。 应用程序类加载器(Application ClassLoader)：加载用户类路径(ClassPath)下所有的类库。由AppClassLoader类实现。 自定义类加载器(User ClassLoader)：加载用户自定义的类库。由用户手动继承ClassLoader类的自定义类加载器实现。 Java8常用ClassLoader的类图如下所示：\n@startuml ClassLoader类图(Java8版本) title ClassLoader类图(Java8版本) footer 适用于Java8及以下版本的常用ClassLoader类图 abstract class ClassLoader #Pink { + ClassLoader parent # Class\u0026lt;?\u0026gt; loadClass(String name, boolean resolve) } class SecureClassLoader class URLClassLoader class Launcher class ExtClassLoader #Pink class AppClassLoader #Pink class BootClassLoader #Pink note top of BootClassLoader Java8中并不存在BootClassLoader类， 启动类加载器由Java虚拟机C++原生支持， 这里仅用于占位，便于理解 endnote ClassLoader \u0026lt;|-- SecureClassLoader SecureClassLoader \u0026lt;|-- URLClassLoader URLClassLoader \u0026lt;|-- ExtClassLoader URLClassLoader \u0026lt;|-- AppClassLoader Launcher +-- ExtClassLoader Launcher +-- AppClassLoader AppClassLoader -\u0026gt; ExtClassLoader ExtClassLoader -\u0026gt; BootClassLoader @enduml 阅读源码可以发现，ExtClassLoader与AppClassLoader均是Launcher类的内部类，且它们的实例化过程均在Launcher的构造方法里面，如下所示(精简了部分语句)：\npublic class Launcher { private ClassLoader loader; public Launcher() { // 实例化ExtClassLoader ClassLoader extcl extcl = ExtClassLoader.getExtClassLoader(); // 实例化AppClassLoader loader = AppClassLoader.getAppClassLoader(extcl); } } 在实例化ExtClassLoader时，它的parent属性将被设置为null，这表示ExtClassLoader的父类加载器为null(这里的null有特殊意义，在后续双亲委派的实现过程源码部分将会介绍)。\n在实例化AppClassLoader时，它的parent属性将被设置为ExtClassLoader，这表示AppClassLoader的父类加载器为ExtClassLoader。\n（二）Java9类加载器 Java9新增的模块化导致源码结构发生重大变更，其类加载器也跟着发生了部分变化：\n平台类加载器(PlatformClassLoader)替换掉了Java8中的扩展类加载器(Extension ClassLoader)。 定义了Java8中不存在的启动类加载器(Bootstrap ClassLoader)。 启动类加载器、平台类加载器、应用程序类加载器不再是单向的依赖关系(详见下述类图)。 Java9常用ClassLoader的类图如下所示：\n@startuml ClassLoader类图(Java9版本) title ClassLoader类图(Java9版本) footer 适用于Java9及以上版本的常用ClassLoader类图 abstract class ClassLoader #Pink class SecureClassLoader class BuiltinClassLoader class ClassLoaders class PlatformClassLoader #Pink class AppClassLoader #Pink class BootClassLoader #Pink ClassLoader \u0026lt;|-- SecureClassLoader SecureClassLoader \u0026lt;|-- BuiltinClassLoader BuiltinClassLoader \u0026lt;|-- PlatformClassLoader BuiltinClassLoader \u0026lt;|-- AppClassLoader BuiltinClassLoader \u0026lt;|-- BootClassLoader ClassLoaders +-- BootClassLoader ClassLoaders +-- PlatformClassLoader ClassLoaders +-- AppClassLoader AppClassLoader --\u0026gt; PlatformClassLoader PlatformClassLoader --\u0026gt; BootClassLoader PlatformClassLoader -\u0026gt; AppClassLoader AppClassLoader -\u0026gt; BootClassLoader @enduml 三、双亲委派的实现过程 根据前文描述，大部分类加载器都存在父级类加载器(即ClassLoader的parent属性对应的值)。基于此，ClassLoader.loadClass()源码描述了双亲委派是如何实现的，如下所示：\nprotected Class\u0026lt;?\u0026gt; loadClass(String name, boolean resolve) throws ClassNotFoundException { synchronized (getClassLoadingLock(name)) { // 首先，检查这个类是否已经被加载了 Class\u0026lt;?\u0026gt; c = findLoadedClass(name); if (c == null) { long t0 = System.nanoTime(); try { if (parent != null) { // 如果父类加载器非空，就执行父类加载器的加载行为 // ！！！此处为双亲委派的核心逻辑！！！ c = parent.loadClass(name, false); } else { // 如果父类加载器为空，就执行启动类加载器的加载行为(前提是name有效) c = findBootstrapClassOrNull(name); } } catch (ClassNotFoundException e) {} if (c == null) { // 如果父类加载器无法加载时，执行本类加载器自身的类加载行为 long t1 = System.nanoTime(); c = findClass(name); } } if (resolve) { resolveClass(c); } return c; } } 上述源码中最核心的一个点在于：类加载器会优先从它的父类加载器中去执行加载行为，父类加载器无法加载时，才会执行当前类加载器的加载行为。这也是“双亲委派”这个词的含义，即，将类加载行为首先委派给双亲(parent属性对应的父类加载器)。\n具体来说，根据双亲委派原则，指定给应用程序类加载器的类，会委派给父级的扩展类加载器中去加载，接着，扩展类加载器又会将之委派给启动类加载器去加载，最终所有的类都会到顶层启动类加载器，只有在父类加载器无法加载时，才会反过来让子类加载器去加载。\n所以，当一个类进入类加载流程时，它的加载位置的优先级为：启动类加载器 \u0026gt; 扩展类加载器\u0026gt; 应用程序类加载器。\n上述例子适用于Java8，Java9也是类似的步骤。\n四、破坏双亲委派 在某些场景，需要父类加载器去请求子类加载器完成类加载行为(如JNDI、JDBC)，或者对代码热替换即模块热部署有需求(如OSGI)，都可以不遵循双亲委派的原则，实现自定义的类加载顺序。类似于这种的场景，都可以称之为“破坏双亲委派”。\n五、总结 类加载器主要分为为“启动类加载器”、“扩展类加载器(平台类加载器)”、“应用程序类加载器”及“自定义类加载器”。\n大部分类加载器都有父类加载器，类加载器会优先从它的父类加载器中去执行加载行为，这一过程被称之为“双亲委派”。在某些场景，可以破坏双亲委派。\n参考文档\n《深入理解Java虚拟机第3版 周志明 著》 ","permalink":"https://blog.luanrz.cn/posts/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/jvm%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B%E6%B5%85%E6%9E%90/","summary":"\u003cp\u003e\u003cstrong\u003e双亲委派\u003c/strong\u003e(Parents Delegation)，一言以蔽之，就是：在Java虚拟机中，将类的加载行为\u003cstrong\u003e委派\u003c/strong\u003e给父级(\u003cstrong\u003e双亲\u003c/strong\u003e)类加载器的过程。\u003c/p\u003e\n\u003cp\u003e接下来将逐一介绍Java8及Java9中的类加载器，并根据类加载器的组织结构，描述双亲委派的实现过程。\u003c/p\u003e","title":"JVM双亲委派模型浅析"},{"content":"Maven通过pom文件来管理Java包的依赖关系，多个pom文件组合在一起可以理解为一颗抽象的依赖树，父节点或祖父节点的包会传递给子节点或祖孙节点，这被称作传递依赖(Transitive-Dependencies)。\n传递依赖一般通过两个标签来实现：parent与dependency，其中，parent定义了上级依赖，dependency定义了下级依赖。\n随着项目复杂性的提升，依赖树中包发生冲突的概率也会增加，Maven通过依赖仲裁(Dependency-Mediation)与依赖管理(Dependency-Management)来唯一确定依赖树中包的版本。\n一、依赖仲裁 Maven使用dependencies标签来引入使用包。\n依赖仲裁，简而言之，就是在依赖树中包的版本发生冲突时，选择哪一个包的过程，Maven采取就近原则，即：\n首先选择依赖层级最浅的 若依赖层次一致，则选择最先定义的 如对于以下依赖树：（参见官网）\nA ├─ B │ └─ C │ └─ D（2.0） └─ E └─ D（1.0） D包有两个版本，其对应了两条依赖路径：A \u0026ndash;\u0026gt; B \u0026ndash;\u0026gt; C \u0026ndash;\u0026gt; D 与 A \u0026ndash;\u0026gt; E \u0026ndash;\u0026gt; D，第二条路径最短（依赖层级最浅），符合上述就近原则的第一条规则，最终选择D包的1.0版本。\n又如，对于以下依赖树：\nA ├─ B │ └─ D（2.0） │ └─ C │ └─ D（1.0） D同样有两个版本，他们的依赖层级一样，A \u0026ndash;\u0026gt; B \u0026ndash;\u0026gt; D路径上的D最先定义，符合上述就近原则的第二条规则，最终选择D包的2.0版本。\n如果想要某个包的版本优先使用，可以将节点提到上级pom节点（满足依赖层级最浅的规则），也可以将对应节点交换位置（满足最先定义的规则）。\n当然，还有另外一种方法，那就是依赖管理。\n二、依赖管理 Maven使用dependencyManagement标签来定义包。\n与dependencies不同的地方在于，dependencyManagement中的包只是一个定义，只有在dependencies中引入对应包时，dependencyManagement中的定义才有意义。\n凡是在dependencyManagement中定义的包，dependencies中引入对应包时，都可以省略版本号，Maven会自动从dependencyManagement中找到对应版本，这一特性为包的版本统一提供了极大的便利性。\n同时，有一点需要非常注意：在子模块中，dependencies中包的版本无法覆盖dependencyManagement中对应包的版本，如下所示：\n\u0026lt;project\u0026gt; ... \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.squareup.okhttp3\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;okhttp\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;4.9.3\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;dependencyManagement\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.squareup.okhttp3\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;okhttp\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.8.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;/dependencyManagement\u0026gt; ... \u0026lt;/project\u0026gt; 在上述pom中dependencies与dependencyManagement使用了okhttp，但它们的版本不一样，此时，Maven将优先使用在dependencyManagement中定义的3.8.1版本，因为在Maven中，依赖管理优先于依赖仲裁 ，即使是在父节点（根节点除外）的dependencies引入一个层级更浅的okhttp版本，这里依旧会取dependencyManagement中okhttp的版本，因为不管okhttp位于哪个节点（根节点除外），它都是处于依赖仲裁的范围内，它的优先级永远低于依赖管理。\n同时，顶层根节点（如启动类所在的web节点）的优先级最高。\n因此，在Maven依赖中存在以下优先级：\n顶层根节点引入的依赖 \u0026gt; 依赖管理 \u0026gt; 依赖仲裁\n三、总结 至此，对于如何唯一确定一个包，并解决包冲突，我们也有了明确的方向：\n根据依赖管理原则，在dependencyManagement中寻找包的版本 根据依赖仲裁原则，在dependencies中寻找包的版本 在顶层根节点寻找包的版本 按照上述 顶层根节点 引入的依赖 \u0026gt; 依赖管理 \u0026gt; 依赖仲裁 找到合适的包版本 参考文档\nMaven Dependency Mechanism ","permalink":"https://blog.luanrz.cn/posts/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/maven%E4%BE%9D%E8%B5%96%E6%9C%BA%E5%88%B6%E6%B5%85%E6%9E%90/","summary":"\u003cp\u003eMaven通过pom文件来管理Java包的依赖关系，多个pom文件组合在一起可以理解为一颗抽象的依赖树，父节点或祖父节点的包会传递给子节点或祖孙节点，这被称作\u003cstrong\u003e传递依赖\u003c/strong\u003e(Transitive-Dependencies)。\u003c/p\u003e\n\u003cp\u003e传递依赖一般通过两个标签来实现：parent与dependency，其中，parent定义了上级依赖，dependency定义了下级依赖。\u003c/p\u003e\n\u003cp\u003e随着项目复杂性的提升，依赖树中包发生冲突的概率也会增加，Maven通过\u003cstrong\u003e依赖仲裁\u003c/strong\u003e(Dependency-Mediation)与\u003cstrong\u003e依赖管理\u003c/strong\u003e(Dependency-Management)来唯一确定依赖树中包的版本。\u003c/p\u003e","title":"Maven依赖机制浅析"},{"content":"ThreadLocal是一种实现线程安全的机制，它提供了访问线程局部变量（thread-local variables）的方法，线程局部变量与普通变量的不同之处在于，线程局部变量在每一个线程中的值都是独立的，这保证了在多线程环境下不会出现线程串用的问题。\n还可以使用同步来实现线程安全，如：互斥同步（synchronized、ReentrantLock）与非阻塞同步（atomic原子类），ThreadLocal属于非同步方案。\n一、ThreadLocal的使用 日志记录ID是一个很常见的Web应用场景：在请求开始时生成一个TID，在响应返回前的任何时候都可以使用这个TID，其中，TID的生成与获取一般位于在不同的地方，并且每个线程的TID都是相互独立的。使用ThreadLocal可以轻松实现上述过程，如下所示：\npublic class TransactionHolder { // 定义ThreadLocal private static final ThreadLocal\u0026lt;String\u0026gt; transactionIdThreadLocal = new ThreadLocal\u0026lt;\u0026gt;(); private void setTransactionId(String transactionId) { // 设值 transactionIdThreadLocal.set(transactionId); } private String getTransactionId() { // 取值 return transactionIdThreadLocal.get(); } private void removeTransactionId() { // 删值 transactionIdThreadLocal.remove(); } } 具体来说，ThreadLocal的使用分为以下几步：\n定义ThreadLocal属性\n一般使用private static来修饰它，static保证线程局部变量的唯一性，如果不加static，每个TransactionHolder实例将维护不同的transactionIdThreadLocal，这样没有意义且在某些时候甚至可能会出错。\n使用set()方法\n为当前线程局部变量赋值。\n使用get()方法\n读取当前线程局部变量的值。\n使用remove()方法\n移除线程局部变量，防止内存泄漏。\n二、ThreadLocal源码分析 ThreadLocal源码涉及到Thread、ThreadLocalMap、Entry几个类，如下图所示：\n@startuml ThreadLocal类图 class ThreadLocal\u0026lt;T\u0026gt; { - int threadLocalHashCode + void set(T value) + T get() + void remove() } class ThreadLocalMap { - Entry[] table - Entry getEntry(ThreadLocal\u0026lt;?\u0026gt; key) - set(ThreadLocal\u0026lt;?\u0026gt; key, Object value) - void remove(ThreadLocal\u0026lt;?\u0026gt; key) } class Entry { - Object value } class Thread { - ThreadLocalMap threadLocals } ThreadLocal ..\u0026gt; Thread ThreadLocal +-- ThreadLocalMap ThreadLocal ..\u0026gt; ThreadLocalMap Thread o-\u0026gt; ThreadLocalMap ThreadLocalMap +-\u0026gt; Entry ThreadLocalMap *-\u0026gt; Entry Entry -|\u0026gt; WeakReference @enduml ThreadLocal通过Thread.currentThread()获取到当前线程实例，并获取到当前线程实例的ThreadLocalMap属性，通过操作ThreadLocalMap中的Entry来实现线程局部变量的读写。\n接下来简单分析一下ThreadLocal的set()方法、get()方法及remove()方法\nset()方法 public void set(T value) { Thread t = Thread.currentThread(); // 获取当前线程实例 ThreadLocalMap map = getMap(t); // 获取当前线程实例的ThreadLocalMap属性 if (map != null) { map.set(this, value); // 设值 } else { createMap(t, value); // map不存在时，创建ThreadLocalMap，并设值 } } get()方法 public T get() { Thread t = Thread.currentThread(); // 获取当前线程实例 ThreadLocalMap map = getMap(t); // 获取当前线程实例的ThreadLocalMap属性 if (map != null) { ThreadLocalMap.Entry e = map.getEntry(this); // 根据当前ThreadLocal的threadLocalHashCode，在map中找到对应的Entry实例 if (e != null) { @SuppressWarnings(\u0026#34;unchecked\u0026#34;) T result = (T)e.value; return result; // 取值 } } return setInitialValue(); // map不存在时，创建map，返回默认值null } remove()方法 public void remove() { ThreadLocalMap m = getMap(Thread.currentThread()); // 获取当前线程实例的ThreadLocalMap属性 if (m != null) { m.remove(this); // 删值 } } 可以看到，ThreadLocal的读写实际上就是对ThreadLocalMap的读写，其中ThreadLocal中的threadLocalHashCode是ThreadLocalMap的键。\n再进一步分析可以看到ThreadLocalMap是如何利用开放寻址法来索引Entry的，以及ThreadLocalMap的更多细节，有兴趣的话可以看一看。就ThreadLocal而言，这些就足够了。\n参考文档\n《深入理解Java虚拟机第3版 周志明 著》 ","permalink":"https://blog.luanrz.cn/posts/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/threadlocal%E5%8E%9F%E7%90%86%E6%B5%85%E6%9E%90/","summary":"\u003cp\u003eThreadLocal是一种实现线程安全的机制，它提供了访问线程局部变量（thread-local variables）的方法，线程局部变量与普通变量的不同之处在于，线程局部变量在每一个线程中的值都是独立的，这保证了在多线程环境下不会出现线程串用的问题。\u003c/p\u003e","title":"ThreadLocal原理浅析"},{"content":"合理使用单例模式可以节约内存资源，但错误的使用可能会导致严重的生产问题，如：多线程下，一个线程可能会覆盖上一个线程的单例属性，导致两次不同的请求得到同样的响应。\n下面将结合一个例子来分析这种情况。\n一、案例描述 考虑以下代码：\n/** * 单例类 */ public final class Singleton { /** 单例持有的普通变量 */ private String data; /** 单例 */ private static Singleton singleton; /** * 私有构造方法 */ private Singleton(){ } /** * 获取单例 * @return Singleton单例 */ public static Singleton getInstance(){ if (singleton == null){ singleton = new Singleton(); } return singleton; } /** * 核心处理方法 */ public String handle() { // 处理当前单例的data数据 try { //假装在处理 Thread.sleep(100); } catch (InterruptedException e) { e.printStackTrace(); } return \u0026#34;响应：\u0026#34; + data; } /** * 设置data * @param data data * @return Singleton单例 */ public Singleton setData(String data) { this.data = data; return singleton; } } 可以使用下面的链式调用来使用上述单例：\nSingleton.getInstance().setData(\u0026#34;data\u0026#34;).handle(); 调用Singleton.getInstance()获取单例 调用setData()方法为data属性赋值 调用handle()方法处理核心逻辑，其中handle()使用data属性。 在单线程下，上述单例模式没有任何问题。但在多线程下，上述单例至少存在两个问题：\n在多个线程同时调用set()方法时，单例持有的普通变量data中，后一个值可能会覆盖掉前一个值，导致在handle()方法中，使用的都是同一个数据，最终出现请求不同但响应相同的现象。 上述单例为懒汉式单例，只有在首次调用getInstance()时才会实例化，若“首次”调用是多个线程同时执行时，可能会重复创建多个实例（这违背了单例模式的初衷）。 二、问题复现 我们先来看第一个问题，为了复现这种情况，编写以下单元测试代码：\nimport org.junit.Assert; import org.junit.Test; import java.util.*; /** * 单例多线程测试 */ public class SingletonConcurrencyTest { @Test public void test() throws InterruptedException { // 普通HashSet线程不安全，多个线程对同一个Set执行put操作时可能会丢失数据 // 使用Collections.synchronizedSet创建线程安全的HashSet Set\u0026lt;String\u0026gt; responseSet = Collections.synchronizedSet(new HashSet\u0026lt;\u0026gt;()); Set\u0026lt;String\u0026gt; threadNameSet = Collections.synchronizedSet(new HashSet\u0026lt;\u0026gt;()); // 初始化模板渲染线程组 List\u0026lt;Thread\u0026gt; threads = new ArrayList\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; 100; i++) { Thread t = new Thread(() -\u0026gt; { // 核心逻辑 String data = UUID.randomUUID().toString(); String result = Singleton.getInstance() .setData(data) .handle(); // 记录重复响应 if (responseSet.contains(result)) { result = result + \u0026#34;重复\u0026#34;; System.out.println(result); } responseSet.add(result); threadNameSet.add(Thread.currentThread().getName()); }); threads.add(t); } // 批量启动模板渲染线程 for (Thread t : threads) { t.start(); } for (Thread t : threads) { t.join(); } // 结果断言 System.out.println(\u0026#34;线程执行完成次数:\u0026#34; + threadNameSet.size()); System.out.println(\u0026#34;非重复响应次数：\u0026#34; + responseSet.size()); Assert.assertTrue(responseSet.stream().noneMatch(id -\u0026gt; id.contains(\u0026#34;重复\u0026#34;))); } } 运行上述单例模式之后将会打印日志：\n2c20a55b-aa85-4809-ab09-b2a5c58c38a5重复 ... 2c20a55b-aa85-4809-ab09-b2a5c58c38a5重复 线程执行完成次数:100 非重复响应次数：2 java.lang.AssertionError 可以看到，同时发了一百个请求，最终却得到了98个重复的响应。\n三、修改方案 为了避免线程串用单例中的属性，有以下三种修改方案：\n弃用单例模式，每次使用时新建对象 去掉单例模式中的普通属性，通过参数的形式将数据传输给对应方法 将单例模式中的普通属性设置为ThreadLocal变量 方案3修改最简单且效率相对较高，下面将使用此方案。\n修改单例类如下：\n/** * 单例类 */ public final class Singleton { /** * 单例持有的普通变量 */ private ThreadLocal\u0026lt;String\u0026gt; dataThreadLocal = new ThreadLocal\u0026lt;\u0026gt;(); /** * 单例 */ private static Singleton singleton; /** * 私有构造方法 */ private Singleton() { } /** * 获取单例 * * @return Singleton单例 */ public static Singleton getInstance() { if (singleton == null) { singleton = new Singleton(); } return singleton; } /** * 核心处理方法 */ public String handle() { String data = dataThreadLocal.get(); // 处理当前单例的data数据 try { //假装在处理 Thread.sleep(100); } catch (InterruptedException e) { e.printStackTrace(); } // 使用完之后移除ThreadLocal以避免内存泄漏 dataThreadLocal.remove(); return \u0026#34;响应：\u0026#34; + data; } /** * 设置data * * @param data data * @return Singleton单例 */ public Singleton setData(String data) { dataThreadLocal.set(data); return singleton; } } 正常情况下，使用ThreadLocal后，每个线程将持有各自的data值，属性串用的问题将得到解决。再次运行SingletonConcurrencyTest单元测试，日志如下所示：\n[响应：null]重复 [响应：null]重复 [响应：null]重复 [响应：null]重复 [响应：null]重复 [响应：null]重复 线程执行完成次数:100 非重复响应次数：95 结果并没有和预期一样！可以看到，在调用ThreadLocal的get()方法时，返回了null。还记得案例描述中说的两个问题吗，我们的单例是懒汉式的，导致多线程下创建了多个实例，同时，我们的ThreadLocal不是static的，每个实例都持有独立的ThreadLocal变量，最终导致返回了null（此处挖坑，后面写一篇ThreadLocal原理的文章）！\n通过以下两种方式可以解决这个问题：\n为ThreadLocal加上static标识（官方也是这么建议的，详见ThreadLocal源码注释） 为懒汉式单例getInstance()方法加锁，或使用饿汉式单例 //Singleton.java //方式1 private static ThreadLocal\u0026lt;String\u0026gt; dataThreadLocal = new ThreadLocal\u0026lt;\u0026gt;(); //方式2:饿汉式单例 private static Singleton singleton = new Singleton(); 再次运行单元测试，日志如下所示：\n线程执行完成次数:100 非重复响应次数：100 成功解决！\n","permalink":"https://blog.luanrz.cn/posts/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/java%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E4%B8%AD%E7%9A%84%E4%B8%80%E4%B8%AA%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%97%AE%E9%A2%98/","summary":"\u003cp\u003e合理使用单例模式可以节约内存资源，但错误的使用可能会导致严重的生产问题，如：多线程下，一个线程可能会覆盖上一个线程的单例属性，导致两次不同的请求得到同样的响应。\u003c/p\u003e\n\u003cp\u003e下面将结合一个例子来分析这种情况。\u003c/p\u003e","title":"Java单例模式中的一个多线程问题"},{"content":"Spring官网中描述了Spring能做的7件事，如下所示：\n@startmindmap * Spring * Microservices（微服务） * Reactive（响应式） * Cloud（云） * Web apps（网页应用） * Serverless（无服务器） * Event Driven（事件驱动） * Batch（批处理） @endmindmap 下面将简单介绍各场景的概念与其关联的项目。\n一、Microservices 微服务（Microservice）是一个小型的、高度自含的、随时可运行的软件实体，多个相互独立的微服务协同工作构成的微服务架构，可以替代掉传统的大而全的单体服务架构，带来更高的灵活性。\n微服务在Spring中涉及到的项目如下：\n项目 功能 Spring Boot 快速搭建一个微服务（Java微服务的事实标准） Spring Cloud 使多个微服务更好地支持分布式特性（服务发现、负载均衡、熔断、分布式跟踪、监控等） Spring Cloud Stream 使微服务可以处理实时消息，以构建一个高度可伸缩的、事件驱动的系统 Micrometer 监控微服务的各项指标 二、Reactive 响应式（Reactive）系统可以实现低延迟与高吞吐，它有几个特性：快速响应（responsive）、可恢复（resilient）、有弹性（elastic）与消息驱动（ message-driven）。响应式处理是一种范式，它可以帮助开发者开发出非阻塞的、异步的应用，这种应用可以处理回压（back-pressure），其中，“回压”是指在应用处理能力达到阀值时的一种反馈现象。\n响应式在Spring中涉及到的项目如下：\n项目 功能 Reactor Spring响应式的基础，Spring WebFlux、Spring Data和Spring Cloud Gateway都用到了它 Spring WebFlux 非阻塞性Web框架，相对于Spring MVC而言，可以使用更少的资源处理更多的请求 Spring Data （原生）支持以响应式的方式访问数据库资源（如MongoDB、Redis 和 Cassandra） R2DBC （三方）支持以响应式的方式访问数据库资源（如Postgres、Microsoft SQL Server、 MySQL、H2和 Google Spanner)） Spring Cloud Stream 支持以响应式的方式访问消息资源（如RabbitMQ和Kafka） 三、Cloud 云（Cloud）原生应用要求微服务在分布式场景中满足12-Factor ，Spring Cloud套件包含了许多让应用程序在云中运行所需的服务（如服务发现、网关、配置、熔断、链路跟踪等）。\n云原生在Spring中涉及到的项目如下：\n项目 功能 Eureka 服务发现 Consul 服务发现 Zookeeper 服务发现 Spring Cloud Gateway 网关 Spring Cloud Config 配置 Spring Cloud Circuit Breaker 熔断 Resilience4J 熔断 Sentinel 熔断 Hystrix 熔断 Spring Cloud Sleuth 链路跟踪 Zipkin 链路跟踪 Spring Cloud Contract 测试 四、Web apps 使用Spring构建的网页应用（Web apps）去掉了大量样板代码和配置（得益于SpringBoot的支持），它简化了服务端HTML应用、REST接口等的开发。\n网页应用在Spring中涉及到的项目如下：\n项目 功能 Spring Boot 网页应用脚手架 Spring Security 网页应用安全支持 Spring Data 网页应用数据访问支持 五、Serverless 无服务器（Serverless）顾名思义，就是指无需关注服务器等基础设施而只需要关注业务逻辑的一种模型，它在一些情况下与FaaS（功能即服务）等价，国内的Serverless实现有腾讯云的“云函数 SCF”与阿里云的“函数计算 FC”。\n无服务器在Spring中涉及到的项目如下：\n项目 功能 Spring Cloud Function 提供无服务器（FaaS）支持 六、Event Driven 事件驱动（Event Driven）也可使称之为消息驱动，每一个事件驱动的系统都是基于消息处理来实现的。\n项目 功能 Spring Cloud Stream 提供“Binders”、“Bindings”和“Messages”三个核心概念来帮助更好地连接Kafka与RabbitMQ等消息组件 Spring Cloud Function 更好地处理多个消息的输入与输出，如合并、连接等操作 Spring Cloud Data Flow 提供跨多个云原生平台处理各种数据源的工具 Spring AMQP 支持AMQP（Advanced Message Queuing Protocol，高级消息队列协议） Spring Kafka 支持Apache Kafka 七、Batch 批处理（Batch）用于处理大量数据，处理过程中不需要外部交互且不会中断。\n","permalink":"https://blog.luanrz.cn/posts/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/spring%E7%9A%847%E4%B8%AA%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/","summary":"\u003cp\u003e\u003ca href=\"https://spring.io\"\u003eSpring官网\u003c/a\u003e中描述了Spring能做的7件事，如下所示：\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode class=\"language-plantuml\" data-lang=\"plantuml\"\u003e@startmindmap\n* Spring\n\t* Microservices（微服务）\n\t* Reactive（响应式）\n\t* Cloud（云）\n\t* Web apps（网页应用）\n\t* Serverless（无服务器）\n\t* Event Driven（事件驱动）\n\t* Batch（批处理）\n@endmindmap\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e下面将简单介绍各场景的概念与其关联的项目。\u003c/p\u003e","title":"Spring的7个使用场景"},{"content":"一、命令行工具 序号 名称 功能 1 jps 虚拟机进程状况工具，主要用于查找vmid，是后续命令的基础 2 jstat 虚拟机统计信息监视工具，查找虚拟机进程中类加载、内存、GC等信息 3 jinfo Java配置信息工具，实时查看和调整虚拟机各项参数 4 jmap Java内存映像工具，生成堆转储快照（headump、dump），与jhat配合使用 5 jhat 虚拟机堆转储快照分析工具，分析jmap生成的堆转储快照文件，与jmap配合使用 6 jstack Java堆栈跟踪工具，生成虚拟机当前时刻的线程快照（threaddump、javacore） 7 jcmd Java命令行工具集，整合了上述众多命令 8 clhsdb HotSpot命令行调试器，也整合了上述众多命令，它在JDK9时被纳入了jhsdb 二、可视化工具 序号 名称 功能 1 JHSDB 基于服务性代理的调试工具，JDK内置（从JDK9开始提供） 2 JConsole Java监视与管理控制台，JDK内置 3 VisualVM 多合一故障处理工具，需要单独下载 4 JMC 可持续在线的监控工具，需要单独下载 参考文档\n《深入理解Java虚拟机第3版 周志明 著》 ","permalink":"https://blog.luanrz.cn/posts/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/jvm%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E5%B7%A5%E5%85%B7%E6%B1%87%E6%80%BB/","summary":"一、命令行工具 序号 名称 功能 1 jps 虚拟机进程状况工具，主要用于查找vmid，是后续命令的基础 2 jstat 虚拟机统计信息监视工具，查找虚拟机进程中类加载、内存、GC等信息 3 jinfo Java配置信息工具，实时查看和调整虚拟机各项参数 4 jmap Java内存映像工具，生成堆转储快照（headump、dump），与jhat配合使用 5 jhat 虚拟机堆转储快照分析工具，分析jmap生成的堆转储快照文件，与jmap配合使用 6 jstack Java堆栈跟踪工具，生成虚拟机当前时刻的线程快照（threaddump、javacore） 7 jcmd Java命令行工具集，整合了上述众多命令 8 clhsdb HotSpot命令行调试器，也整合了上述众多命令，它在JDK9时被纳入了jhsdb 二、可视化工具 序号 名称 功能 1 JHSDB 基于服务性代理的调试工具，JDK内置（从JDK9开始提供） 2 JConsole Java监视与管理控制台，JDK内置 3 VisualVM 多合一故障处理工具，需要单独下载 4 JMC 可持续在线的监控工具，需要单独下载 参考文档\n《深入理解Java虚拟机第3版 周志明 著》 ","title":"JVM性能调优工具汇总"},{"content":"一、常用数据结构一览 数据结构 用途 vector 动态数组 stack 先入后出的线性表 queue 先入先出的线性表 map 键值对元素集合 set 无序非重复集合 持续完善与更新中\u0026hellip;\nvector 1.导入vector vector是STL中的一个容器类，其位于std命名空间。\n#include \u0026lt;vector\u0026gt; using namespace std; 2.定义vector vector使用一个泛型来指定vector元素的数据类型。\n// 定义元素数据类型为int的vector vector\u0026lt;int\u0026gt; int_vector; // 定义元素数据类型为string的vector(在使用string之前先include) vector\u0026lt;string\u0026gt; string_vector; 3.初始化vector 定义vector时不加任何赋值语句，其本身已经初始化为一个空的vector。\n与普通数组的初始化方式一样，vector也可以使用{元素1, 元素2, ... 元素n}的形式初始化多个元素，如下所示：\nvector\u0026lt;int\u0026gt; int_vector = {1, 2, 3}; 4.使用vector // 通过下标取值 int first_element = int_vector[0]; // 遍历（普通方式） int current_vector_element; for (int i = 0; i \u0026lt; int_vector.size(); i++) { current_vector_element = int_vector[i]; } // 遍历（迭代器方式） vector\u0026lt;int\u0026gt;::iterator iterator; for (iterator = int_vector.begin(); iterator != int_vector.end(); iterator++) { current_vector_element = *iterator; } // 在末尾增加元素 int_vector.push_back(4); // 删除末尾的元素 int_vector.pop_back(); stack // TODO\nqueue // TODO\nmap 1.导入map map是STL中的一个容器类，其位于std命名空间。\n#include \u0026lt;map\u0026gt; using namespace std; 2.定义map map使用两个泛型来指定map元素中键与值的数据类型。\n// 定义键为string类型且值为int类型的map map\u0026lt;string,int\u0026gt; string_int_map; 3.初始化map map可以使用{ {键1,值1}, {键2,值2}, ... {键n,值n} }的形式初始化多个元素，如下所示：\nmap\u0026lt;string,int\u0026gt; string_int_map = {{\u0026#34;a\u0026#34;,1}, {\u0026#34;b\u0026#34;,2}}; 4.使用map // 遍历（迭代器方式） string current_key; int current_value; map\u0026lt;string,int\u0026gt;::iterator iterator; for (iterator = string_int_map.begin(); iterator != string_int_map.end(); iterator++) { current_key = iterator-\u0026gt;first; current_value = iterator-\u0026gt;second; } set // TODO\n","permalink":"https://blog.luanrz.cn/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/c++%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E5%AE%9A%E4%B9%89%E4%B8%8E%E4%BD%BF%E7%94%A8/","summary":"\u003ch2 id=\"一常用数据结构一览\"\u003e一、常用数据结构一览\u003c/h2\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e数据结构\u003c/th\u003e\n\u003cth\u003e用途\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ca href=\"#vector\"\u003evector\u003c/a\u003e\u003c/td\u003e\n\u003ctd\u003e动态数组\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ca href=\"#stack\"\u003estack\u003c/a\u003e\u003c/td\u003e\n\u003ctd\u003e先入后出的线性表\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ca href=\"#queue\"\u003equeue\u003c/a\u003e\u003c/td\u003e\n\u003ctd\u003e先入先出的线性表\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ca href=\"#map\"\u003emap\u003c/a\u003e\u003c/td\u003e\n\u003ctd\u003e键值对元素集合\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ca href=\"#set\"\u003eset\u003c/a\u003e\u003c/td\u003e\n\u003ctd\u003e无序非重复集合\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\n\u003c/table\u003e\n\u003cblockquote\u003e\n\u003cp\u003e持续完善与更新中\u0026hellip;\u003c/p\u003e\n\u003c/blockquote\u003e","title":"C++常用数据结构的简单使用"},{"content":"一、Lambda表达式 什么是Lambda表达式?\nLambda表达式是一个函数，有入参和出参，它表示一个行为。\nLambda表达式是一个对象，Java中函数是二等公民，只能依附于类存在，Lambda表达式的目标类型被称之为函数接口。\n（一）Lambda表达式与匿名内部类对象 Lambda表达式和匿名内部类对象很像，在正式介绍Lambda表达式之前，先看看一个匿名内部类对象的例子。\n一般情况下，接口不可以直接实例化，但可以在new接口的过程中重写接口中的方法来创建一个匿名内部类对象。如下所示：\nRunnable anonymousClassesRunnable = new Runnable() { @Override public void run() { System.out.println(\u0026#34;我是一个匿名类内部类对象\u0026#34;); } }; 有没有更简单的方式呢？请看下述代码：\nRunnable lambdaRunnable = () -\u0026gt; System.out.println(\u0026#34;我是一个lambda表达式\u0026#34;); 上述代码中=右侧的() -\u0026gt; System.out.println(\u0026quot;我是一个lambda表达式\u0026quot;)是一个Lambda表达式。\n这个Lambda表达式由三部分组成：\n() : 请求参数，这里为空（对应了上述匿名内部类中run方法的请求参数） System.out.println(\u0026quot;我是一个lambda表达式\u0026quot;): 方法体（对应了上述匿名内部类中run方法的方法体） -\u0026gt; : Lambda表达式标识符，连接左侧的请求参数和右侧的方法体 可以看到，Lambda表达式与匿名内部类对象完全等价，它们都在=右侧，都可以被赋值给=左侧的接口变量，换言之，Lambda表达式本质上是一个接口的实例化对象（在Java中，万物皆对象，lambda表达式也不例外）。那么，任意接口都可以是Lambda表达式的目标类型吗？\n（二） 函数接口 Lambda表达式只能表示一个行为，这就意味着其对应的接口只能有唯一的方法。同时，为了更精确地标识Lambda表达式的目标接口，通常会给对应的接口加上@FunctionalInterface注解。这种接口叫做函数接口。\n函数接口是Lambda表达式的目标类型。\n查看一下上述例子中Runnable类的源码，如下所示：\npackage java.lang; @FunctionalInterface public interface Runnable { public abstract void run(); } 可以看到，Runnable类有以下特性：\n只有一个方法 含有@FunctionalInterface注解 所以，Runnable是一个函数接口。\njdk的java.util.function包中内置了许多函数接口，常见的如下所示：\n接口 方法 使用场景 Predicate boolean test(T t) Strem的filter/match系列 Consumer void accept(T t) Strem的forEach/peek Function\u0026lt;T, R\u0026gt; R apply(T t) Strem的map系列/flatMap系列 Supplier T get() Strem的collect/generate 二、Stream Stream基于Lambda表达式，可以对集合进行复杂操作，实现集合的过滤、映射、去重、排序、查找、求值等功能。\n（一）Stream常用API一览 一个有效的Stream操作可以由0到n个中间操作和1个终止操作组成。\n中间操作（intermediate operation）返回Stream对象，可以在Stream操作过程中链式调用。\n终止操作（terminal operation）返回空或特定值，在终止操作之前，任何中间操作都不会执行。\n1. 中间操作 方法 请求参数类型 返回类型 功能 filter Predicate Stream 过滤 map Function\u0026lt;T,R\u0026gt; Stream 映射 flatMap Function\u0026lt;T,R\u0026gt; Stream 映射 distinct void Stream 去重 sorted Comparator Stream 排序 其它中间操作：mapToInt、mapToLong、mapToDouble、flatMapToInt、flatMapToLong、flatMapToDouble、peek、limit、skip\n2. 终止操作 方法 请求参数类型 返回类型 功能 forEach Consumer void 循环 collect Collector \u0026hellip; 收集 findFirst void Optional 查找 findAny void Optional 查找 anyMatch Predicate boolean 查找 allMatch Predicate boolean 查找 noneMatch Predicate boolean 查找 min Comparator Optional 求值 max Comparator Optional 求值 count void long 求值 其它终止操作：forEachOrdered、reduce、toArray\n（二）创建Stream对象 在正式介绍Stream用法之前，先定义两种类型的列表，后续的所有实例都是基于这两种列表。\nclass Student { private String studentId; private String name; private String gender; private int age; } class School { private String schoolId; private String name; private List\u0026lt;Student\u0026gt; students; } List\u0026lt;Student\u0026gt; syStudents = new ArrayList\u0026lt;\u0026gt;(); List\u0026lt;Student\u0026gt; fdStudents = new ArrayList\u0026lt;\u0026gt;(); List\u0026lt;School\u0026gt; schools = new ArrayList\u0026lt;\u0026gt;(); syStudents.add(new Student(\u0026#34;1\u0026#34;, \u0026#34;野原新之助\u0026#34;, \u0026#34;男\u0026#34;, 5)); syStudents.add(new Student(\u0026#34;2\u0026#34;, \u0026#34;风间彻\u0026#34;, \u0026#34;男\u0026#34;, 5)); syStudents.add(new Student(\u0026#34;3\u0026#34;, \u0026#34;樱田妮妮\u0026#34;, \u0026#34;女\u0026#34;, 4)); syStudents.add(new Student(\u0026#34;4\u0026#34;, \u0026#34;佐藤正男\u0026#34;, \u0026#34;男\u0026#34;, 4)); syStudents.add(new Student(\u0026#34;5\u0026#34;, \u0026#34;阿呆\u0026#34;, \u0026#34;男\u0026#34;, 4)); fdStudents.add(new Student(\u0026#34;1\u0026#34;, \u0026#34;图图\u0026#34;, \u0026#34;男\u0026#34;, 3)); fdStudents.add(new Student(\u0026#34;2\u0026#34;, \u0026#34;小美\u0026#34;, \u0026#34;女\u0026#34;, 3)); fdStudents.add(new Student(\u0026#34;3\u0026#34;, \u0026#34;刷子\u0026#34;, \u0026#34;男\u0026#34;, 4)); fdStudents.add(new Student(\u0026#34;4\u0026#34;, \u0026#34;壮壮\u0026#34;, \u0026#34;男\u0026#34;, 5)); fdStudents.add(new Student(\u0026#34;5\u0026#34;, \u0026#34;小豆丁\u0026#34;, \u0026#34;男\u0026#34;, 1)); schools.add(new School(\u0026#34;1\u0026#34;, \u0026#34;双叶幼稚园\u0026#34;, syStudents)); schools.add(new School(\u0026#34;2\u0026#34;, \u0026#34;翻斗幼儿园\u0026#34;, fdStudents)); 创建Stream对象一般使用Collection.stream()方法，如下所示：\nStream\u0026lt;Student\u0026gt; studentStream = syStudents.stream(); //创建一个元素为Student的Stream对象 Stream\u0026lt;School\u0026gt; schoolsStream = schools.stream(); //创建一个元素为Student的Stream对象 （二）过滤 Stream过滤可以使用filter方法，过滤掉集合中符合特定条件的元素。这是一个中间操作，一般配合collect或findFirst等终止操作一起使用。\nfilter方法接受一个目标类型为Predicate函数接口的lambda表达式作为请求参数。\n// 找到双叶幼稚园中所有年龄大于等于4岁的男孩子 List\u0026lt;Student\u0026gt; newStudents = syStudents .stream() // 创建一个元素为Student的Stream对象 .filter(student -\u0026gt; \u0026#34;男\u0026#34;.equals(student.gender)) // 过滤得到所有性别为男的小朋友 .filter(student -\u0026gt; student.age \u0026gt;= 4) // 在上一步过滤的基础上, 再次过滤得到所有年龄大于等于4的小朋友 .collect(Collectors.toList()); // 收集过滤之后的集合 Assert.assertEquals(3, newStudents.size()); （三）映射 Stream映射可以使用map或flatMap方法，将集合中的元素映射为另一个元素。这是一个中间操作，一般配合collect等终止操作一起使用。\nmap方法与flatMap方法接受一个目标类型为Function函数接口的lambda表达式作为请求参数。\n// 找到双叶幼稚园中所有小朋友的名字 List\u0026lt;String\u0026gt; newStudents = syStudents .stream() .map(student -\u0026gt; student.name) // 将student对象映射为姓名 .collect(Collectors.toList());// 收集姓名集合 Assert.assertEquals(\u0026#34;[野原新之助, 风间彻, 樱田妮妮, 佐藤正男, 阿呆]\u0026#34;, newStudents.toString()); // 获得所有幼稚园中的小朋友集合 List\u0026lt;Student\u0026gt; newStudentsFromAllSchool = schools .stream() .flatMap(school -\u0026gt; school.students.stream()) // 将school对象映射为一个student流, 并将所有的student流合并成一个 .collect(Collectors.toList()); Assert.assertEquals(10, newStudentsFromAllSchool.size()); （四）去重 Stream去重可以使用distinct方法，去除集合中的重复元素。这是一个中间操作，一般配合collect等终止操作一起使用。\ndistinct方法没有请求参数, 只有重写集合元素类的equals方法时, distinct去重才有意义。\nsyStudents.add(new Student(\u0026#34;1\u0026#34;,\u0026#34;蜡笔小新\u0026#34;,\u0026#34;男\u0026#34;, 5)); // 去除双叶幼稚园中重复的小朋友 List\u0026lt;Student\u0026gt; newStudents = syStudents .stream() .distinct() // 去重, 必须重写equals方法 .collect(Collectors.toList());//收集去重后的集合 Assert.assertEquals(5, newStudents.size()); （五）排序 Stream排序可以使用sorted方法，对集合中的元素进行排序。这是一个中间操作，一般配合collect等终止操作一起使用。\nsorted方法可以接受一个目标类型为Comparator函数接口的lambda表达式作为请求参数。sorted方法也有一个无参的重载方法，必须保证集合元素类实现实现Comparable接口，才能调用sorted的无参重载方法否则会抛出ClassCastException异常。\n// 将双叶幼稚园中所有的小朋友按年龄从小到大顺序重新排序 List\u0026lt;Student\u0026gt; newStudents = syStudents .stream() .sorted((o1, o2) -\u0026gt; o1.age - o2.age) // 按年龄从小到大排序 .collect(Collectors.toList()); //收集排序后的集合 Assert.assertEquals(3, newStudents.get(0).age); （六）查找 Stream查找也可以使用findFirst及findAny方法，找到集合中第一个或任意满足特定条件的一个元素。这是一个终止操作，一般配合filter中间操作一起使用。\nfind系列方法没有请求参数, 返回一个Optional对象。\n// 查找双叶幼稚园中第一个studentId为1的小朋友 Optional\u0026lt;Student\u0026gt; optionalFirstStudent = syStudents .stream() .filter(student -\u0026gt; Objects.equals(student.studentId, \u0026#34;1\u0026#34;)) // 过滤得到所有studentId为1的小朋友 .findFirst(); // 在上述过滤的到的集合中找到第一个符合条件的元素 // Optional对象处理 Student firstStudent = optionalFirstStudent.get(); Assert.assertEquals(\u0026#34;野原新之助\u0026#34;, firstStudent.name); // 查找双叶幼稚园任意一个3岁的小朋友 Optional\u0026lt;Student\u0026gt; optionalAnyStudent = syStudents .stream() .filter(student -\u0026gt; Objects.equals(student.age, 3)) // 过滤得到所有年龄为3的小朋友 .findAny(); // 在上述过滤的到的集合中找到第一个符合条件的元素 // Optional对象处理 Student anyStudent = optionalAnyStudent.orElse(new Student(null, null, null, 0)); Assert.assertEquals(\u0026#34;阿呆\u0026#34;, anyStudent.name); Stream查找使用anyMatch、allMatch及noneMatch方法，判断集合中的元素是否满足特定条件。这是一个终止操作。\nmatch系列方法接受一个目标类型为Predicate函数接口的lambda表达式作为请求参数。\n// 判断双叶幼稚园中是否所有的小朋友的年龄都小于等于5岁 boolean isAllCorrect = syStudents .stream() .allMatch(student -\u0026gt; student.age \u0026lt;= 5); // 判断是否所有的小朋友的年龄都小于等于5岁 Assert.assertTrue(isAllCorrect); // 判断双叶幼稚园中是否有任意一个的小朋友是女孩子 boolean isAnyCorrect = syStudents .stream() .anyMatch(student -\u0026gt; Objects.equals(student.gender, \u0026#34;女\u0026#34;)); // 判断有任意一个的小朋友的性别为女 Assert.assertTrue(isAnyCorrect); // 判断双叶幼稚园中是否没有一个小朋友的年龄大于5岁 boolean isNoneCorrect = syStudents .stream() .noneMatch(student -\u0026gt; student.age \u0026gt; 5); // 判断是否没有一个小朋友的年龄大于5岁 Assert.assertTrue(isNoneCorrect); （七）求值 Stream排序可以使用min、max及count等方法，求得集合的最小值、最大值及元素个数等值。这是一个终止操作。\n// 计算双叶幼稚园中所有的小朋友的最小年龄 int minAge = syStudents .stream() .map(student -\u0026gt; student.age) .min((o1, o2) -\u0026gt; o1 - o2) .get(); // 计算双叶幼稚园中所有的小朋友的最大年龄 int maxAge = syStudents .stream() .map(student -\u0026gt; student.age) .max((o1, o2) -\u0026gt; o1 - o2) .get(); // 计算双叶幼稚园中所有的小朋友的人数 long count = syStudents .stream() .count(); Assert.assertEquals(3, minAge); Assert.assertEquals(5, maxAge); Assert.assertEquals(5, count); 附录 代码实例 import org.junit.Assert; import org.junit.Before; import org.junit.Test; import java.util.ArrayList; import java.util.List; import java.util.Objects; import java.util.Optional; import java.util.stream.Collectors; import java.util.stream.Stream; public class LambdaDemo { List\u0026lt;Student\u0026gt; syStudents = new ArrayList\u0026lt;\u0026gt;(); List\u0026lt;Student\u0026gt; fdStudents = new ArrayList\u0026lt;\u0026gt;(); List\u0026lt;School\u0026gt; schools = new ArrayList\u0026lt;\u0026gt;(); /** * 初始化数据 */ @Before public void initData() { syStudents.add(new Student(\u0026#34;1\u0026#34;, \u0026#34;野原新之助\u0026#34;, \u0026#34;男\u0026#34;, 5)); syStudents.add(new Student(\u0026#34;2\u0026#34;, \u0026#34;风间彻\u0026#34;, \u0026#34;男\u0026#34;, 5)); syStudents.add(new Student(\u0026#34;3\u0026#34;, \u0026#34;樱田妮妮\u0026#34;, \u0026#34;女\u0026#34;, 4)); syStudents.add(new Student(\u0026#34;4\u0026#34;, \u0026#34;佐藤正男\u0026#34;, \u0026#34;男\u0026#34;, 4)); syStudents.add(new Student(\u0026#34;5\u0026#34;, \u0026#34;阿呆\u0026#34;, \u0026#34;男\u0026#34;, 3)); fdStudents.add(new Student(\u0026#34;1\u0026#34;, \u0026#34;图图\u0026#34;, \u0026#34;男\u0026#34;, 3)); fdStudents.add(new Student(\u0026#34;2\u0026#34;, \u0026#34;小美\u0026#34;, \u0026#34;女\u0026#34;, 3)); fdStudents.add(new Student(\u0026#34;3\u0026#34;, \u0026#34;刷子\u0026#34;, \u0026#34;男\u0026#34;, 4)); fdStudents.add(new Student(\u0026#34;4\u0026#34;, \u0026#34;壮壮\u0026#34;, \u0026#34;男\u0026#34;, 5)); fdStudents.add(new Student(\u0026#34;5\u0026#34;, \u0026#34;小豆丁\u0026#34;, \u0026#34;男\u0026#34;, 1)); schools.add(new School(\u0026#34;1\u0026#34;, \u0026#34;双叶幼儿园\u0026#34;, syStudents)); schools.add(new School(\u0026#34;2\u0026#34;, \u0026#34;翻斗幼儿园\u0026#34;, fdStudents)); } /** * 展示一个简单的Lambda表达式 */ @Test public void showLambdaAndAnonymousClass() { Runnable anonymousClassRunnable = new Runnable() { @Override public void run() { System.out.println(\u0026#34;我是一个匿名类内部类对象\u0026#34;); } }; Runnable lambdaRunnable = () -\u0026gt; System.out.println(\u0026#34;我是一个lambda表达式\u0026#34;); new Thread(anonymousClassRunnable).start(); new Thread(lambdaRunnable).start(); } /** * 1. 创建Stream对象 */ @Test public void createStreamObject() { Stream\u0026lt;Student\u0026gt; studentStream = syStudents.stream(); //创建一个元素为Student的Stream对象 Stream\u0026lt;School\u0026gt; schoolsStream = schools.stream(); //创建一个元素为Student的Stream对象 } /** * 2. 过滤 */ @Test public void filter() { // 找到双叶幼稚园中所有年龄大于等于4岁的男孩子 List\u0026lt;Student\u0026gt; newStudents = syStudents .stream() // 创建一个元素为Student的Stream对象 .filter(student -\u0026gt; \u0026#34;男\u0026#34;.equals(student.gender)) // 过滤得到所有性别为男的小朋友 .filter(student -\u0026gt; student.age \u0026gt;= 4) // 在上一步过滤的基础上, 再次过滤得到所有年龄大于等于4的小朋友 .collect(Collectors.toList()); // 收集过滤之后的集合 Assert.assertEquals(3, newStudents.size()); } /** * 3. 映射 */ @Test public void map() { // 找到双叶幼稚园中所有小朋友的名字 List\u0026lt;String\u0026gt; newStudents = syStudents .stream() .map(student -\u0026gt; student.name) // 将student对象映射为姓名 .collect(Collectors.toList());// 收集姓名集合 Assert.assertEquals(\u0026#34;[野原新之助, 风间彻, 樱田妮妮, 佐藤正男, 阿呆]\u0026#34;, newStudents.toString()); // 获得所有幼稚园中的小朋友集合 List\u0026lt;Student\u0026gt; newStudentsFromAllSchool = schools .stream() .flatMap(school -\u0026gt; school.students.stream()) // 将school对象映射为一个student流, 并将所有的student流合并成一个 .collect(Collectors.toList());// 收集合并后的student集合 Assert.assertEquals(10, newStudentsFromAllSchool.size()); } /** * 4. 去重 */ @Test public void removeDuplicate() { syStudents.add(new Student(\u0026#34;1\u0026#34;,\u0026#34;野原新之助的替身\u0026#34;,\u0026#34;男\u0026#34;, 5)); // 去除双叶幼稚园中重复的小朋友 List\u0026lt;Student\u0026gt; newStudents = syStudents .stream() .distinct() // 去重, 必须重写equals方法 .collect(Collectors.toList());//收集去重后的集合 Assert.assertEquals(5, newStudents.size()); } /** * 5. 排序 */ @Test public void sort() { // 将双叶幼稚园中所有的小朋友按年龄从小到大顺序重新排序 List\u0026lt;Student\u0026gt; newStudents = syStudents .stream() .sorted((o1, o2) -\u0026gt; o1.age - o2.age) // 按年龄从小到大排序 .collect(Collectors.toList()); //收集排序后的集合 Assert.assertEquals(3, newStudents.get(0).age); } /** * 6. 查找 */ @Test public void findAndMatch() { // 查找双叶幼稚园中第一个studentId为1的小朋友 Optional\u0026lt;Student\u0026gt; optionalFirstStudent = syStudents .stream() .filter(student -\u0026gt; Objects.equals(student.studentId, \u0026#34;1\u0026#34;)) // 过滤得到所有studentId为1的小朋友 .findFirst(); // 在上述过滤的到的集合中找到第一个符合条件的元素 // Optional对象处理 Student firstStudent = optionalFirstStudent.get(); Assert.assertEquals(\u0026#34;野原新之助\u0026#34;, firstStudent.name); // 查找双叶幼稚园任意一个3岁的小朋友 Optional\u0026lt;Student\u0026gt; optionalAnyStudent = syStudents .stream() .filter(student -\u0026gt; Objects.equals(student.age, 3)) // 过滤得到所有年龄为3的小朋友 .findAny(); // 在上述过滤的到的集合中找到第一个符合条件的元素 // Optional对象处理 Student anyStudent = optionalAnyStudent.orElse(new Student(null, null, null, 0)); Assert.assertEquals(\u0026#34;阿呆\u0026#34;, anyStudent.name); // 判断双叶幼稚园中是否所有的小朋友的年龄都小于等于5岁 boolean isAllCorrect = syStudents .stream() .allMatch(student -\u0026gt; student.age \u0026lt;= 5); // 判断是否所有的小朋友的年龄都小于等于5岁 Assert.assertTrue(isAllCorrect); // 判断双叶幼稚园中是否有任意一个的小朋友是女孩子 boolean isAnyCorrect = syStudents .stream() .anyMatch(student -\u0026gt; Objects.equals(student.gender, \u0026#34;女\u0026#34;)); // 判断任意一个的小朋友的性别为女 Assert.assertTrue(isAnyCorrect); // 判断双叶幼稚园中是否没有一个小朋友的年龄大于5岁 boolean isNoneCorrect = syStudents .stream() .noneMatch(student -\u0026gt; student.age \u0026gt; 5); // 判断是否没有一个小朋友的年龄大于5岁 Assert.assertTrue(isNoneCorrect); } /** * 7. 取值 */ @Test public void evaluation() { // 计算双叶幼稚园中所有的小朋友的最小年龄 int minAge = syStudents .stream() .map(student -\u0026gt; student.age) .min((o1, o2) -\u0026gt; o1 - o2) .get(); Assert.assertEquals(3, minAge); // 计算双叶幼稚园中所有的小朋友的最大年龄 int maxAge = syStudents .stream() .map(student -\u0026gt; student.age) .max((o1, o2) -\u0026gt; o1 - o2) .get(); Assert.assertEquals(5, maxAge); // 计算双叶幼稚园中所有的小朋友的人数 long count = syStudents .stream() .count(); Assert.assertEquals(5, count); } class Student { private String studentId; private String name; private String gender; private int age; public Student(String studentId, String name, String gender, int age) { this.studentId = studentId; this.name = name; this.gender = gender; this.age = age; } @Override public boolean equals(Object o) { if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Student student = (Student) o; return studentId.equals(student.studentId); } @Override public int hashCode() { return Objects.hash(studentId); } } class School { private String schoolId; private String name; private List\u0026lt;Student\u0026gt; students; public School(String schoolId, String name, List\u0026lt;Student\u0026gt; students) { this.schoolId = schoolId; this.name = name; this.students = students; } } } ","permalink":"https://blog.luanrz.cn/posts/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/java8%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/","summary":"\u003ch2 id=\"一lambda表达式\"\u003e一、Lambda表达式\u003c/h2\u003e\n\u003cp\u003e什么是Lambda表达式?\u003c/p\u003e\n\u003cp\u003eLambda表达式是一个函数，有入参和出参，它表示一个行为。\u003c/p\u003e\n\u003cp\u003eLambda表达式是一个对象，Java中函数是二等公民，只能依附于类存在，Lambda表达式的目标类型被称之为函数接口。\u003c/p\u003e\n\u003ch3 id=\"一lambda表达式与匿名内部类对象\"\u003e（一）Lambda表达式与匿名内部类对象\u003c/h3\u003e\n\u003cp\u003eLambda表达式和匿名内部类对象很像，在正式介绍Lambda表达式之前，先看看一个匿名内部类对象的例子。\u003c/p\u003e\n\u003cp\u003e一般情况下，接口不可以直接实例化，但可以在new接口的过程中重写接口中的方法来创建一个匿名内部类对象。如下所示：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eRunnable anonymousClassesRunnable \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003enew\u003c/span\u003e Runnable\u003cspan style=\"color:#f92672\"\u003e()\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#a6e22e\"\u003e@Override\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003erun\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e()\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        System\u003cspan style=\"color:#f92672\"\u003e.\u003c/span\u003e\u003cspan style=\"color:#a6e22e\"\u003eout\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e.\u003c/span\u003e\u003cspan style=\"color:#a6e22e\"\u003eprintln\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e(\u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;我是一个匿名类内部类对象\u0026#34;\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#f92672\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#f92672\"\u003e};\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e有没有更简单的方式呢？请看下述代码：\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eRunnable lambdaRunnable = () -\u0026gt; System.out.println(\u0026#34;我是一个lambda表达式\u0026#34;);\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e上述代码中\u003ccode\u003e=\u003c/code\u003e右侧的\u003ccode\u003e() -\u0026gt; System.out.println(\u0026quot;我是一个lambda表达式\u0026quot;)\u003c/code\u003e是一个\u003ccode\u003eLambda表达式\u003c/code\u003e。\u003c/p\u003e\n\u003cp\u003e这个Lambda表达式由三部分组成：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003ccode\u003e()\u003c/code\u003e : 请求参数，这里为空（对应了上述匿名内部类中run方法的请求参数）\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eSystem.out.println(\u0026quot;我是一个lambda表达式\u0026quot;)\u003c/code\u003e: 方法体（对应了上述匿名内部类中run方法的方法体）\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e-\u0026gt;\u003c/code\u003e : Lambda表达式标识符，连接左侧的请求参数和右侧的方法体\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e可以看到，Lambda表达式与匿名内部类对象完全等价，它们都在\u003ccode\u003e=\u003c/code\u003e右侧，都可以被赋值给\u003ccode\u003e=\u003c/code\u003e左侧的接口变量，换言之，\u003cstrong\u003eLambda表达式本质上是一个接口的实例化对象\u003c/strong\u003e（在Java中，万物皆对象，lambda表达式也不例外）。那么，任意接口都可以是Lambda表达式的目标类型吗？\u003c/p\u003e","title":"Java8函数式编程入门"},{"content":" 包管理器 适用语言 主配置文件路径 官方首页 npm NodeJs ~/.npmrc www.npmjs.com pip Python ~/.config/pip/pip.conf pypi.org docker - /etc/docker/daemon.json www.docker.com maven Java ~/.m2/settings.xml maven.apache.org gradle Java - gradle.org go go ~/.config/go/env golang.google.cn npm 配置国内代理 使用npm config命令 # 设置registry npm config set registry http://registry.npm.taobao.org/ # 查看所有配置 npm config list 编辑.npmrc文件 vim ~/.npmrc registry=https://r.npm.taobao.org/ pip 配置国内代理 使用pip config命令 # 设置index-url pip config set global.index-url http://mirrors.aliyun.com/pypi/simple/ # 设置trusted-host pip config set global.trusted-host mirrors.aliyun.com # 设置timeout pip config set global.timeout 60 # 查看所有配置 pip config list 编辑pip.conf文件 vim .config/pip/pip.conf [global] timeout = 60 index-url = http://mirrors.aliyun.com/pypi/simple/ trusted-host=mirrors.aliyun.com tips1: 编辑.config/pip/pip.conf文件与pip config命令等效\ntips2: 也可以编辑.pip/pip.conf文件修改配置，但它的优先级要小于~/.config/pip/pip.conf\ndocker 配置国内代理 编辑daemon.json文件 vim /etc/docker/daemon.json { \u0026#34;registry-mirrors\u0026#34;: [ \u0026#34;https://registry.docker-cn.com\u0026#34;, ] } maven 配置国内代理 编辑settings.xml文件 vim ~/.m2/settings.xml \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;settings\u0026gt; \u0026lt;localRepository\u0026gt;~/.m2/repository\u0026lt;/localRepository\u0026gt; \u0026lt;mirror\u0026gt; \u0026lt;id\u0026gt;nexus-aliyun\u0026lt;/id\u0026gt; \u0026lt;mirrorOf\u0026gt;central\u0026lt;/mirrorOf\u0026gt; \u0026lt;name\u0026gt;Nexus aliyun\u0026lt;/name\u0026gt; \u0026lt;url\u0026gt;https://maven.aliyun.com/repository/public\u0026lt;/url\u0026gt; \u0026lt;/mirror\u0026gt; \u0026lt;profiles\u0026gt; \u0026lt;profile\u0026gt; \u0026lt;id\u0026gt;dev\u0026lt;/id\u0026gt; \u0026lt;repositories\u0026gt; \u0026lt;repository\u0026gt; \u0026lt;id\u0026gt;nexus-aliyun\u0026lt;/id\u0026gt; \u0026lt;url\u0026gt;https://maven.aliyun.com/repository/public/\u0026lt;/url\u0026gt; \u0026lt;releases\u0026gt; \u0026lt;enabled\u0026gt;true\u0026lt;/enabled\u0026gt; \u0026lt;/releases\u0026gt; \u0026lt;snapshots\u0026gt; \u0026lt;enabled\u0026gt;true\u0026lt;/enabled\u0026gt; \u0026lt;/snapshots\u0026gt; \u0026lt;/repository\u0026gt; \u0026lt;/repositories\u0026gt; \u0026lt;pluginRepositories\u0026gt; \u0026lt;pluginRepository\u0026gt; \u0026lt;id\u0026gt;nexus-aliyun\u0026lt;/id\u0026gt; \u0026lt;url\u0026gt;https://maven.aliyun.com/repository/public/\u0026lt;/url\u0026gt; \u0026lt;releases\u0026gt; \u0026lt;enabled\u0026gt;true\u0026lt;/enabled\u0026gt; \u0026lt;/releases\u0026gt; \u0026lt;snapshots\u0026gt; \u0026lt;enabled\u0026gt;true\u0026lt;/enabled\u0026gt; \u0026lt;/snapshots\u0026gt; \u0026lt;/pluginRepository\u0026gt; \u0026lt;/pluginRepositories\u0026gt; \u0026lt;/profile\u0026gt; \u0026lt;/profiles\u0026gt; \u0026lt;activeProfiles\u0026gt; \u0026lt;activeProfile\u0026gt;dev\u0026lt;/activeProfile\u0026gt; \u0026lt;/activeProfiles\u0026gt; \u0026lt;/settings\u0026gt; gradle 配置国内代理 编辑build.gradle文件 适用于Gradle Groovy\nvim ${ProjectPath}/build.gradle repositories { maven {url \u0026#39;https://maven.aliyun.com/repository/public\u0026#39;} } 编辑build.gradle.kts文件 适用于Gradle Kotlin\nvim ${ProjectPath}/build.gradle.kts repositories { maven (\u0026#34;https://maven.aliyun.com/repository/public\u0026#34;) maven (\u0026#34;https://maven.aliyun.com/repository/google\u0026#34;) maven (\u0026#34;https://maven.aliyun.com/repository/gradle-plugin\u0026#34;) } go 配置国内代理 使用go env命令 go env -w GO111MODULE=on go env -w GOPROXY=https://goproxy.cn,direct 编辑env文件 vim ~/.config/go/env GO111MODULE=on GOPROXY=https://goproxy.cn,direct ","permalink":"https://blog.luanrz.cn/posts/%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/%E5%B8%B8%E7%94%A8%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8%E9%85%8D%E7%BD%AE/","summary":"\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e包管理器\u003c/th\u003e\n\u003cth\u003e适用语言\u003c/th\u003e\n\u003cth\u003e主配置文件路径\u003c/th\u003e\n\u003cth\u003e官方首页\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ca href=\"#npm\"\u003enpm\u003c/a\u003e\u003c/td\u003e\n\u003ctd\u003eNodeJs\u003c/td\u003e\n\u003ctd\u003e~/.npmrc\u003c/td\u003e\n\u003ctd\u003e\u003ca href=\"https://www.npmjs.com/\"\u003ewww.npmjs.com\u003c/a\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ca href=\"#pip\"\u003epip\u003c/a\u003e\u003c/td\u003e\n\u003ctd\u003ePython\u003c/td\u003e\n\u003ctd\u003e~/.config/pip/pip.conf\u003c/td\u003e\n\u003ctd\u003e\u003ca href=\"https://pypi.org/\"\u003epypi.org\u003c/a\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ca href=\"#docker\"\u003edocker\u003c/a\u003e\u003c/td\u003e\n\u003ctd\u003e-\u003c/td\u003e\n\u003ctd\u003e/etc/docker/daemon.json\u003c/td\u003e\n\u003ctd\u003e\u003ca href=\"https://www.docker.com/\"\u003ewww.docker.com\u003c/a\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ca href=\"#maven\"\u003emaven\u003c/a\u003e\u003c/td\u003e\n\u003ctd\u003eJava\u003c/td\u003e\n\u003ctd\u003e~/.m2/settings.xml\u003c/td\u003e\n\u003ctd\u003e\u003ca href=\"https://maven.apache.org/\"\u003emaven.apache.org\u003c/a\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ca href=\"#gradle\"\u003egradle\u003c/a\u003e\u003c/td\u003e\n\u003ctd\u003eJava\u003c/td\u003e\n\u003ctd\u003e-\u003c/td\u003e\n\u003ctd\u003e\u003ca href=\"https://gradle.org/\"\u003egradle.org\u003c/a\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ca href=\"#go\"\u003ego\u003c/a\u003e\u003c/td\u003e\n\u003ctd\u003ego\u003c/td\u003e\n\u003ctd\u003e~/.config/go/env\u003c/td\u003e\n\u003ctd\u003e\u003ca href=\"https://golang.google.cn/\"\u003egolang.google.cn\u003c/a\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\n\u003c/table\u003e","title":"常用包管理器配置"},{"content":"以String类中的匹配与替换为入口, 简单介绍Java正则匹配与正则替换\n一、前言 正则表达式一般用于字符串的模式匹配与替换，Java通过Pattern类与Matcher类原生支持正则表达式。在此基础上，String类封装了正则的细节，提供了一种更便捷的正则操作的方式。\n本文将从String类说起，通过它的matches与replace系列方法，介绍String的匹配与替换。随后，将介绍Java正则中的Pattern与Matcher两大核心类的基本使用方法。最后，将从String类源码层面，简单分析String类的正则匹配和正则替换是如何通过Pattern类和Matcher类实现的。\n有关正则表达式的前置知识介绍，请参照本文附录中的正则表达式通用知识。\n二、String匹配与替换 （一）String匹配 可以使用String的matches方法对字符串进行匹配，它的定义为：boolean matches(String regex)，matches方法可以用来判断目标字符串是否符合指定的正则表达式(regex)，一个简单的示例如下：\n// 待匹配的目标字符串 String targetString = \u0026#34;\u0026lt;Name\u0026gt;Violet\u0026lt;/Name\u0026gt;\u0026#34;; // 正则表达式 String regex = \u0026#34;\u0026lt;Name\u0026gt;.*\u0026lt;/Name\u0026gt;\u0026#34;; // 正则匹配 boolean isMatched = targetString.matches(regex); 上述示例中，对\u0026quot;\u0026lt;Name\u0026gt;Violet\u0026lt;/Name\u0026gt;\u0026quot;字符串按照\u0026quot;\u0026lt;Name\u0026gt;.*\u0026lt;/Name\u0026gt;\u0026quot;这个正则表达式进行匹配，因为目标字符串符合规则，所以匹配成功。\n部分场景下，如果只需要判断字符串中是否有某个子串，可以直接使用String的contains方法，这种方法在匹配是否包含子串是很有效，但在更复杂的匹配规则下就不适用了，此时还是需要使用上述的matches方法。\n（二）String替换 可以使用String的replace系列方法对字符串进行替换，包括：replace、replaceAll、replaceFirst，它们的定义如下：\nString replace(char oldChar, char newChar) 字符简单替换，将目标字符串中所有的oldChar字符替换为newChar字符，不涉及到正则表达式 String replace(CharSequence target, CharSequence replacement) 字符串简单替换，将目标字符串中所有的target字符串替换为replacement字符串，不涉及正则表达式 String replaceAll(String regex, String replacement) 字符串正则替换，将目标字符串中所有符合的regex正则表达式的子串替换为replacement String replaceFirst(String regex, String replacement) 字符串正则替换，将目标字符串中第一个符合的regex正则表达式的子串替换为replacement 一个简单的示例如下：\n// 待替换的目标字符串 String targetString = \u0026#34;\u0026lt;Name\u0026gt;Violet\u0026lt;/Name\u0026gt;\u0026#34;; // 正则表达式 String regex = \u0026#34;\u0026lt;Name\u0026gt;.*\u0026lt;/Name\u0026gt;\u0026#34;; // 1. 简单替换所有匹配到的字符 String newString1 = targetString.replace(\u0026#39;V\u0026#39;,\u0026#39;v\u0026#39;); //结果为: \u0026#34;\u0026lt;Name\u0026gt;violet\u0026lt;/Name\u0026gt;\u0026#34; // 2. 简单替换所有匹配到的字符串 String newString2 = targetString.replace(\u0026#34;Violet\u0026#34;,\u0026#34;Violet.Evergarden\u0026#34;); //结果为: \u0026#34;\u0026lt;Name\u0026gt;Violet.Evergarden\u0026lt;/Name\u0026gt;\u0026#34; // 3. 正则替换所有匹配到的字符串 String newString3 = targetString.replaceAll(regex,\u0026#34;\u0026lt;Name\u0026gt;Violet.Evergarden\u0026lt;/Name\u0026gt;\u0026#34;); //结果为: \u0026#34;\u0026lt;Name\u0026gt;Violet.Evergarden\u0026lt;/Name\u0026gt;\u0026#34; // 4. 正则替换第一个匹配到的字符串 String newString4 = targetString.replaceFirst(regex,\u0026#34;\u0026lt;Name\u0026gt;Violet.Evergarden\u0026lt;/Name\u0026gt;\u0026#34;); //结果为: \u0026#34;\u0026lt;Name\u0026gt;Violet.Evergarden\u0026lt;/Name\u0026gt;\u0026#34; 三、Pattern与Matcher Pattern与Matcher是Java支持正则表达式的两大核心类，上述String匹配与替换中的正则匹配与正则替换在底层都是通过Pattern与Matcher来实现的，具体实现过程请参见String正则源码分析。\n一个Pattern与Matcher的基本使用方法的示例如下：\n// 待替换的目标字符串 String targetString = \u0026#34;\u0026lt;Name\u0026gt;Violet\u0026lt;/Name\u0026gt;\u0026#34;; // 正则表达式 String regex = \u0026#34;\u0026lt;Name\u0026gt;.*\u0026lt;/Name\u0026gt;\u0026#34;; // 以正则表达式字符串regex为基础，定义Pattern Pattern pattern = Pattern.compile(regex); // 以Pattern与目标字符串为基础，定义Matcher // 后续的所有正则匹配与正则替换，都是对Matcher进行操作 Matcher matcher = pattern.matcher(targetString); // 正则匹配，等同于String.matches(String regex) boolean isMatched = matcher.matches(); // 正则替换，等同于String.replaceAll(String regex, String replacement) String newString = matcher.replaceAll(\u0026#34;\u0026lt;Name\u0026gt;Violet.Evergarden\u0026lt;/Name\u0026gt;\u0026#34;); Pattern与Matcher还有很多其它的用法，此处暂时不做展开，后续如果有需要在此处进行补充。\n四、String正则源码分析 （一）String正则匹配源码分析 String的matches方法实现如下所示：\npublic boolean matches(String regex) { return Pattern.matches(regex, this); } String的matches方法很简单，只是简单地调用了Pattern类的matches方法。\n进入到Pattern类的matches方法，如下所示：\npublic static boolean matches(String regex, CharSequence input) { Pattern p = Pattern.compile(regex); Matcher m = p.matcher(input); return m.matches(); } 可以发现里面的内容与上一节Pattern与Matcher中的使用示例大同小异：首先根据正则表达式实例化Pattern对象，然后根据Pattern对象与目标字符串实例化Matcher对象，最后调用Matcher对象的matches方法。最终起作用的正是Matcher对象的matches方法。\n（二）String正则替换源码分析 String的replaceFirst与replaceAll方法实现如下所示：\npublic String replaceFirst(String regex, String replacement) { return Pattern.compile(regex).matcher(this).replaceFirst(replacement); } public String replaceAll(String regex, String replacement) { return Pattern.compile(regex).matcher(this).replaceAll(replacement); } String的replace系列方法也很简单：首先调用Pattern.compile(regex)实例化Pattern对象，然后调用Pattern对象的matcher(this)实例化Matcher对象（此处的this就是当前字符串)，最后调用Matcher对象的replaceFirst与replaceAll方法。与String的正则匹配实现方法类似，最终起作用的正是Matcher对象的replaceFirst与replaceAll方法。\n本小节简单分析了如何通过Pattern类和Matcher类来实现String正则匹配与正则替换，具体实现细节可以继续往下深挖，受限于篇幅，此处就不介绍了（其实是因为我是个懒狗，还没看完，挖个坑，后面有时间补上）。\n附录 正则表达式通用知识 (内容正在快马加鞭赶来\u0026hellip;)\n","permalink":"https://blog.luanrz.cn/posts/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/java%E6%AD%A3%E5%88%99%E5%85%A5%E9%97%A8/","summary":"\u003cp\u003e以String类中的匹配与替换为入口, 简单介绍Java正则匹配与正则替换\u003c/p\u003e\n\u003ch2 id=\"一前言\"\u003e一、前言\u003c/h2\u003e\n\u003cp\u003e正则表达式一般用于字符串的模式\u003cstrong\u003e匹配\u003c/strong\u003e与\u003cstrong\u003e替换\u003c/strong\u003e，Java通过Pattern类与Matcher类原生支持正则表达式。在此基础上，String类封装了正则的细节，提供了一种更便捷的正则操作的方式。\u003c/p\u003e\n\u003cp\u003e本文将从String类说起，通过它的matches与replace系列方法，介绍\u003ca href=\"#%E4%BA%8Cstring%E5%8C%B9%E9%85%8D%E4%B8%8E%E6%9B%BF%E6%8D%A2\"\u003eString的匹配与替换\u003c/a\u003e。随后，将介绍Java正则中的\u003ca href=\"#%E4%B8%89pattern%E4%B8%8Ematcher\"\u003ePattern与Matcher\u003c/a\u003e两大核心类的基本使用方法。最后，将从\u003ca href=\"#%E5%9B%9Bstring%E6%AD%A3%E5%88%99%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90\"\u003eString类源码\u003c/a\u003e层面，简单分析String类的正则匹配和正则替换是如何通过Pattern类和Matcher类实现的。\u003c/p\u003e\n\u003cp\u003e有关正则表达式的前置知识介绍，请参照本文\u003ca href=\"#%E9%99%84%E5%BD%95\"\u003e附录\u003c/a\u003e中的\u003ca href=\"#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E9%80%9A%E7%94%A8%E7%9F%A5%E8%AF%86\"\u003e正则表达式通用知识\u003c/a\u003e。\u003c/p\u003e","title":"Java正则入门"},{"content":"介绍数据结构中主要排序算法的流程与具体实现。包括以下八个排序算法：插入排序、希尔排序、冒泡排序、快速排序、选择排序、堆排序、归并排序、基数排序。\n一、排序算法一览 排序方法 时间复杂度 空间复杂度 稳定性 所属类别 插入排序 O(n²) O(1) √ 插入法 选择排序 O(n²) O(1) ×(√) 选择法 冒泡排序 O(n²) O(1) √ 交换法 希尔排序 O(n¹˙³) O(1) × 插入法 快速排序 O(nlogn) O(logn) × 交换法 堆排序 O(nlogn) O(1) × 选择法 归并排序 O(nlogn) O(n) √ - 基数排序 O(d*n) O(n) √ - 二、具体算法实现 （一）插入排序 /** * 插入排序 * @param list 待排序的数组 * @param size 待排序的数组大小 */ void insertionSort(int* list, int size){ for (int i = 1; i \u0026lt; size; ++i) { //\u0026#34;无序区首位元素\u0026#34;小于\u0026#34;有序区尾部元素\u0026#34;时,将当前元素插入有序区 (无序区\u0026#34;首位元素\u0026#34;为i对应的当前元素, 有序区尾部元素为i-1对应的上一元素) if (list[i] \u0026lt; list[i-1]){ int temp = list[i]; int j; //将有序区中所有大于当前元素的值整体向后移动一步 for (j = i-1; temp \u0026lt; list[j] \u0026amp;\u0026amp; j \u0026gt;= 0; --j) { list[j+1] = list[j]; } //将当前元素放入正确的位置 list[j+1] = temp; } } } （二）选择排序 /** * 选择排序 * @param list 待排序的数组 * @param size 待排序的数组大小 */ void selectionSort(int* list, int size){ for (int i = 0; i \u0026lt; size; ++i) { int minIndex; //遍历无序区 //找到无序区最小的元素, 并保存其下标 for (int j = i; j \u0026lt; size; ++j) { if (list[j] \u0026lt; list[minIndex]){ minIndex = j; } } //将\u0026#34;无序区最小元素\u0026#34;与\u0026#34;无序区首位元素\u0026#34;互换(\u0026#34;无序区首位元素\u0026#34;为i对应的当前元素) //此时新的\u0026#34;无序区的首位元素\u0026#34;进入有序区尾部 if (i != minIndex){ int temp = list[i]; list[i] = list[minIndex]; list[minIndex] = temp; } } } （三）冒泡排序 /** * 冒泡排序 * @param list 待排序的数组 * @param size 待排序的数组大小 */ void bubbleSort(int* list, int size){ for (int i = 0; i \u0026lt; size; ++i) { for (int j = i; j \u0026lt; size; ++j) { if (list[j] \u0026gt; list[j+1]){ int temp = list[j]; list[j] = list[j+1]; list[j+1] = temp; } } } } （四）希尔排序 （五）快速排序 （六）堆排序 （七）归并排序 （八）基数排序 参考文档\n《数据结构及应用算法教程 严蔚敏 陈文博 著》 《软件设计师教程 胡圣明 褚华 著》 ","permalink":"https://blog.luanrz.cn/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%AD%E7%9A%84%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/","summary":"\u003cp\u003e介绍数据结构中主要排序算法的流程与具体实现。包括以下八个排序算法：插入排序、希尔排序、冒泡排序、快速排序、选择排序、堆排序、归并排序、基数排序。\u003c/p\u003e\n\u003ch2 id=\"一排序算法一览\"\u003e一、排序算法一览\u003c/h2\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth style=\"text-align:center\"\u003e排序方法\u003c/th\u003e\n\u003cth style=\"text-align:center\"\u003e时间复杂度\u003c/th\u003e\n\u003cth style=\"text-align:center\"\u003e空间复杂度\u003c/th\u003e\n\u003cth style=\"text-align:center\"\u003e稳定性\u003c/th\u003e\n\u003cth style=\"text-align:center\"\u003e所属类别\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:center\"\u003e\u003ca href=\"#%E4%B8%80%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F\"\u003e插入排序\u003c/a\u003e\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003eO(n²)\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003eO(1)\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e√\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e插入法\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:center\"\u003e\u003ca href=\"#%E4%BA%8C%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F\"\u003e选择排序\u003c/a\u003e\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003eO(n²)\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003eO(1)\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e×(√)\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e选择法\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:center\"\u003e\u003ca href=\"#%E4%B8%89%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F\"\u003e冒泡排序\u003c/a\u003e\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003eO(n²)\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003eO(1)\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e√\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e交换法\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:center\"\u003e\u003ca href=\"#%E5%9B%9B%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F\"\u003e希尔排序\u003c/a\u003e\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003eO(n¹˙³)\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003eO(1)\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e×\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e插入法\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:center\"\u003e\u003ca href=\"#%E4%BA%94%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F\"\u003e快速排序\u003c/a\u003e\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003eO(nlogn)\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003eO(logn)\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e×\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e交换法\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:center\"\u003e\u003ca href=\"#%E5%85%AD%E5%A0%86%E6%8E%92%E5%BA%8F\"\u003e堆排序\u003c/a\u003e\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003eO(nlogn)\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003eO(1)\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e×\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e选择法\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:center\"\u003e\u003ca href=\"#%E4%B8%83%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F\"\u003e归并排序\u003c/a\u003e\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003eO(nlogn)\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003eO(n)\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e√\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e-\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:center\"\u003e\u003ca href=\"#%E5%85%AB%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F\"\u003e基数排序\u003c/a\u003e\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003eO(d*n)\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003eO(n)\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e√\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e-\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\n\u003c/table\u003e","title":"数据结构中的排序算法"},{"content":"编译 gcc Hello.cpp 生成可执行文件a.out\ngcc -o Hello.o Hello.cpp 生成可执行文件Hello.o\ngcc -g -o Hello.o Hello.cpp 生成可调试的可执行文件Hello.o\n调试 gdb Hello.o\n常用GDB命令 break ：新增断点。后接一个参数，表示在指定位置增加断点，参数格式为：[源文件名:]\u0026lt;方法名\u0026gt; | [源文件名:]\u0026lt;行数\u0026gt;\ndelete：删除断点。后接零个参数，表示删除所有断点。后接一个参数，表示删除指定序号的断点，参数格式为：\u0026lt;序号\u0026gt;\nstep：往下执行语句，会进入函数。后接零个参数，表示往下执行一条语句。后接一个参数，表示往下执行指定数目的多条语句，参数格式为：\u0026lt;向下行数\u0026gt;\nnext：往下执行语句，不会进入函数。参数规范与step类似\ncontinue：继续运行\nfinish：运行至当前函数返回后退出\nlist：查看代码\nframe：查看帧栈\nbackstrace：查看整个调用栈\ninfo ：查看信息。后接一个参数，参数格式为：\u0026lt;args | locals\u0026gt;，args表示查看函数参数，locals表示查看局部变量\nprint：打印值。\n","permalink":"https://blog.luanrz.cn/posts/%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/%E5%91%BD%E4%BB%A4%E5%A4%87%E5%BF%98%E5%BD%95gdb/","summary":"编译 gcc Hello.cpp 生成可执行文件a.out\ngcc -o Hello.o Hello.cpp 生成可执行文件Hello.o\ngcc -g -o Hello.o Hello.cpp 生成可调试的可执行文件Hello.o\n调试 gdb Hello.o\n常用GDB命令 break ：新增断点。后接一个参数，表示在指定位置增加断点，参数格式为：[源文件名:]\u0026lt;方法名\u0026gt; | [源文件名:]\u0026lt;行数\u0026gt;\ndelete：删除断点。后接零个参数，表示删除所有断点。后接一个参数，表示删除指定序号的断点，参数格式为：\u0026lt;序号\u0026gt;\nstep：往下执行语句，会进入函数。后接零个参数，表示往下执行一条语句。后接一个参数，表示往下执行指定数目的多条语句，参数格式为：\u0026lt;向下行数\u0026gt;\nnext：往下执行语句，不会进入函数。参数规范与step类似\ncontinue：继续运行\nfinish：运行至当前函数返回后退出\nlist：查看代码\nframe：查看帧栈\nbackstrace：查看整个调用栈\ninfo ：查看信息。后接一个参数，参数格式为：\u0026lt;args | locals\u0026gt;，args表示查看函数参数，locals表示查看局部变量\nprint：打印值。","title":"命令备忘录：GDB"},{"content":"删除远程分支 git push origin --del rzluan-orderchange/ndc_xml_api_v3\n克隆指定分支到指定文件夹 git clone -b [branch_name] [git_url] [dir_path]\n变更统计 git log --author=rzluan --after=\u0026#34;2019-11-01 00:00:00\u0026#34; --before=\u0026#34;2019-11-30 23:59:59\u0026#34; --name-only | grep \u0026#39;^src/*\u0026#39; | sort | uniq git log --author=rzluan --after=\u0026#34;2019-11-01 00:00:00\u0026#34; --before=\u0026#34;2019-11-30 23:59:59\u0026#34; --numstat | grep \u0026#34;src\u0026#34; | awk \u0026#39;{a[$3]+=$1;b[$3]+=$2}END{for(j in a) print j,\u0026#34;代码变更\u0026#34;(a[j]+b[j])\u0026#34;行\u0026#34;}\u0026#39; git log --author=rzluan --after=\u0026#34;2019-11-01 00:00:00\u0026#34; --before=\u0026#34;2019-11-30 23:59:59\u0026#34; --numstat | grep \u0026#34;src\u0026#34; | awk \u0026#39;{a[$3]+=($1+$2)}END{for(j in a) b+=a[j]} END{print \u0026#34;总行数\u0026#34;,b}\u0026#39; 修改commit记录 修改提交时间：git commit --amend --date=\u0026quot;May 8 12:00:30 2020 +0800\u0026quot;\n修改提交人信息：git commit --amend --author \u0026quot;luanrzh luanrzh@qq.com\u0026quot;\n强制推送至远程仓库：git push \u0026lt;remote\u0026gt; \u0026lt;branch\u0026gt; -f\n撤销commit记录 git reset HEAD : 撤销commit，撤销暂存区，工作空间代码改动不变 git reset --mixed HEAD^ : 同上 git reset --soft HEAD^ : 撤销commit，暂存区不变，工作空间代码改动不变 git reset --hard HEAD^ : 撤销commit，清空暂存区，清空工作空间代码改变 git reset HEAD~n : 撤销n次commit git commit --amend : 修改commit注释 清除所有commit记录 参见Git – Remove All Commits – Clear Git History (Local \u0026amp; Remote)\ngit checkout --orphan temp_branch # 切换到一个临时分支，该分支的状态和`git init`很像 # 在一步可以做一些特殊操作，如删除当前文件夹下所有文件、新增文件等等，后续新分支将会以此处的文件状态为准 git add -A # 提交工作区中所有文件变动，到临时分支暂存区 git commit -am \u0026#34;The first commit\u0026#34; # 提交暂存区中所有文件变动，到临时分支本地仓库 git branch -D main # 删除需要清除所有commit记录的分支 git branch -m main # 将当前临时分支修改成刚刚删掉的分支名 $ git push -f origin main # 推送到远程仓库（！！！危险操作！！！） ","permalink":"https://blog.luanrz.cn/posts/%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/%E5%91%BD%E4%BB%A4%E5%A4%87%E5%BF%98%E5%BD%95git/","summary":"删除远程分支 git push origin --del rzluan-orderchange/ndc_xml_api_v3\n克隆指定分支到指定文件夹 git clone -b [branch_name] [git_url] [dir_path]\n变更统计 git log --author=rzluan --after=\u0026#34;2019-11-01 00:00:00\u0026#34; --before=\u0026#34;2019-11-30 23:59:59\u0026#34; --name-only | grep \u0026#39;^src/*\u0026#39; | sort | uniq git log --author=rzluan --after=\u0026#34;2019-11-01 00:00:00\u0026#34; --before=\u0026#34;2019-11-30 23:59:59\u0026#34; --numstat | grep \u0026#34;src\u0026#34; | awk \u0026#39;{a[$3]+=$1;b[$3]+=$2}END{for(j in a) print j,\u0026#34;代码变更\u0026#34;(a[j]+b[j])\u0026#34;行\u0026#34;}\u0026#39; git log --author=rzluan --after=\u0026#34;2019-11-01 00:00:00\u0026#34; --before=\u0026#34;2019-11-30 23:59:59\u0026#34; --numstat | grep \u0026#34;src\u0026#34; | awk \u0026#39;{a[$3]+=($1+$2)}END{for(j in a) b+=a[j]} END{print \u0026#34;总行数\u0026#34;,b}\u0026#39; 修改commit记录 修改提交时间：git commit --amend --date=\u0026quot;May 8 12:00:30 2020 +0800\u0026quot;","title":"命令备忘录：Git"},{"content":"Editor Basics Actions Ctrl + Shift + A\nSelect Ctrl + Shift + →\tSelect a word\nCtrl + Shift + ←\tSelect a word\nCtrl + W\tExtend the select\nCtrl + Shift + W\tShrink the select\nCtrl + A Select whole file\nComment Line Ctrl + /\tComment out or uncomment line(s)\nDelete Line Ctrl + Y\tDelete line(s)\nCtrl + Z Restore the deleted line(s)\nDuplicate Ctrl + D Duplicate line(s)\nMove Alt + Shift + ↓\tpull down line(s)\nAlt + Shift + ↑\tpull up line(s)\nCtrl + Shift + ↓\tpull down class member\nCtrl + Shift + ↑\tpull up class member\nCollapse Ctrl + -\tcollapse a region(eg. method)\nCtrl + +\texpand a region\nCtrl + Shift + -\tcollapse all regions\nCtrl + Shfit + +\texpand all regions\nMultiple Selections Alt + J\tSelect the symbol at the caret or select the next occurrence of this symbol\nAlt + Shift + J\tdeselect the last occurrence\nCtrl + Alt + Shfit + J\tselect all occurrence in the file\nCode Completion Basic Completion Ctrl + SpaceKey activate basic completion(replace Enter with tab to overwrite the word rather than simply insert it)\nSmart Type Completion Ctrl + Shift + SpaceKey activate smart type completion\nStatement Completion Ctrl + Shift + Enter\tcomplete the statement\nRefactorings Rename Shift + F6\trename\nExtract Variable/Field Alt + Shift + V\tintroduce local variable or field(you can also use Alt + Enter and select the list item )\nRefactoring Basics Ctrl + Alt + C\textract the selected expression into a constant\nCtrl + Alt + M\textract the selected code block into a method\nCtrl + Alt + P\textract the selected expression into a parameter (not work)\nCode Assistance Code Formatting Alt + Shift + L\tcorrect code formatting\nParameter Info Ctrl + P see the method signature\nQuick Popups Ctrl + Q\tsee documentation for the symbol at the caret(Esc to close the popup)\nCtrl + Shift + I\tsee the definition of the symbol at the caret\nEditor Coding Assistance F2\tgo to the next highlighted error in the file\nCtrl + 1\tsee the error description\nAlt + Enter\tshow suggestions and fix it\nCtrl + Alt + T\tsurround with\nCtrl + Shift + 7\thighlight all usages of the symbol at the caret\nNavigation Jump to source F4\tjump to source(include jdk classes)\nDeclaration/Implementation Ctrl + B\tjump to the declaration of a class or interface\nCtrl + Alt + B\tsee implementations of a class/interface\nFile Structure Ctrl + 0\tsee file structure\nNext/Previous Occurrences Ctrl + F\tfind all word you selected\nF3\tfind next occurrences\nShfit + F3\tfind previous occurrences\n","permalink":"https://blog.luanrz.cn/posts/%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/%E5%91%BD%E4%BB%A4%E5%A4%87%E5%BF%98%E5%BD%95idea/","summary":"Editor Basics Actions Ctrl + Shift + A\nSelect Ctrl + Shift + →\tSelect a word\nCtrl + Shift + ←\tSelect a word\nCtrl + W\tExtend the select\nCtrl + Shift + W\tShrink the select\nCtrl + A Select whole file\nComment Line Ctrl + /\tComment out or uncomment line(s)\nDelete Line Ctrl + Y\tDelete line(s)\nCtrl + Z Restore the deleted line(s)\nDuplicate Ctrl + D Duplicate line(s)","title":"命令备忘录：IDEA"},{"content":"Java序列化 new ObjectOutputStream(new FileOutputStream(\u0026quot;resp\u0026quot;)).writeObject(resp);\n配置VM参数\u0026quot;javaagent\u0026quot;以支持切面编程 - javaagent:/home/luanrzh/.m2/repository/org/aspectj/aspectjweaver/1.9.4/aspectjweaver-1.9.4.jar 启用远程调试 java -jar \\ -Dserver.port=8080 \\ -agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=8081 \\ parent-0.0.1-SNAPSHOT.jar jasypt加密解密 java -cp jasypt-1.9.2.jar org.jasypt.intf.cli.JasyptPBEStringEncryptionCLI input=123456 password=1234-1234-1234-1234 algorithm=PBEWithMD5AndDES java -cp jasypt-1.9.2.jar org.jasypt.intf.cli.JasyptPBEStringDecryptionCLI input=\u0026#34;jvp0W0qUkv0WmG/JzwyUTA==\u0026#34; password=1234-1234-1234-1234 algorithm=PBEWithMD5AndDES ","permalink":"https://blog.luanrz.cn/posts/%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/%E5%91%BD%E4%BB%A4%E5%A4%87%E5%BF%98%E5%BD%95java/","summary":"Java序列化 new ObjectOutputStream(new FileOutputStream(\u0026quot;resp\u0026quot;)).writeObject(resp);\n配置VM参数\u0026quot;javaagent\u0026quot;以支持切面编程 - javaagent:/home/luanrzh/.m2/repository/org/aspectj/aspectjweaver/1.9.4/aspectjweaver-1.9.4.jar 启用远程调试 java -jar \\ -Dserver.port=8080 \\ -agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=8081 \\ parent-0.0.1-SNAPSHOT.jar jasypt加密解密 java -cp jasypt-1.9.2.jar org.jasypt.intf.cli.JasyptPBEStringEncryptionCLI input=123456 password=1234-1234-1234-1234 algorithm=PBEWithMD5AndDES java -cp jasypt-1.9.2.jar org.jasypt.intf.cli.JasyptPBEStringDecryptionCLI input=\u0026#34;jvp0W0qUkv0WmG/JzwyUTA==\u0026#34; password=1234-1234-1234-1234 algorithm=PBEWithMD5AndDES ","title":"命令备忘录：Java"},{"content":"会话管理——使用screen恢复掉线的shell会话 screen -S myScreen\nscreen -r myScreen\n显示当前目录所占用的磁盘空间 du -h --max-depth=1\n访问NFS服务 sudo pacman -S core/nfs-utils #ArchLinux下安装nfs-utils，不然没有showmount命令\nshowmount -e 192.168.1.105 #显示指定IP上挂载的卷\nsudo mount -t nfs -o proto=tcp,nolock 192.168.1.105:/volume1/homes homes/ #开始挂载\n访问SMB服务 sudo pacman -S smbclient #安装\nsmbclient -L 192.168.0.100 -U username%password # 显示共享目录\nsmbclient //192.168.0.100/directory -U username%password # 进入上述共享目录中的directory目录\n一键删除所有项目下的target find . -name target | awk '{print \u0026quot;rm -rf \u0026quot;$1}' | sh\n扫描局域网所有IP与端口 nmap -sP 192.168.1.0/24\nnmap -A 192.168.1.100\n压缩与解压 压缩 解压 tar.gz tar czvf test.tar.gz test/ tar xzvf test.tar.gz tar.xz tar cJvf test.tar.xz test/ tar xvf test.tar.xz zip zip test.zip test/* unzip test.zip rar rar test.rar test/* (un)rar x(e) test.rar ","permalink":"https://blog.luanrz.cn/posts/%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/%E5%91%BD%E4%BB%A4%E5%A4%87%E5%BF%98%E5%BD%95linux/","summary":"会话管理——使用screen恢复掉线的shell会话 screen -S myScreen\nscreen -r myScreen\n显示当前目录所占用的磁盘空间 du -h --max-depth=1\n访问NFS服务 sudo pacman -S core/nfs-utils #ArchLinux下安装nfs-utils，不然没有showmount命令\nshowmount -e 192.168.1.105 #显示指定IP上挂载的卷\nsudo mount -t nfs -o proto=tcp,nolock 192.168.1.105:/volume1/homes homes/ #开始挂载\n访问SMB服务 sudo pacman -S smbclient #安装\nsmbclient -L 192.168.0.100 -U username%password # 显示共享目录\nsmbclient //192.168.0.100/directory -U username%password # 进入上述共享目录中的directory目录\n一键删除所有项目下的target find . -name target | awk '{print \u0026quot;rm -rf \u0026quot;$1}' | sh\n扫描局域网所有IP与端口 nmap -sP 192.168.1.0/24\nnmap -A 192.168.1.100\n压缩与解压 压缩 解压 tar.","title":"命令备忘录：Linux"},{"content":"浏览 ctrl-f 向下一翻页（f = forword ） ctrl-b 向上一翻页（b = backward） ctrl-d 向下翻半页（d = down） ctlr-u 向上翻半页（u = up） ctrl-e 向下滚一行 ctrl-y 向上滚一行 zz 让光标所在的行居屏幕中央 zt 让光标所在的行居屏幕最上一行 t=top zb 让光标所在的行居屏幕最下一行 b=bottom 编辑 u 撤销 Ctrl-r 恢复撤销 替换 命令备忘录：Vim\n:%s/a/b/g 将所有的a替换为b ","permalink":"https://blog.luanrz.cn/posts/%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/%E5%91%BD%E4%BB%A4%E5%A4%87%E5%BF%98%E5%BD%95vim/","summary":"浏览 ctrl-f 向下一翻页（f = forword ） ctrl-b 向上一翻页（b = backward） ctrl-d 向下翻半页（d = down） ctlr-u 向上翻半页（u = up） ctrl-e 向下滚一行 ctrl-y 向上滚一行 zz 让光标所在的行居屏幕中央 zt 让光标所在的行居屏幕最上一行 t=top zb 让光标所在的行居屏幕最下一行 b=bottom 编辑 u 撤销 Ctrl-r 恢复撤销 替换 命令备忘录：Vim\n:%s/a/b/g 将所有的a替换为b ","title":"命令备忘录：Vim"},{"content":"i3wm是Linux下的一款窗口管理器(Windowns Manager), 通常简称为i3。 本文档基于Archlinux(其它发行版大同小异), 简单介绍了i3的常用软件与配置。\n安装 sudo pacman -S i3-gaps polybar rofi feh picom yay i3lock-fancy-rapid 序号 软件 功能 01 i3-gaps i3-wm的增强版，支持间隙等特性 02 polybar 状态栏，i3-bar的替代者 03 rofi 启动菜单，dmenu的替代者 04 feh 设置桌面壁纸 05 picom 透明支持 06 i3lock-fancy-rapid 锁屏，i3lock的升级版，支持背景虚化 配置 配置polybar 生成polybar配置文件 mkdir ~/.config/polybar cp /usr/share/doc/polybar/config ~/.config/polybar/ 编辑polybar配置文件 vim ~/.config/polybar/config ------------------------------------------ [bar/example] ... border-size = 0 ... modules-left = i3 modules-center = date modules-right = memory cpu battery wlan eth ... [module/wlan] type = internal/network interface = wlp0s20f3 ... [module/eth] type = internal/network interface = enp0s31f6 ... ------------------------------------------ 新建polybar启动文件 vim ~/.config/polybar/launch.sh killall -q polybar while pgrep -u $UID -x polybar \u0026gt;/dev/null; do sleep 1; done polybar example chmod +x launch.sh 启用polybar（参见配置i3） vim ~/.config/i3/config exec --no-startup-id ~/.config/polybar/launch.sh 配置rofi 拷贝主题文件 mkdir ~/.config/rofi cp -r /usr/share/rofi/themes ~/.config/rofi 预览主题 rofi-theme-selector 修改rofi配置 rofi -dump-config \u0026gt; ~/.config/rofi/config.rasi vim ~/.config/rofi/config.rasi ------------------------------------------ configuration { ... modi: \u0026#34;window,run,ssh,drun\u0026#34;; show-icons: true; ... } .... ------------------------------------------ 启用rofi（参见配置i3） vim ~/.config/i3/config ## 绑定rofi：drun bindsym --release $mod+space exec --no-startup-id rofi -show drun -theme ~/.config/rofi/themes/arthur.rasi ## 绑定rofi：window bindsym $mod+Tab exec --no-startup-id rofi -show window -theme ~/.config/rofi/themes/sidebar.rasi 配置关停脚本 详情请参考ArchLinux Wiki\nvim ~/i3exit.sh ------------------------------------------ #!/bin/sh lock() { i3lock-fancy-rapid 5 3 } case \u0026#34;$1\u0026#34; in lock) lock ;; logout) i3-msg exit ;; suspend) lock \u0026amp;\u0026amp; systemctl suspend ;; hibernate) lock \u0026amp;\u0026amp; systemctl hibernate ;; reboot) systemctl reboot ;; shutdown) systemctl poweroff ;; *) echo \u0026#34;Usage: $0 {lock|logout|suspend|hibernate|reboot|shutdown}\u0026#34; exit 2 esac exit 0 ------------------------------------------ chmod +x ~/i3exit.sh 配置i3 vim ~/.config/i3/config ------------------------------------------ ## 将mod设置为Alt键 set $mod Mod1 ## 设置标题字体 font pango:monospace 10 # 关闭当前窗口（注释原有映射，与Mac保持一致） #bindsym $mod+Shift+q kill bindsym $mod+q kill ## 关闭底部常驻的i3bar（注释掉bar） #bar { # status_command i3status #} ## 设置窗口边框等等 new_window none new_float normal hide_edge_borders both ## 设置窗口间距 gaps inner 2 gaps outer 2 ## 启动polybar exec --no-startup-id ~/.config/polybar/launch.sh ## 设置背景图片 exec --no-startup-id feh --bg-fill ~/Pictures/156274745324.jpg ## 设置透明 exec --no-startup-id picom -b ## 启动中文输入法支持 exec --no-startup-id fcitx ## Deepin系应用前置处理 exec --no-startup-id /usr/lib/gsd-xsettings \u0026amp; ## 将显示器DP2设置为主屏 exec --no-startup-id xrandr --output DP2 --primary ## 绑定rofi：drun bindsym --release $mod+space exec --no-startup-id rofi -show drun -theme ~/.config/rofi/themes/arthur.rasi ## 绑定rofi：window bindsym $mod+Tab exec --no-startup-id rofi -show window -theme ~/.config/rofi/themes/sidebar.rasi ## 绑定便签本：把当前窗口设为便笺本 bindsym $mod+Shift+minus move scratchpad ## 绑定便签本：呼出第一个便笺本 bindsym $mod+minus scratchpad show ## 绑定锁屏功能 bindsym Mod4+l exec --no-startup-id ~/i3exit.sh lock ------------------------------------------ ","permalink":"https://blog.luanrz.cn/posts/%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/i3wm%E9%85%8D%E7%BD%AE/","summary":"i3wm是Linux下的一款窗口管理器(Windowns Manager), 通常简称为i3。 本文档基于Archlinux(其它发行版大同小异), 简单介绍了i3的常用软件与配置。\n安装 sudo pacman -S i3-gaps polybar rofi feh picom yay i3lock-fancy-rapid 序号 软件 功能 01 i3-gaps i3-wm的增强版，支持间隙等特性 02 polybar 状态栏，i3-bar的替代者 03 rofi 启动菜单，dmenu的替代者 04 feh 设置桌面壁纸 05 picom 透明支持 06 i3lock-fancy-rapid 锁屏，i3lock的升级版，支持背景虚化 配置 配置polybar 生成polybar配置文件 mkdir ~/.config/polybar cp /usr/share/doc/polybar/config ~/.config/polybar/ 编辑polybar配置文件 vim ~/.config/polybar/config ------------------------------------------ [bar/example] ... border-size = 0 ... modules-left = i3 modules-center = date modules-right = memory cpu battery wlan eth ... [module/wlan] type = internal/network interface = wlp0s20f3 .","title":"i3wm配置"},{"content":"通过修改\u0026quot;GRUB界面\u0026quot;,\u0026ldquo;plymouth界面\u0026quot;以及\u0026quot;锁屏登陆界面\u0026rdquo;, 来规避Ubuntu18.04的紫色背景\nGRUB界面 sudo cp pictrue.jpg /boot/grub\ncd /etc/default/\nsudo cp grub grub.bak\nsudo vim grub\nGRUB_GFXMODE=1366x768 sudo update-grub\nplymouth界面 cd /usr/share/plymouth/themes/ubuntu-logo\nsudo cp ubuntu-logo.script ubuntu-logo.script.bak\nsudo vim ubuntu-logo.script\nWindow.SetBackgroundTopColor (0.00, 0.00, 0.00); Window.SetBackgroundBottomColor (0.00, 0.00, 0.00); 锁屏登陆界面 cd /usr/share/gnome-shell/theme/\nsudo cp ubuntu.css ubuntu.css.bak\nsudo vim ubuntu.css\n#lockDialogGroup { background: black; } ","permalink":"https://blog.luanrz.cn/posts/%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/%E9%AA%9A%E6%B0%94%E7%B4%AB%E5%BF%AB%E8%B5%B0%E5%BC%80%E4%BF%AE%E6%94%B9ubuntu18.04%E7%9A%84%E8%83%8C%E6%99%AF%E8%89%B2/","summary":"通过修改\u0026quot;GRUB界面\u0026quot;,\u0026ldquo;plymouth界面\u0026quot;以及\u0026quot;锁屏登陆界面\u0026rdquo;, 来规避Ubuntu18.04的紫色背景\nGRUB界面 sudo cp pictrue.jpg /boot/grub\ncd /etc/default/\nsudo cp grub grub.bak\nsudo vim grub\nGRUB_GFXMODE=1366x768 sudo update-grub\nplymouth界面 cd /usr/share/plymouth/themes/ubuntu-logo\nsudo cp ubuntu-logo.script ubuntu-logo.script.bak\nsudo vim ubuntu-logo.script\nWindow.SetBackgroundTopColor (0.00, 0.00, 0.00); Window.SetBackgroundBottomColor (0.00, 0.00, 0.00); 锁屏登陆界面 cd /usr/share/gnome-shell/theme/\nsudo cp ubuntu.css ubuntu.css.bak\nsudo vim ubuntu.css\n#lockDialogGroup { background: black; } ","title":"骚气紫快走开——修改Ubuntu18.04的背景色"},{"content":"本文介绍了手动下载并安装IDEA插件开发环境依赖的过程, 以解决IDEA插件开发环境过程中下载Gradle包过慢的问题如果你的网络环境可以正常下载依赖包, 本文对你来说是通篇废话, 请忽略.\nIDEA插件开发环境搭建 一、依赖 由于在国下载内Gradle包的速度较慢，部分大文件会因为下载时间过长连接超时导致下载失败。\n在Idea插件项目中，主要会下载以下三个大文件：\nideaIC-2020.1.zip\t（500M左右） ideaIC-2020.1-sources.jar\t（100M左右） jbr-11_0_6-linux-x64-b765.25.tar.gz\t（100M左右） 下面是ideaIC-2020.1.zip依赖的解决过程，其它依赖的解决过程与之类似。\n1. 获取下载链接并手动下载依赖包 在命令行下进入Gradle项目根目录，执行下述命令：\n./gradlew compileDebugSource --stacktrace -info\n在上述日志中找到下载链接，通过迅雷下载。（你也可以直接通过 附录 部分下载）\n2. 获取依赖包的SHA1码 使用sha1sum命令获取文件的SHA1码。\nsha1sum ideaIC-2020.1.zip 执行上述命令后，将得到：\ncbeeb1f1aebd4c9ea8fb5ab990c5904a676fc41a ideaIC-2020.1.zip cbeeb1f1aebd4c9ea8fb5ab990c5904a676fc41a就是ideaIC-2020.1.zip的SHA1码。\n3. 在gradle本地缓存的指定路径下创建SHA1码同名文件夹，将并将依赖包移动至此 进入gradle本地缓存的路径\ncd ~/.gradle/caches/modules-2/files-2.1\n进入ideaIC-2020.1.zip的所在路径\ncd com.jetbrains.intellij.idea/ideaIC/2020.1\n创建SHA1码同名文件夹\nmkdir cbeeb1f1aebd4c9ea8fb5ab990c5904a676fc41a\n移动依赖包\ncp ~/Downloads/ideaIC-2020.1.zip cbeeb1f1aebd4c9ea8fb5ab990c5904a676fc41a\n附：各依赖包的路径 com.jetbrains.intellij.idea/ideaIC/2020.1/xxx/ideaIC-2020.1.zip 下载 com.jetbrains.intellij.idea/ideaIC/2020.1/xxx/ideaIC-2020.1-sources.jar 下载 com.jetbrains/jbre/jbr-11_0_6-linux-x64-b765.25.tar.gz 下载 ","permalink":"https://blog.luanrz.cn/posts/%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/idea%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/","summary":"本文介绍了手动下载并安装IDEA插件开发环境依赖的过程, 以解决IDEA插件开发环境过程中下载Gradle包过慢的问题如果你的网络环境可以正常下载依赖包, 本文对你来说是通篇废话, 请忽略.\nIDEA插件开发环境搭建 一、依赖 由于在国下载内Gradle包的速度较慢，部分大文件会因为下载时间过长连接超时导致下载失败。\n在Idea插件项目中，主要会下载以下三个大文件：\nideaIC-2020.1.zip\t（500M左右） ideaIC-2020.1-sources.jar\t（100M左右） jbr-11_0_6-linux-x64-b765.25.tar.gz\t（100M左右） 下面是ideaIC-2020.1.zip依赖的解决过程，其它依赖的解决过程与之类似。\n1. 获取下载链接并手动下载依赖包 在命令行下进入Gradle项目根目录，执行下述命令：\n./gradlew compileDebugSource --stacktrace -info\n在上述日志中找到下载链接，通过迅雷下载。（你也可以直接通过 附录 部分下载）\n2. 获取依赖包的SHA1码 使用sha1sum命令获取文件的SHA1码。\nsha1sum ideaIC-2020.1.zip 执行上述命令后，将得到：\ncbeeb1f1aebd4c9ea8fb5ab990c5904a676fc41a ideaIC-2020.1.zip cbeeb1f1aebd4c9ea8fb5ab990c5904a676fc41a就是ideaIC-2020.1.zip的SHA1码。\n3. 在gradle本地缓存的指定路径下创建SHA1码同名文件夹，将并将依赖包移动至此 进入gradle本地缓存的路径\ncd ~/.gradle/caches/modules-2/files-2.1\n进入ideaIC-2020.1.zip的所在路径\ncd com.jetbrains.intellij.idea/ideaIC/2020.1\n创建SHA1码同名文件夹\nmkdir cbeeb1f1aebd4c9ea8fb5ab990c5904a676fc41a\n移动依赖包\ncp ~/Downloads/ideaIC-2020.1.zip cbeeb1f1aebd4c9ea8fb5ab990c5904a676fc41a\n附：各依赖包的路径 com.jetbrains.intellij.idea/ideaIC/2020.1/xxx/ideaIC-2020.1.zip 下载 com.jetbrains.intellij.idea/ideaIC/2020.1/xxx/ideaIC-2020.1-sources.jar 下载 com.jetbrains/jbre/jbr-11_0_6-linux-x64-b765.25.tar.gz 下载 ","title":"IDEA插件开发环境搭建"},{"content":"官方OpenJdk8u构建指南个人翻译版本。官方地址为README-builds.html\n介绍 这个README文件包含了OpenJDK的构建说明。构建OpenJDK的源码需要一定的专业技术知识。\n!!!!!!!!!!!!!!! 这是对这份文档的一次重大改写!!!!!!!!!!!!!!!\n概述如下：\n当前构建方式是“configure \u0026amp;\u0026amp; make” GNU make的版本应当大于或等于3.81 构建是可伸缩的，比如：可以使用更多的处理器来完成构建过程，以减少构建时间 嵌套与递归的make调用已经明显减少，fork/exec 与子进程生成的总量也相应减少 不再支持 Windows MKS Windows Vistual Studio 的 vsvars*.bat 和 vcvars*.bat 等文件会自动运行 构建OpenJDK时，不再使用Ant 不再支持在配置构建过程时使用 ALT_* 环境变量 目录 介绍\n使用Mercurial\n获取源码 仓库结构 源码规范 构建\n系统设置 Linux Solaris MacOSX Windows Configure Make 测试\n附录A：提示和技巧\n常见问题解答 构建性能技巧 故障排查 附录B：GNU-Make信息\n附录C：构建环境\n使用Mercurial OpenJDK源码由版本控制系统 Mercurial 维护，如果你还不熟悉 Mercurial ，请参阅 Beginner Guides 或参考 Mercurial Book 。本书的前几章对“Mercurial是什么“以及“Mercurial如何工作”进行了出色的概述。\n获取源码 执行主仓库下的 `get_source.sh 命令，获取 OpenJDK Mercurial 仓库的全部内容。\nhg clone http://hg.openjdk.java.net/jdk8/jdk8 YourOpenJDK cd YourOpenJDK bash ./get_source.sh 当你拥有了所有的仓库之后，请记住，每个的仓库都是独立的。你也可以重新执行./get_source.sh，随时拉取所有仓库的最新变更集。这些内嵌的仓库被称作“forest”（树形结构），有多种方法可以为每个仓库执行相同的hg命令。例如，make/scripts/hgforest.sh脚本就可以为每个仓库执行相同的hg命令，如下：\ncd YourOpenJDK bash ./make/scripts/hgforest.sh status 仓库结构 仓库及其内容概述\n仓库 内容概述 .(root) 通用配置与 makefile 逻辑 hotspot 构建 OpenJDK Hotspot 虚拟机所需的源代码和 make 文件 langtools OpenJDK javac 和 language tools 的源代码 jdk 构建OpenJDK运行时库与其它文件所需的的源代码和 make 文件 jaxp OpenJDK JAXP 功能的源代码 jaxws OpenJDK JAX-WS 功能的源代码 corba OpenJDK Corba 功能的源代码 nashorn OpenJDK JavaScript 功能的源代码 源码规范 一些基本的规范：\n源文件中空格的使用是受限制的：不能有制表符、行末不能有空格、文件不能以一个以上的空行结束（源文件包括.java， .c， .h， .cpp， 和 .hpp 文件） 不应该将具有可执行权限的文件添加到源仓库中去 所有生成的文件需要与源代码控制系统所维护管理的文件保持隔离，生成的文件应当存放在顶层的 build/ 目录下 默认的构建过程应该构建 product ，而不是其它。可供构建的选项如下：product（优化版本）、debug（未优化版本，附带-g的断言逻辑）、fastdebug（优化版本，附带-g的断言逻辑） 每个仓库必须存在.hgignore 文件，它必须包含 build/、dist/，可以包含nbproject/private等类似的文件夹，不能包含仓库中的 src/ 、 test/ 及其它在仓库管理范围内的任何内容 目录名和文件名不应该包含空格或非打印字符 生成的文件或二进制文件不应该添加到仓库中（包括 javah 输出）。对于这条规则有一些特例，特别是一些生成的 configure 脚本 不应该将不需要用于构建或测试的文件添加到仓库 构建 构建OpenJDK的第一步是确保系统本身已经拥有了构建OpenJDK所需要的一切。一旦系统设置完成，通常就不再需要执行这一步了。\n构建OpenJDK现在可以通过运行一个 configure 脚本来完成，这个脚本会尝试查找并验证你是否已经拥有所需的一切，然后运行 make 命令，如下所示：\nbash ./configure make all 在可能的情况下， configure 文件会尝试在默认位置或组件指定的变量设置中来定位不同的组件，当正常的缺省设置失效或无法找到组件时，可能需要额外的 configure 选项来帮助 configure 找到构建所需的工具，如果构建过程中提示缺失软件包，你可能需要在安装指定软件包之后重新执行构建操作。\n注意：configure 脚本文件没有执行权限，需要使用 bash 命令显式地运行它，请参看源码规范\n系统设置 在尝试使用操作系统去构建 OpenJDK 之前，需要进行一些非常基本的系统设置。对所有操作系统来说：\n请确保 GNU make 工具的版本大于或等于3.8.1，执行\u0026quot;make -version\u0026ldquo;来查看make的版本\n安装一个引导 JDK。所有的 OpenJDK 构建都需要访问一个先前发布的 JDK ，这个 JDK 叫作 bootstrap JDK 或者 boot JDK 。一般的规则是，这个引导 JDK 必须是 JDK 上一个主要版本的实例。此外，可能需要使用一个特定的 update 级别或更高级别的引导 JDK来完成构建操作。\n构建 JDK8 需要使用 Update7 或以上版本的 JDK7， JDK8 的开发者不应该把 JDK8 当作引导 JDK ， 以确保由 JDK7 所构建的系统部分不会引入 JDK8 的依赖\nJDK7 二进制文件可以在 Oracle的 JDK 7 下载站点 下载。构建过程中，引导 JDK 能够正常访问是非常重要的，你应该将引导 JDK 的 bin 路径添加到 PATH 环境变量中去。如果 configure 找不到这个引导 JDK ，你可能需要使用 configure 选项 --with-boot-jdk 来指定它的位置\n确保 GNU make、引导 JDK 和编译器都位于你的 PATH 环境变量中\n针对特定系统： （仅翻译了Linux，Sloaris、Windows、Mac OS X 都没有翻译）\nLinux 安装所有需要的软件开发包，包括alsa、freetype、cups和xrender\n使用 Linux 时，尽量使用系统包，而不是自己构建或从其他地方获取。大多数Linux都可以使用系统包。\n注意，有些 Linux 系统有预先设置环境变量的习惯，例如，在Linux 系统中安装完 JDK 后， JAVA_HOME 可能会预先定义到你的环境变量中。你可能需要 unset JAVA_HOME。建议运行 env 命令，并验证你从系统默认设置中获取的环境变量对于构建 OpenJDK 是否有意义。\nConfigure configure 脚本的基本调用方法如下：\nbash ./configure [options] 上述操作将会创建一个含有 \u0026ldquo;configuration\u0026rdquo; 的输出目录，并为构建结果设置一个子目录，构建结果目录一般看起来像：\nbuild/linux-x64-normal-server-release configure 会计算出你正在哪个系统上运行，以及全部所需构建组件位于何处。如果你已经安装了构建所需的所有先决条件，它就会找到所有内容。如果不能自动检测到任何组件，它就会退出并告诉你问题所在。发生这种情况时，请阅读下面的配置选项中的更多内容。\n一些例子：\n描述 Configure 命令 含有指定freetype的32位版本 bash ./configure --with-freetype=/cygdrive/c/freetype-i586 --with-target-bits=32 fastdebug级别的64位版本 bash ./configure --enable-debug --with-target-bits=64 配置选项 OpenJDK configure 选项的完整细节可以通过以下命令获取：\nbash ./configure --help=short 使用 -help 能看到所有可用的 configure 选项，你可以生成任意数量的不同配置，如debug、release、32、64等等。一些比较常用的 configure 选项如下：\nConfigure 选项 描述 \u0026ndash;enable-debug 设置debug级别为fastdebug （这是--with-debug-level=fastdebug的简写）。 \u0026ndash;with-alsa=path 设置ALSA（Linux声音驱动程序）的位置。在Linux中，需要使用大于或等于0.9.1版本的 ALSA 文件来构建OpenJDK.。这些 Linux 文件通常可以从“libasound”开发包的“alsa”中获得，强烈建议使用由当前Linux发行版所提供的软件包。 \u0026ndash;with-boot-jdk=path 选择引导 JDK。 \u0026ndash;with-boot-jdk-jvmargs=\u0026ldquo;args\u0026rdquo; 提供用于运行引导JDK的JVM选项。 \u0026ndash;with-cacerts=path 选择cacerts文件的路径。 参看 证书颁发机构 以更好地理解证书授权概念。“cacerts”文件表示CA证书的全局密钥库，在JDK和JRE二进制包中，“cacerts”文件包含来自几个公共CA的根CA证书(公共CA包括VeriSign、Thawte和Baltimore等)。源文件包含了一个没有CA根证书的cacerts文件。正式构建时需要获得每个公共CA的许可，并将证书包含到它们自己的自定义cacerts文件中。如果cacerts文件没有正确包含公共CA的许可，将导致运行时证书链的验证异常。默认情况下，会提供一个空的cacerts文件，这对大多数JDK开发人员来说应该没有问题。 \u0026ndash;with-cups=path 选择CUPS安装路径在Solaris和Linux上构建OpenJDK需要CUPS(UNIX通用打印系统)头文件。Solaris中，可以通过安装Solaris Software Companion的CD/DVD中的SFWcups软件包来获得头文件，这些头文件通常会安装到目录/opt/sfw/cups中。CUPS头文件可以从www.cups.org下载。 \u0026ndash;with-cups-include=path 选择CUPS头文件路径。 \u0026ndash;with-debug-level=level 选择调试信息信息级别，包括release、fastdebug及slowdebug。 \u0026ndash;with-dev-kit=path 选择编译与开发工具的路径。 \u0026ndash;with-freetype=path 选择要使用的freetype文件。预期在lib/目录下有freetype的库文件，在include/目录下有freetype的头文件。 freetype的版本需要大于或等于2.3。在Unix系统上，所需的文件可能已经内置了，但你仍然可能需要升级它们。注意，freetype必须是同时包含库文件和头文件的开发版本。你可以从FreeType 站点下载最新的FreeType从头开始构建freetype 2库也是可以的，但是在Windows上构建可能需要参考Windows freetype DLL构建说明注意，在默认情况下，由于许可限制原因，FreeType构建时禁用了字节码提示支持。在这种情况下，文字的外观与大小将与Sun的JDK官方版本有所差异。有关更多信息，请参见SourceForge FreeType2主页。 \u0026ndash;with-import-hotspot=path 选择以前版本的hotspot二进制文件的位置，以避免构建hotspot。 \u0026ndash;with-target-bits=arg 选择构建位数，包括32与64。 \u0026ndash;with-jvm-variants=variants 选择要构建的JVM变体，包括server, client, kernel, zero 和 zeroshark，多个选项用逗号分割。 \u0026ndash;with-memory-size=size 选择 GNU make 可运用的 RAM 上限。 \u0026ndash;with-msvcr-dll=path 选择msvcr100.dll文件的位置， 这个文件是 Visual Studio的C/C++运行时库，在使用Windows构建时会用到。这个文件通常是从Visual Studio 2010的redist目录中自动获得的。 \u0026ndash;with-num-cores=cores 选择要使用的内核数量（处理器数量或CPU数量）。 \u0026ndash;with-x=path 选择X11和xrender文件的路径。在Solaris和Linux上构建OpenJDK时需要使用XRender的扩展头文件，Linux头文件通常可以从\u0026quot;Xrender\u0026quot;开发包中获得，建议使用由当前Linux发行版所提供的软件包。Solaris的XRender头文件和和其它X11头文件在新版本的Solaris的SFWxwinc包中，它们位于/usr/X11/include/X11/extensions/Xrender.h或/usr/openwin/share/include/X11/extensions/Xrender.h。 Make make 的基本调用方法如下：\nmake all 执行这个命令将会在构建结果目录下开始构建，构建结果目录由configure脚本生成\n运行make help可以获取更多支持的target信息\n以下是一些大家普遍感兴趣的target:\ntarget 描述 空 构建所有内容，但不包括镜像 all 构建所有内容，且包括镜像 all-conf 构建所有配置 images 构建完整的j2sdk和j2re镜像 install 将生成的镜像安装到本地，安装路径一般是/usr/local clean 删除所有由make生成的文件，不包括由configure生成的文件 dist-clean 删除所有由make和configure生成的文件（基本上是重置配置） help 提供一些make命令的帮助，包含了一些常用的target 测试 构建完成之后，你应该可以在输出目录的j2sdk-image子目录下看到生成的二进制文件和其它相关联的文件。特别是，build/*/images/j2sdk-image/bin目录应该包含了当前配置的OpenJDK工具的可执行文件。\n如果需要测试工具jtreg的话，你可以参见jtreg站点。仓库中提供的回归测试可以使用以下命令运行：\ncd test \u0026amp;\u0026amp; make PRODUCT_HOME=`pwd`/../build/*/images/j2sdk-image all 附录A：提示和技巧 常见问题解答 构建性能技巧 故障排查 附录B：GNU-Make信息 附录C：构建环境 ","permalink":"https://blog.luanrz.cn/posts/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/openjdk8u%E6%9E%84%E5%BB%BA%E6%8C%87%E5%8D%97/","summary":"官方OpenJdk8u构建指南个人翻译版本。官方地址为README-builds.html\n介绍 这个README文件包含了OpenJDK的构建说明。构建OpenJDK的源码需要一定的专业技术知识。\n!!!!!!!!!!!!!!! 这是对这份文档的一次重大改写!!!!!!!!!!!!!!!\n概述如下：\n当前构建方式是“configure \u0026amp;\u0026amp; make” GNU make的版本应当大于或等于3.81 构建是可伸缩的，比如：可以使用更多的处理器来完成构建过程，以减少构建时间 嵌套与递归的make调用已经明显减少，fork/exec 与子进程生成的总量也相应减少 不再支持 Windows MKS Windows Vistual Studio 的 vsvars*.bat 和 vcvars*.bat 等文件会自动运行 构建OpenJDK时，不再使用Ant 不再支持在配置构建过程时使用 ALT_* 环境变量 目录 介绍\n使用Mercurial\n获取源码 仓库结构 源码规范 构建\n系统设置 Linux Solaris MacOSX Windows Configure Make 测试\n附录A：提示和技巧\n常见问题解答 构建性能技巧 故障排查 附录B：GNU-Make信息\n附录C：构建环境\n使用Mercurial OpenJDK源码由版本控制系统 Mercurial 维护，如果你还不熟悉 Mercurial ，请参阅 Beginner Guides 或参考 Mercurial Book 。本书的前几章对“Mercurial是什么“以及“Mercurial如何工作”进行了出色的概述。\n获取源码 执行主仓库下的 `get_source.sh 命令，获取 OpenJDK Mercurial 仓库的全部内容。\nhg clone http://hg.","title":"OpenJDK8u构建指南"},{"content":"Termux是Android下的一款Linux环境, 本文简要介绍了Termux的部分实用配置\nTermux初始配置 允许外部存储 termux-setup-storage\n修改termux镜像源 export EDITOR=vi \u0026amp;\u0026amp; apt edit-sources\n----------------------------------------------------------- http://mirrors.tuna.tsinghua.edu.cn/termux ----------------------------------------------------------- apt update \u0026amp;\u0026amp; upgrade\n安装ubuntu 下载 ubuntu pkg install wget \u0026amp;\u0026amp; wget https://raw.githubusercontent.com/Neo-Oli/termux-ubuntu/master/ubuntu.sh \u0026amp; bash ubuntu.sh\n修改dns vi ~/ubuntu-fs/etc/resolv.conf\n-------------------------------------- nameserver 114.114.114.114 -------------------------------------- 修改ubuntu镜像源 vi ~/ubuntu-fs/etc/apt/source.list\n-------------------------------------------------------------------------------------------------- # 默认注释了源码仓库，如有需要可自行取消注释 deb https://mirrors.ustc.edu.cn/ubuntu-ports/ xenial main restricted universe multiverse # deb-src https://mirrors.ustc.edu.cn/ubuntu-ports/ xenial main main restricted universe multiverse deb https://mirrors.ustc.edu.cn/ubuntu-ports/ xenial-updates main restricted universe multiverse # deb-src https://mirrors.ustc.edu.cn/ubuntu-ports/ xenial-updates main restricted universe multiverse deb https://mirrors.ustc.edu.cn/ubuntu-ports/ xenial-backports main restricted universe multiverse # deb-src https://mirrors.ustc.edu.cn/ubuntu-ports/ xenial-backports main restricted universe multiverse deb https://mirrors.ustc.edu.cn/ubuntu-ports/ xenial-security main restricted universe multiverse # deb-src https://mirrors.ustc.edu.cn/ubuntu-ports/ xenial-security main restricted universe multiverse -------------------------------------------------------------------------------------------------- 启动ubuntu ~/start-ubuntu.sh\napt update \u0026amp;\u0026amp; upgrade\n","permalink":"https://blog.luanrz.cn/posts/%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/termux%E9%85%8D%E7%BD%AE/","summary":"Termux是Android下的一款Linux环境, 本文简要介绍了Termux的部分实用配置\nTermux初始配置 允许外部存储 termux-setup-storage\n修改termux镜像源 export EDITOR=vi \u0026amp;\u0026amp; apt edit-sources\n----------------------------------------------------------- http://mirrors.tuna.tsinghua.edu.cn/termux ----------------------------------------------------------- apt update \u0026amp;\u0026amp; upgrade\n安装ubuntu 下载 ubuntu pkg install wget \u0026amp;\u0026amp; wget https://raw.githubusercontent.com/Neo-Oli/termux-ubuntu/master/ubuntu.sh \u0026amp; bash ubuntu.sh\n修改dns vi ~/ubuntu-fs/etc/resolv.conf\n-------------------------------------- nameserver 114.114.114.114 -------------------------------------- 修改ubuntu镜像源 vi ~/ubuntu-fs/etc/apt/source.list\n-------------------------------------------------------------------------------------------------- # 默认注释了源码仓库，如有需要可自行取消注释 deb https://mirrors.ustc.edu.cn/ubuntu-ports/ xenial main restricted universe multiverse # deb-src https://mirrors.ustc.edu.cn/ubuntu-ports/ xenial main main restricted universe multiverse deb https://mirrors.ustc.edu.cn/ubuntu-ports/ xenial-updates main restricted universe multiverse # deb-src https://mirrors.ustc.edu.cn/ubuntu-ports/ xenial-updates main restricted universe multiverse deb https://mirrors.","title":"Termux配置"},{"content":"ArchLinux安装第二部分, 包括图形化界面与实用软件的安装及实用配置。本文档参考自ArchLinux官方Wiki的General recommendations。\n四、后续安装 安装图形化界面 pacman -S xf86-video-intel\t（安装显卡驱动）\npacman -S xorg xfce4 xfce4-goodies sddm\t（安装桌面桌面环境与桌面管理器）\npacman -S network-manager-applet\t(安装NetworkManager插件)\nsystemctl enable sddm\t（开机自动启动sddm）\nsystemctl enable NetworkManager\t（开机自动启动NetworkManager）\nsystemctl disable netctl\t（取消开机自动启动netctl）\nnetctl和networkmanager互斥！\n新建用户并赋予其sudo权限 useradd -m -G wheel luanrzh\t（创建用户luanrzh）\npasswd luanrzh\t（修改luanrzh密码）\npacman -S sudo（安装sudo）\nvim /etc/sudoers\t（配置sudo）\n创建交换文件 fallocate -l 4G /swapfile\nchmod 600 /swapfile\nmkswap /swapfile\nswapon /swapfile\nvim /etc/fstab\n安装yaourt vim /etc/pacman.conf\n------------------------------ [archlinuxcn] SigLevel = Optional TrustAll Server = http://repo.archlinuxcn.org/$arch ------------------------------ pacman -Syu yaourt\n安装中文环境 pacman -S noto-fonts-cjk\t（谷歌出品的noto字体，大而全）\n//pacman -S wqy-microhei\t（文泉驿微米黑字体，小而精，只支持中文）\n字体文件夹：/usr/share/fonts/（全局） ~/.fonts（用户，已过时）\npacman -S fcitx-sogoupinyin fcitx-im fcitx-configtool\t（fcitx输入法）\nvim .xprofile\t（配置fcitx输入法）\n------------------------------ export XMODIFIERS=@im=fcitx export QT_IM_MODULE=fcitx export GTK_IM_MODULE=fcitx ------------------------------ 安装实用软件 yaourt google-chrome（谷歌浏览器）\nyaourt nutstore\t（坚果云）\nyaourt wps-office\t（WPS Ofiice）\n字体问题：安装完WPS后坚果云的界面字体变得贼丑，原因是wps新增的字体优先级高于原先的默认字体。 调整字体优先级\nyaourt netease-cloud-music\t(网易云音乐)\nyaourt visual-studi-code （VS Code）\nyaourt android-studio\t（Android Studio）\nyaourt Moeditor\t（一款markdown编辑器）\npacman -S yakuake guake\t（两款终端模拟器，可配合快捷键实现快速下拉）\npacman -S virtualbox\t(virtualbox虚拟机)\npacman -S linux-headers\t（不安装这个virtualbox虚拟机可能会报错）\npacman -S baobab（gnome中的磁盘使用情况分析工具）\npacman -S filezilla（ftp客户端）\npacman -S remmina（远程桌面连接工具）\nyaourt remmina-plugin-rdesktop\t（remmina RDP插件）\npacman -S File-Roller XArchive（两款解压缩工具）\npacman -S alacarte\t(应用程序主菜单编辑软件)\npacman -S nmap\t(局域网扫描工具)\nyaourt wechat_web_devtools\t(微信开发者工具)\npacman -S dia umbrello\t(两款UML绘图工具)\npacman -S gimp\t(画图软件,PS替代品)\npacman -S kolourpaint\t(另一款画图软件)\nyaourt eclim\t（Vim下的Eclipse,并没有省内存,没卵用）\nyaourt i-nex\t(系统信息查看软件)\nyaourt dbeaver\t（数据库客户端）\nyaourt calibre\t（电子书）\n界面美化 yaourt papirus-icon-theme（图标）\nyaourt numix-icon-theme（图标）\nyaourt numix-circle-icon-theme（圆形图标）\nyaourt arc-gtk-theme（样式，主题）\npacman -S docky（底部出现横杠，点击设置-\u0026gt;窗口管理器微调-\u0026gt;合成器，取消“在dock窗口下显示阴影”）\n使用MTP协议与Android手机传输数据 yaourt mtpfs（MTP支持）\ngvfs-mtp （GNOME Files文件管理器集成）\nvim/etc/fuse.conf mtpfs -o allow_other ~/mnt\n安装deepin下的国产windows软件 vim /etc/pacman.conf （开启multilib库，去掉#注释）\n------------------------------ [multilib] Include = /etc/pacman.d/mirrorlist ------------------------------ yaourt -Sy deepin.com.qq.im\t（QQ）\nyaourt -Sy deepin.com.qq.office\t（Tim）\nyaourt -Sy deepin.com.thunderspeed （迅雷）\nyaourt -Sy deepin-wine-thunderspeed\t（迅雷备选方案）\nyaourt -Sy deepin-baidu-pan\t（百度云）\n安装LAMP apache与php pacman -S php-apache\t（安装apache、php、php扩展:libphp）\nmousepad /etc/httpd/conf/httpd.conf\t（配置apache——php扩展）\n参见 Archlinux wiki\n------------------------------ #LoadModule mpm_event_module modules/mod_mpm_event.so（注释） LoadModule mpm_prefork_module modules/mod_mpm_prefork.so （去掉注释） . LoadModule php7_module modules/libphp7.so AddHandler php7-script php\t（将这一行放在LoadModule 的末尾） . Include conf/extra/php7_module.conf\t（将这一行放到Include列表的末尾） ------------------------------ 使用命令：“php -S localhost:8000 -t public_html/ ”可以独立运行PHP\nmysql pacman -S mariadb\t（安装mysql数据库）\nmysql_install_db --user=mysql --basedir=/usr --datadir=/var/lib/mysql\t（mysql目录配置）\nsystemctl start mysqld\t（启动数据库）\nmysql_secure_installation\t（mysql安全配置）\npacman -S dbeaver\t（安装数据库管理工具）\nphpmyadmin pacman -S phpmyadmin\t（安装phpmyadmin）\nmousepad /etc/httpd/conf/extra/phpmyadmin.conf\t（创建Apache配置文件）\n------------------------------ Alias /phpmyadmin \u0026#34;/usr/share/webapps/phpMyAdmin\u0026#34; \u0026lt;Directory \u0026#34;/usr/share/webapps/phpMyAdmin\u0026#34;\u0026gt; DirectoryIndex index.php AllowOverride All Options FollowSymlinks Require all granted \u0026lt;/Directory\u0026gt; ------------------------------ mousepad /etc/httpd/conf/httpd.conf\t（将上个文件的引用加入到httpd.conf）\n------------------------------ # phpMyAdmin configuration Include conf/extra/phpmyadmin.conf（将这一行放到Include列表的末尾） ------------------------------ //mousepad /etc/webapps/phpmyadmin/config.inc.php\t（配置phpmyadmin）\nmousepad /etc/php/php.ini（配置mysqli 扩展）\n------------------------------ extension=mysqli（去掉;注释） ------------------------------\t不执行上述操作的话，在进入phpmyadmin时会显示\u0026quot;缺少 mysqli 扩展“\n安装LNMP 参见Arch Linux服务器安装LNMP (Nginx, MariaDB, PHP7)\n五、后续配置 设置声卡（解决网易云音乐没有声音的问题） pacman -S alsa-utils\nalsamixer\nF6\t（切换至HDA Intel PCH，将Master调到100）\nvim ~/.asoundrc\t（设置用户级默认声卡，系统级修改/etc/asound.conf ）\n------------------------------ pcm.!default { type hw card PCH } ctl.!default { type hw card PCH } ------------------------------ 设置开机不输入密码直接进入界面 sudo vim /etc/sddm.conf\n------------------------------ [Autologin] User=luanrzh Session=xfce ------------------------------ 取消延迟启动grub sudo vim /boot/grub/grub.cfg\n------------------------------ set timeout=0\t（将5改为0） ------------------------------ 解决TIM(QQ)无法接受图片的问题 sudo vim /etc/sysctl.conf\n------------------------------ #disable ipv6 net.ipv6.conf.all.disable_ipv6 = 1 net.ipv6.conf.\u0026lt;enp9s0\u0026gt;.disable_ipv6 = 1 net.ipv6.conf.\u0026lt;lo\u0026gt;.disable_ipv6 = 1 ------------------------------ sudo sysctl -p\nrm rf ~/.deepinwine/Deepin-TIM/\n关闭蜂鸣器beep 临时关闭 sudo rmmod pcspkr\n永久关闭 sudo vim /etc/modprobe.d/nobeep.conf\n-------------------- blacklist pcspkr -------------------- 设置锁屏 安装i3lock yay i3lock-fancy-rapid-git\n让xflock4调用i3lock xfconf-query -c xfce4-session -p /general/LockCommand -s \u0026quot;i3lock-fancy-rapid 5 3\u0026quot; --create -t string\n","permalink":"https://blog.luanrz.cn/posts/%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/archlinux%E5%AE%89%E8%A3%85%E4%BA%8C/","summary":"ArchLinux安装第二部分, 包括图形化界面与实用软件的安装及实用配置。本文档参考自ArchLinux官方Wiki的General recommendations。\n四、后续安装 安装图形化界面 pacman -S xf86-video-intel\t（安装显卡驱动）\npacman -S xorg xfce4 xfce4-goodies sddm\t（安装桌面桌面环境与桌面管理器）\npacman -S network-manager-applet\t(安装NetworkManager插件)\nsystemctl enable sddm\t（开机自动启动sddm）\nsystemctl enable NetworkManager\t（开机自动启动NetworkManager）\nsystemctl disable netctl\t（取消开机自动启动netctl）\nnetctl和networkmanager互斥！\n新建用户并赋予其sudo权限 useradd -m -G wheel luanrzh\t（创建用户luanrzh）\npasswd luanrzh\t（修改luanrzh密码）\npacman -S sudo（安装sudo）\nvim /etc/sudoers\t（配置sudo）\n创建交换文件 fallocate -l 4G /swapfile\nchmod 600 /swapfile\nmkswap /swapfile\nswapon /swapfile\nvim /etc/fstab\n安装yaourt vim /etc/pacman.conf\n------------------------------ [archlinuxcn] SigLevel = Optional TrustAll Server = http://repo.","title":"ArchLinux安装（二）"},{"content":"ArchLinux安装第一部分, 只包含基础环境的安装, 不包括桌面环境。本文档参考自ArchLinux官方Wiki的Installation guide。\n一、硬盘分区 创建引导分区和根分区 fdisk /dev/sda\t（进入第一个硬盘）\ng\t（如果是全新硬盘，使用g创建新的gpt分区表）\nn\t回车\t回车\t+500M\t（创建新的分区作为引导分区，大小为500M）\nt\t1\t（修改分区类型为EFI System）\nn\t回车\t回车\t+10G\t（创建新的分区作为根分区，大小为10G）\np\t（打印所有更改）\nw\t（保存所有更改）\n格式化分区 mkfs.fat -F32 /dev/sda1\t（格式化引导分区）\nmkfs.ext4 /dev/sda2\t（格式化根分区）\n挂载分区 mount /dev/sda2 /mnt\t（挂载根分区到airrootfs下的mnt目录）\nmkdir /mnt/boot\t（在airrootfs下的mnt目录创建boot子目录）\nmount /dev/sda2 /mnt/boot\t（挂载引导分区到airrootfs下的mnt/boot目录）\n（注意！！！chroot之前，所有的操作均是在内存中进行，airrootfs挂载为系统根目录，chroot在后面有介绍）\n二、联网安装 联网 wifi-menu\t（使用无线局域网）\ndhcp\t（使用自动拨号）\n（注意！使用手机开热点时，电脑可能不能正常解析DNS服务器，需要手动设置。）\nvim /etc/resolv.conf\n-------------------------------------------- nameserver 114.114.114.114） -------------------------------------------- 选择镜像源 vim /etc/pacman.d/mirrolist\t（修改镜像源）\n-------------------------------------------------- Server = http://mirrors.neusoft.edu.cn/archlinux/$repo/os/$arch\t（选择镜像源） -------------------------------------------------- （大多数镜像源格式一致，只需要更改http与archlinux之间的内容即可）\n安装基本包 pacstrap /mnt base base-devel\n三、配置系统 设置分区自动挂载（生成fstab文件） genfstab -L /mnt \u0026gt;\u0026gt; /mnt/etc/fstab\t（自动生成fstab文件，如若按tab未正常补齐，说明前面安装错误）\ncat /mnt/etc/fstab\t（查看fstab文件是否生成成功，若内容不正确，会导致下次无法启动系统！）\n更换根目录挂载点，系统操作权转移（Chroot） arch-chroot /mnt\t（将根目录挂载点由由airrootfs变为/dev/sda2（即airrootfs下的mnt目录））\n（注意！！！chroot之前，大部分操作是在内存中进行，chroot之后，一切操作均在硬盘上进行）\n趁现在有网，将必须的安装包下载下来 pacman -S vim dialog wpa_supplicant\tntfs-3g networkmanager\t（安装vim和网络相关的软件）\npacman -S intel-ucode\t（安装intel相关驱动）\npacman -S os-prober\tgrub efibootmgr（安装引导相关软件）\n设置Locale，主机名，Root密码 vim /etc/locale.gen\t（去掉相关注释）\n-------------------------------------------- en_US.UTF-8 zh_CN.UTF-8 zh_HK.UTF-8 zh_TW.UTF-8 -------------------------------------------- locale-gen\t（使local生效）\nvim /etc/locale.conf\t（编辑本地化文件）\n-------------------------------------------- LANG=en_US.UTF-8\t（设置默认本地本地化标准） -------------------------------------------- echo Archlinux \u0026gt; /etc/hostname\t（设置主机名）\nvim /etc/hosts\t（添加主机名对应信息，非必要）\npasswd\t（设置root密码）\n设置时间 timedatectl set-ntp true\t（更新系统时间）（在前面设置）\nln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime\t（设置时区为上海）\nhwclock --systohc --utc\t（设置时间标准为UTC）\n部署启动文件 grub-install --target=x86_64-efi --efi-directory=/boot --bootloader-id=arch（在引导分区安装grub）\nvim /etc/lvm/lvm.conf\n-------------------------------------------- use_lvmetad = 0（大约在40%处，将1改为0） -------------------------------------------- grub-mkconfig -o /boot/grub/grub.cfg\t（生成grub配置文件）\n重启系统 exit\nreboot\n至此，系统已经安装成功了！图形化界面安装参考“后续安装”\n","permalink":"https://blog.luanrz.cn/posts/%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/archlinux%E5%AE%89%E8%A3%85%E4%B8%80/","summary":"ArchLinux安装第一部分, 只包含基础环境的安装, 不包括桌面环境。本文档参考自ArchLinux官方Wiki的Installation guide。\n一、硬盘分区 创建引导分区和根分区 fdisk /dev/sda\t（进入第一个硬盘）\ng\t（如果是全新硬盘，使用g创建新的gpt分区表）\nn\t回车\t回车\t+500M\t（创建新的分区作为引导分区，大小为500M）\nt\t1\t（修改分区类型为EFI System）\nn\t回车\t回车\t+10G\t（创建新的分区作为根分区，大小为10G）\np\t（打印所有更改）\nw\t（保存所有更改）\n格式化分区 mkfs.fat -F32 /dev/sda1\t（格式化引导分区）\nmkfs.ext4 /dev/sda2\t（格式化根分区）\n挂载分区 mount /dev/sda2 /mnt\t（挂载根分区到airrootfs下的mnt目录）\nmkdir /mnt/boot\t（在airrootfs下的mnt目录创建boot子目录）\nmount /dev/sda2 /mnt/boot\t（挂载引导分区到airrootfs下的mnt/boot目录）\n（注意！！！chroot之前，所有的操作均是在内存中进行，airrootfs挂载为系统根目录，chroot在后面有介绍）\n二、联网安装 联网 wifi-menu\t（使用无线局域网）\ndhcp\t（使用自动拨号）\n（注意！使用手机开热点时，电脑可能不能正常解析DNS服务器，需要手动设置。）\nvim /etc/resolv.conf\n-------------------------------------------- nameserver 114.114.114.114） -------------------------------------------- 选择镜像源 vim /etc/pacman.d/mirrolist\t（修改镜像源）\n-------------------------------------------------- Server = http://mirrors.","title":"ArchLinux安装（一）"},{"content":"前言 文件分为文本文件和非文本文件（二进制文件，如音频、图片文件等），此处讨论的主要是文本文件。\n文件的读写操作基于Java的I/O流，Java流分为字节流与字符流，它们都可以实现文件的读写操作。一般而言，字符流专注于处理文本文件，而字节流则更为通用，所有类型的文件均可操作。基于此，文本文件的读写操作有两种不同的策略：字节流文件读写与字符流文件读写。\n文件流的继承关系 用策略模式组织代码结构 策略模式的核心设计思想是：多种算法相互可替换，每一种算法称之为一种策略。本案例中文本文件的读写操作存在两个策略，即基于字节流的文件读写策略与基于字符流的文件读写策略。\n抽象策略类——待实现功能的接口描述 文本文件的操作主要分为读和写两种，抽象策略类（接口）包含了这两个方法，其规定了其子类（具体策略类）需要实现的具体功能。\nRWStrategy.java\n//抽象策略类 public interface RWStrategy { // 文件操作：读 public String read(File file); // 文件操作：写 public void write(File file, String content); } 具体策略类——待实现功能的具体方案 具体策略类是抽象具体类（接口）的实现。下述代码中，StrategyA表示字节流文件读写策略，StrategyB表示字符流文件读写策略。\nRWStrategyA.java\n//具体策略类 public class RWStrategyA implements RWStrategy { public String read(File file) { String content = \u0026#34;\u0026#34;; try (FileInputStream fis = new FileInputStream(file); BufferedInputStream bis = new BufferedInputStream(fis);) { Long length = file.length(); byte[] bytes = new byte[length.intValue()]; bis.read(bytes); content = new String(bytes); } catch (Exception e) { e.printStackTrace(); } return content; } public void write(File file, String content) { try (FileOutputStream fos = new FileOutputStream(file); BufferedOutputStream bos = new BufferedOutputStream(fos);) { byte[] bytes = content.getBytes(); bos.write(bytes); } catch (Exception e) { e.printStackTrace(); } } // 单例 private static RWStrategyA strategy; public static RWStrategyA newInstance() { if (strategy == null) { strategy = new RWStrategyA(); } return strategy; } private RWStrategyA() { }; } RWStrategyB.java\n//具体策略类 public class RWStrategyB implements RWStrategy { public String read(File file) { String content = \u0026#34;\u0026#34;; try (FileReader fr = new FileReader(file); BufferedReader br = new BufferedReader(fr)) { Long length = file.length(); char[] chars = new char[length.intValue()];// 实际字符数组长度比这个小 br.read(chars); content = new String(chars); } catch (Exception e) { e.printStackTrace(); } return content; } public void write(File file, String content) { try (FileWriter fw = new FileWriter(file); BufferedWriter bw = new BufferedWriter(fw);) { char[] chars = content.toCharArray(); bw.write(chars); //\tbw.write(content); } catch (Exception e) { e.printStackTrace(); } } // 单例 private static RWStrategyB strategy; public static RWStrategyB newInstance() { if (strategy == null) { strategy = new RWStrategyB(); } return strategy; } private RWStrategyB() { }; } 由于具体策略类不需要创建多个对象，故使用到了单例模式。 在具体策略类中使用newInstance()方法获取单例对象，使类的创建与类的使用分离，这样其它类获取当前类的实例时就不需要使用new关键字了。\n环境类 环境类是主类（使用策略的类）与策略类的桥梁。 环境类维护了一个具体策略类，这个具体策略类的选择由构造函数的参数决定。\n构造方法一：直接注入具体策略类对象，这个具体策略类对象由主类创建 构造方法二：根据枚举值自动创建具体策略类对象 构造方法三：默认创建某一个具体策略类 同时，环境类提供了对应的接口方法，该方法将调用具体策略类中的对应方法，这样做的好处是可以隐藏策略类的细节，即使主类不需要知道策略类的具体方法名也能够调用对应的策略方法。\nRWContext.java\n//环境类 public class RWContext { // 策略对象 private RWStrategy strategy; // 构造函数：传入策略对象 public RWContext(RWStrategy strategy) { this.strategy = strategy; } // 构造函数：传入策略枚举值 public RWContext(RWStrategyEnum strategyEnum) { switch (strategyEnum) { case BYTE_STREAM_STRATEG: strategy = RWStrategyA.newInstance(); break; case CHARACTER_STREAM_STRATEGY: strategy = RWStrategyB.newInstance(); break; } } // 构造函数：默认 public RWContext() { strategy = RWStrategyA.newInstance(); } // 策略方法：从文件中读取内容 public String readFromFile(File file) { return strategy.read(file); } // 策略方法：向文件中写入内容 public void writeToFile(File file, String content) { strategy.write(file, content); } } 枚举中有两个值，对应着两种策略，主要用于环境类中选择性创建具体策略类对象。\nRWStrategyEnum.java\npublic enum RWStrategyEnum { BYTE_STREAM_STRATEG, CHARACTER_STREAM_STRATEGY; } 主类 通过主类类来测试两个具体策略类是否正常运行。\nRWMain.java\npublic class RWMain { static File file; static String content; public static void main(String args[]) throws IOException { file = new File(\u0026#34;filerw.txt\u0026#34;); if (!file.exists()) { file.createNewFile(); } runStrategyA(); runStrategyB(); } public static void runStrategyA() { content = new SimpleDateFormat(\u0026#34;yyyy-MM-dd hh:mm:ss \u0026#34;).format(new Date()) + \u0026#34;A\\n\u0026#34;; RWContext context = new RWContext(RWStrategyEnum.BYTE_STREAM_STRATEG); String beforeWrite = context.readFromFile(file); context.writeToFile(file, beforeWrite + content); String afterWrite = context.readFromFile(file); System.out.println(\u0026#34;A策略：\\n写入前：\\n\u0026#34; + beforeWrite + \u0026#34;\\n写入后:\\n\u0026#34; + afterWrite); } public static void runStrategyB() { content = new SimpleDateFormat(\u0026#34;yyyy-MM-dd hh:mm:ss \u0026#34;).format(new Date()) + \u0026#34;B\\n\u0026#34;; RWContext context = new RWContext(RWStrategyEnum.CHARACTER_STREAM_STRATEGY); String beforeWrite = context.readFromFile(file); context.writeToFile(file, beforeWrite + content); String afterWrite = context.readFromFile(file); System.out.println(\u0026#34;B策略：\\n写入前：\\n\u0026#34; + beforeWrite + \u0026#34;写入后:\\n\u0026#34; + afterWrite); } } 总结 字节流可以处理所有文件，字节流只能处理文本文件，同时，字符流的底层实现依赖于字节流。虽然本案例中用到了两种方式对文本文件进行了读写操作，但是术业有专攻，一般更推荐使用字符流的方式处理文本文件。字符输入流的readline()方法可读取一行。\n关于字节流，read()与read(bytes[])分别在什么时候用？\n我的理解是：\n当流中的字节数未知时使用read()，必须使用while(InputStream.read()!=0)一个字节一个字节读。 当流中的字节数已知时使用read(byte[]) ，创建指定长度的字节数组，然后调用InputStream.read(byte[])即可整体读入。 那么问题来了，什么时候字节数已知呢？\n如果是文件流，那字节数组肯定已知，因为可以直接调用File.length获取字节长度。 其它情况统统按字节数未知处理，老老实实一个一个字节读。 over。\n","permalink":"https://blog.luanrz.cn/posts/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/java%E6%96%87%E4%BB%B6%E6%B5%81%E4%B8%8E%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%BB%BC%E5%90%88%E8%BF%90%E7%94%A8%E7%94%A8%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F%E5%AE%8C%E6%88%90%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99%E6%93%8D%E4%BD%9C/","summary":"\u003ch2 id=\"前言\"\u003e前言\u003c/h2\u003e\n\u003cp\u003e文件分为文本文件和非文本文件（二进制文件，如音频、图片文件等），此处讨论的主要是文本文件。\u003c/p\u003e\n\u003cp\u003e文件的读写操作基于Java的I/O流，Java流分为字节流与字符流，它们都可以实现文件的读写操作。一般而言，字符流专注于处理文本文件，而字节流则更为通用，所有类型的文件均可操作。基于此，文本文件的读写操作有两种不同的策略：字节流文件读写与字符流文件读写。\u003c/p\u003e","title":"Java文件流与策略模式的综合运用：用两种方式完成文件读写操作"},{"content":"树莓派配置, 包括常用开发环境及部分实用工具的安装与配置\n安装raspbian系统至SD卡 略\n选择国内仓库源 sudo sed -i \u0026#39;s#://raspbian.raspberrypi.org#s://mirrors.ustc.edu.cn/raspbian#g\u0026#39; /etc/apt/sources.list sudo sed -i \u0026#39;s#://archive.raspberrypi.org/debian#s://mirrors.ustc.edu.cn/archive.raspberrypi.org/debian#g\u0026#39; /etc/apt/sourceslist.d/raspi.list 参见链接树莓派—raspbian软件源（全）\n使用VNC协议无线连接桌面 系统已经默认安装RealVNC,直接启动即可\nvncserver 使用RDP协议无线连接桌面 sudo apt install tightvncserver xrdp 安装tightvncserver将会自动卸载realvnc\n安装phpMyAdmin环境 安装nginx,php-fpm,mairadb\nsudo apt install nginx php-fpm mariadb-server 配置数据库\n安全设置 sudo mysql_secure_installation 登录 mysql -uroot -p 报错，错误信息为：ERROR 1698 (28000): Access denied for user \u0026lsquo;root\u0026rsquo;@\u0026rsquo;localhost\u0026rsquo;\n解决方案：\nsudo mysql -uroot -p update mysql.user set authentication_string=PASSWORD(\u0026#39;root\u0026#39;), plugin=\u0026#39;mysql_native_password\u0026#39; where user=\u0026#39;root\u0026#39;; flush privileges; 配置nginx以支持php\nsudo vim /etc/nginx/sites-available/default ----------------------------------- location / { index index.html index.htm index.php default.html default.htm default.php; } location ~\\.php$ { fastcgi_pass unix:/run/php/php7.3-fpm.sock; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; include fastcgi_params; } ----------------------------------- 配置php以支持mysql\n安装php的mysql扩展 sudo apt install php-mysql 在配置文件中加入php的mysql扩展 sudo vim /etc/php/7.3/fpm/php.ini ----------------------------------- extension=mysqli ;去掉注释 ----------------------------------- 安装phpMyAdmin\ncd ~/Downloads wget https://www.phpmyadmin.net/downloads/phpMyAdmin-latest-all-languages.tar.gz tar zxvf phpMyAdmin-latest-all-languages.tar.gz sudo mv phpMyAdmin-*-all-languages /var/www/html/pma 安装tomcat环境 安装jdk环境\nsudo apt install openjdk-8-jdk 下载tomcat8.5.42并解压至/usr/local/java目录下\ncd ~/Downloads wget https://mirrors.tuna.tsinghua.edu.cn/apache/tomcat/tomcat-8/v8.5.42/bin/apache-tomcat-8.5.42.tar.gz tar zxf apache-tomcat-8.5.42.tar.gz sudo mkdir /usr/local/java sudo mv apache-tomcat-8.5.42 /usr/local/java/tomcat 设置开机自启动tomcat\nsudo vim /etc/rc.local ----------------------------------- /usr/local/java/tomcat/bin/startup.sh # 在exit 0前加入tomcat启动文件 ----------------------------------- 配置无线静态IP 编辑dhcpcd.conf文件\nsudo vim /etc/dhcpcd.conf ----------------------------------- interface wlan0 static ip_address=192.168.0.200/24 static routers=192.168.0.1 static domain_name_server=114.114.114.114 ----------------------------------- 安装花生壳实现内网穿透 下载安装花生壳\ncd ~/Downloads wget http://download.oray.com/peanuthull/embed/phddns_3.0.3_systemd.deb sudo dpkg -i phddns_3.0.3_systemd.deb 安装ftp服务器实现文件共享 安装vsftp\nsudo apt install vsftpd 配置vsftp\nsudo vim /etc/vsftpd.conf ----------------------------------- write_enable=YES local_umask=022 ----------------------------------- 挂载移动硬盘\nsudo mount -o uid=pi,gid=pi /dev/sda1 ~/Public 开机后自动推送IP至邮箱 安装邮件客户端\nsudo apt install msmtp mutt 配置msmtp\nvim .msmtprc ----------------------------------- account default host smtp.qq.com from luanrzh@qq.com auth plain user luanrzh@qq.com password mfnamealwuktbabi logfile /var/log/msmtp.log ----------------------------------- .msmtprc初始权限会报错：msmtp: /home/pi/.msmtprc: contains secrets and therefore must have no more than user read/write permissions\n修改.msmtprc文件权限\nchmod 600 .msmtprc 配置mutt\nvim .muttrc ----------------------------------- set sendmail=\u0026#34;/usr/bin/msmtp\u0026#34; set use_from=yes set from=\u0026#34;luanrzh@qq.com\u0026#34; set realname=\u0026#34;pi\u0026#34; set editor=\u0026#34;vim\u0026#34; ----------------------------------- 新增\u0026quot;获取IP并发邮件\u0026quot;的脚本\nvim send-ip-mail.sh ----------------------------------- #!/bin/bash # check network availability while true do TIMEOUT=5 SITE_TO_CHECK=\u0026#34;https://www.126.com/\u0026#34; RET_CODE=`curl -I -s --connect-timeout $TIMEOUT $SITE_TO_CHECK -w %{http_code} | tail -n1` if [ \u0026#34;x$RET_CODE\u0026#34; = \u0026#34;x200\u0026#34; ]; then echo \u0026#34;Network OK, will send mail...\u0026#34; break else echo \u0026#34;Network not ready, wait...\u0026#34; sleep 1s fi done # get the IP address of eth0, e.g. \u0026#34;192.168.16.5\u0026#34; ETH0_IP_ADDR=`ifconfig eth0 | sed -n \u0026#34;2,2p\u0026#34; | awk \u0026#39;{print substr($2,1)}\u0026#39;` WLAN0_IP_ADDR=`ifconfig wlan0 | sed -n \u0026#34;2,2p\u0026#34; | awk \u0026#39;{print substr($2,1)}\u0026#39;` # send the Email echo -e \u0026#34;有线:${ETH0_IP_ADDR}\\n无线:${WLAN0_IP_ADDR}\u0026#34; | mutt -s \u0026#34; 树莓派IP\u0026#34; luanrzh@qq.com ----------------------------------- 编写 开机运行脚本\nsudo vim /etc/rc.local ----------------------------------- #... /home/pi/send-ip-mail.sh \u0026gt;\u0026gt; /home/pi/send-ip-mail.log 2\u0026gt;\u0026amp;1 exit 0 ----------------------------------- 上述脚本是以root用户执行，当前/root目录下还没有msmtp和mutt的配置文件\n复制配置文件至/root目录下\nsudo cp .msmtprc /root sudo cp .muttrc /root ","permalink":"https://blog.luanrz.cn/posts/%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/%E6%A0%91%E8%8E%93%E6%B4%BE%E9%85%8D%E7%BD%AE/","summary":"树莓派配置, 包括常用开发环境及部分实用工具的安装与配置\n安装raspbian系统至SD卡 略\n选择国内仓库源 sudo sed -i \u0026#39;s#://raspbian.raspberrypi.org#s://mirrors.ustc.edu.cn/raspbian#g\u0026#39; /etc/apt/sources.list sudo sed -i \u0026#39;s#://archive.raspberrypi.org/debian#s://mirrors.ustc.edu.cn/archive.raspberrypi.org/debian#g\u0026#39; /etc/apt/sourceslist.d/raspi.list 参见链接树莓派—raspbian软件源（全）\n使用VNC协议无线连接桌面 系统已经默认安装RealVNC,直接启动即可\nvncserver 使用RDP协议无线连接桌面 sudo apt install tightvncserver xrdp 安装tightvncserver将会自动卸载realvnc\n安装phpMyAdmin环境 安装nginx,php-fpm,mairadb\nsudo apt install nginx php-fpm mariadb-server 配置数据库\n安全设置 sudo mysql_secure_installation 登录 mysql -uroot -p 报错，错误信息为：ERROR 1698 (28000): Access denied for user \u0026lsquo;root\u0026rsquo;@\u0026rsquo;localhost\u0026rsquo;\n解决方案：\nsudo mysql -uroot -p update mysql.user set authentication_string=PASSWORD(\u0026#39;root\u0026#39;), plugin=\u0026#39;mysql_native_password\u0026#39; where user=\u0026#39;root\u0026#39;; flush privileges; 配置nginx以支持php\nsudo vim /etc/nginx/sites-available/default ----------------------------------- location / { index index.","title":"树莓派配置"},{"content":"使用Vundle管理Vim插件与实用插件配置\n一、安装插件管理器Vundle 参见在 Linux 上使用 Vundle 管理 Vim 插件 及VundleVim/Vundle.vim\n下载Vundle git clone https://github.com/VundleVim/Vundle.vim.git ~/.vim/bundle/Vundle.vim\n配置Vundle vim ~/.vimrc\nset nocompatible \u0026#34; be iMproved, required filetype off \u0026#34; required \u0026#34; set the runtime path to include Vundle and initialize set rtp+=~/.vim/bundle/Vundle.vim call vundle#begin() \u0026#34; alternatively, pass a path where Vundle should install plugins \u0026#34;call vundle#begin(\u0026#39;~/some/path/here\u0026#39;) \u0026#34; let Vundle manage Vundle, required Plugin \u0026#39;VundleVim/Vundle.vim\u0026#39; \u0026#34; The following are examples of different formats supported. \u0026#34; Keep Plugin commands between vundle#begin/end. \u0026#34; plugin on GitHub repo \u0026#34; Plugin \u0026#39;tpope/vim-fugitive\u0026#39; \u0026#34; plugin from http://vim-scripts.org/vim/scripts.html \u0026#34; Plugin \u0026#39;L9\u0026#39; \u0026#34; Git plugin not hosted on GitHub \u0026#34; Plugin \u0026#39;git://git.wincent.com/command-t.git\u0026#39; \u0026#34; git repos on your local machine (i.e. when working on your own plugin) \u0026#34; Plugin \u0026#39;file:///home/gmarik/path/to/plugin\u0026#39; \u0026#34; The sparkup vim script is in a subdirectory of this repo called vim. \u0026#34; Pass the path to set the runtimepath properly. \u0026#34; Plugin \u0026#39;rstacruz/sparkup\u0026#39;, {\u0026#39;rtp\u0026#39;: \u0026#39;vim/\u0026#39;} \u0026#34; Install L9 and avoid a Naming conflict if you\u0026#39;ve already installed a \u0026#34; different version somewhere else. \u0026#34; Plugin \u0026#39;ascenator/L9\u0026#39;, {\u0026#39;name\u0026#39;: \u0026#39;newL9\u0026#39;} \u0026#34; All of your Plugins must be added before the following line call vundle#end() \u0026#34; required filetype plugin indent on \u0026#34; required \u0026#34; To ignore plugin indent changes, instead use: \u0026#34;filetype plugin on \u0026#34; \u0026#34; Brief help \u0026#34; :PluginList - lists configured plugins \u0026#34; :PluginInstall - installs plugins; append `!` to update or just :PluginUpdate \u0026#34; :PluginSearch foo - searches for foo; append `!` to refresh local cache \u0026#34; :PluginClean - confirms removal of unused plugins; append `!` to auto-approve removal \u0026#34; \u0026#34; see :h vundle for more details or wiki for FAQ \u0026#34; Put your non-Plugin stuff after this line 二、实用插件配置 编辑插件地址：在~/.vimrc文件的call vundle#begin()与call vundle#end() 之间写入Plugin '......'\t编辑插件配置：在~/.vimrc文件末尾写入配置信息\n安装插件：vim \u0026ndash;\u0026gt; : \u0026ndash;\u0026gt;PluginInstall\n语法高亮与行号显示\nset nu! \u0026#34;显示行号 syntax on \u0026#34;语法高亮度显示 NERDTree Plugin \u0026#39;scrooloose/nerdtree\u0026#39;\t\u0026#34; --------------------NerdTree-------------------- \u0026#34; 设置NerdTree,按F3即可显示或隐藏NerdTree区域 map \u0026lt;F3\u0026gt; :NERDTreeMirror\u0026lt;CR\u0026gt; map \u0026lt;F3\u0026gt; :NERDTreeToggle\u0026lt;CR\u0026gt; \u0026#34;打开vim时自动打开NERDTree autocmd vimenter * NERDTree vim-markdown Plugin \u0026#39;godlygeek/tabular\u0026#39; Plugin \u0026#39;plasticboy/vim-markdown\u0026#39; vim-instant-markdown Plugin \u0026#39;suan/vim-instant-markdown\u0026#39; vim-table-mode Plugin \u0026#39;dhruvasagar/vim-table-mode\u0026#39;\t\u0026#34;使用\\tm开启Table Model auto-pairs Plugin \u0026#39;jiangmiao/auto-pairs\u0026#39; syntastic Plugin \u0026#39;scrooloose/syntastic\u0026#39; \u0026#34; --------------------syntastic-------------------- \u0026#34; syntastic官方推荐的默认设置 set statusline+=%#warningmsg# set statusline+=%{SyntasticStatuslineFlag()} set statusline+=%* let g:syntastic_always_populate_loc_list = 1 let g:syntastic_auto_loc_list = 1 let g:syntastic_check_on_open = 1 let g:syntastic_check_on_wq = 0 youcompleteme Plugin \u0026#39;valloric/youcompleteme\u0026#39; supertab Plugin \u0026#39;ervandew/supertab\u0026#39; NERD Commenter Plugin \u0026#39;scrooloose/nerdcommenter\u0026#39; ","permalink":"https://blog.luanrz.cn/posts/%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/vim%E9%85%8D%E7%BD%AE/","summary":"使用Vundle管理Vim插件与实用插件配置\n一、安装插件管理器Vundle 参见在 Linux 上使用 Vundle 管理 Vim 插件 及VundleVim/Vundle.vim\n下载Vundle git clone https://github.com/VundleVim/Vundle.vim.git ~/.vim/bundle/Vundle.vim\n配置Vundle vim ~/.vimrc\nset nocompatible \u0026#34; be iMproved, required filetype off \u0026#34; required \u0026#34; set the runtime path to include Vundle and initialize set rtp+=~/.vim/bundle/Vundle.vim call vundle#begin() \u0026#34; alternatively, pass a path where Vundle should install plugins \u0026#34;call vundle#begin(\u0026#39;~/some/path/here\u0026#39;) \u0026#34; let Vundle manage Vundle, required Plugin \u0026#39;VundleVim/Vundle.vim\u0026#39; \u0026#34; The following are examples of different formats supported.","title":"Vim配置"},{"content":"以PC机上的Tomcat环境与树莓派上的LNMP环境整合过程为例, 演示Nginx反向代理简单配置过程\n整合PC机上的Tomcat环境与树莓派上的LNMP环境\n一、启动Tomcat服务与Apache服务 访问http://192.168.43.209:8080 ,测试PC机上的Tomcat环境 访问http://192.168.43.105:80 ,测试树莓派上的LNMP环境 二、修改nginx.conf sudo vim /etc/nginx/nginx.conf ----------------------------------------------------------- http { upstream tomcat { server 192.168.43.209:8080; } upstream ksweb { server 192.168.43.1:8888; } server { listen 80; server_name tomcat; location / { proxy_pass http://tomcat; } } server { listen 80; server_name pi; location / { proxy_pass http://pi; index index.php index.html index.htm;\t} } } ----------------------------------------------------------- 三、修改本地hosts sudo vim /etc/hosts ----------------------------------------------------------- 192.168.43.209\ttomcat 192.168.43.105\tpi ----------------------------------------------------------- 四、测试 sudo vim ~/Desktop/test.html\n----------------------------------------------------------- \u0026lt;a href =\u0026quot;http://tomcat\u0026quot;\u0026gt;tomcat\u0026lt;/a\u0026gt; \u0026lt;a href =\u0026quot;http://pi\u0026quot;\u0026gt;pi\u0026lt;/a\u0026gt; ----------------------------------------------------------- 运行test.html,点击\u0026quot;tomcat\u0026quot;与\u0026quot;pi\u0026quot;,将分别tomcat首页与LNMP首页\n五、总结 关键字:反向代理、负载均衡、分布式\n反向代理的主要作用是负载均衡 PC机和树莓派可以看作是一个简单的分布式系统 ","permalink":"https://blog.luanrz.cn/posts/%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E9%85%8D%E7%BD%AE/","summary":"以PC机上的Tomcat环境与树莓派上的LNMP环境整合过程为例, 演示Nginx反向代理简单配置过程\n整合PC机上的Tomcat环境与树莓派上的LNMP环境\n一、启动Tomcat服务与Apache服务 访问http://192.168.43.209:8080 ,测试PC机上的Tomcat环境 访问http://192.168.43.105:80 ,测试树莓派上的LNMP环境 二、修改nginx.conf sudo vim /etc/nginx/nginx.conf ----------------------------------------------------------- http { upstream tomcat { server 192.168.43.209:8080; } upstream ksweb { server 192.168.43.1:8888; } server { listen 80; server_name tomcat; location / { proxy_pass http://tomcat; } } server { listen 80; server_name pi; location / { proxy_pass http://pi; index index.php index.html index.htm;\t} } } ----------------------------------------------------------- 三、修改本地hosts sudo vim /etc/hosts ----------------------------------------------------------- 192.168.43.209\ttomcat 192.168.43.105\tpi ----------------------------------------------------------- 四、测试 sudo vim ~/Desktop/test.","title":"Nginx反向代理配置"},{"content":"Centos7.4下Apache.Mysql,PHP及phpMyAdmin的安装与配置\nLinux+Apache+MySQL+PHP安装总结（centos7.4） 一、linux linux系统为centos7.4版本。\n二、Apche yum install httpd -y #（安装apache） systemctl start httpd #（启动apache，也可以是service httpd start） 三、Mysql Centos7.4版本下安装mariadb（MySQL的一个开源分支）。\nyum install mariadb mariadb-server #（安装MySql） systemctl start mariadb #（启动MySQL） mysql_secure_installation #（设置MySql，可在此处修改root密码） 四、PHP yum install php php-mysql（安装php、php-mysql模板） 五、phpMyAdmin yum install phpMyAdmin（安装数据库web端管理入口phpMyAdmin） vim /etc/httpd/conf.d/phpMyAdmin.conf（修改本配置文件才能够远程访问） \u0026lt;RequireAny\u0026gt; #Require ip 127.0.0.1 #Require ip ::1 Require all granted \u0026lt;/RequireAny\u0026gt; vim /etc /phpMyAdmin/config.inc.php（修改本配置文件才能正常登入MySQL） $cfg[\u0026#39;Servers\u0026#39;][$i][\u0026#39;user\u0026#39;] = \u0026#39;root\u0026#39;; $cfg[\u0026#39;Servers\u0026#39;][$i][\u0026#39;password\u0026#39;] = \u0026#39;Wise0823\u0026#39;;（该密码须与数据库密码一致） 六、结束 使用http://106.14.184.75/phpMyAdmin访问数据库管理页。（登录密码不能为‘0’）\n","permalink":"https://blog.luanrz.cn/posts/%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/centos7.4%E4%B8%8Blamp%E7%9A%84%E5%AE%89%E8%A3%85/","summary":"Centos7.4下Apache.Mysql,PHP及phpMyAdmin的安装与配置\nLinux+Apache+MySQL+PHP安装总结（centos7.4） 一、linux linux系统为centos7.4版本。\n二、Apche yum install httpd -y #（安装apache） systemctl start httpd #（启动apache，也可以是service httpd start） 三、Mysql Centos7.4版本下安装mariadb（MySQL的一个开源分支）。\nyum install mariadb mariadb-server #（安装MySql） systemctl start mariadb #（启动MySQL） mysql_secure_installation #（设置MySql，可在此处修改root密码） 四、PHP yum install php php-mysql（安装php、php-mysql模板） 五、phpMyAdmin yum install phpMyAdmin（安装数据库web端管理入口phpMyAdmin） vim /etc/httpd/conf.d/phpMyAdmin.conf（修改本配置文件才能够远程访问） \u0026lt;RequireAny\u0026gt; #Require ip 127.0.0.1 #Require ip ::1 Require all granted \u0026lt;/RequireAny\u0026gt; vim /etc /phpMyAdmin/config.inc.php（修改本配置文件才能正常登入MySQL） $cfg[\u0026#39;Servers\u0026#39;][$i][\u0026#39;user\u0026#39;] = \u0026#39;root\u0026#39;; $cfg[\u0026#39;Servers\u0026#39;][$i][\u0026#39;password\u0026#39;] = \u0026#39;Wise0823\u0026#39;;（该密码须与数据库密码一致） 六、结束 使用http://106.14.184.75/phpMyAdmin访问数据库管理页。（登录密码不能为‘0’）","title":"Centos7.4下LAMP的安装"}]