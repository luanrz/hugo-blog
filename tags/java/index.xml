<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>Java on luanrz's blog</title><link>https://blog.luanrz.cn/tags/java/</link><description>Recent content in Java on luanrz's blog</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Sun, 11 Dec 2022 11:01:19 +0800</lastBuildDate><atom:link href="https://blog.luanrz.cn/tags/java/index.xml" rel="self" type="application/rss+xml"/><item><title>Java应用部署K8S全流程：Docker镜像制作、Harbor镜像存储与Helm应用部署</title><link>https://blog.luanrz.cn/posts/%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/java%E5%BA%94%E7%94%A8%E9%83%A8%E7%BD%B2k8s%E5%85%A8%E6%B5%81%E7%A8%8Bdocker%E9%95%9C%E5%83%8F%E5%88%B6%E4%BD%9Charbor%E9%95%9C%E5%83%8F%E4%B8%8A%E4%BC%A0%E4%B8%8Ehelm%E5%BA%94%E7%94%A8%E9%83%A8%E7%BD%B2/</link><pubDate>Sun, 11 Dec 2022 11:01:19 +0800</pubDate><guid>https://blog.luanrz.cn/posts/%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/java%E5%BA%94%E7%94%A8%E9%83%A8%E7%BD%B2k8s%E5%85%A8%E6%B5%81%E7%A8%8Bdocker%E9%95%9C%E5%83%8F%E5%88%B6%E4%BD%9Charbor%E9%95%9C%E5%83%8F%E4%B8%8A%E4%BC%A0%E4%B8%8Ehelm%E5%BA%94%E7%94%A8%E9%83%A8%E7%BD%B2/</guid><description>一、前言 Java应用部署到K8S（Kubernetes），一般需要镜像制作、镜像存储与应用部署这三个步骤。
镜像制作：根据Java源代码生成符合OCI（开放容器标准）的镜像。可以使用Docker完成镜像制作。 镜像存储：将镜像上传到镜像仓库以便后续使用。这里的镜像仓库一般是指Harbor。 应用部署：根据镜像仓库中的镜像及其对应配置，将应用部署到K8S集群。K8S原生支持手动编写配置文件实现应用部署，Helm简化了应用部署的过程。 为了更好地理解云环境部署，可以类比传统的虚机部署。在云环境部署中：
镜像制作就相当于：maven打包生成war包（实际上war包是镜像的一部分）。 镜像存储就相当于：将war包上传到Maven仓库。 应用部署就相当于：将Maven仓库中的war包安装到JBoss容器。 在此正式介绍上述三个过程之前，还需要准备一些环境。除了Java基础环境之外，还需要准备一个Docker环境与Kubernete集群（可以使用minikube）。
国内网络环境启动minikube时，可以使用：minikube start --image-mirror-country='cn' --kubernetes-version=v1.23.13指令，其中，cn表示使用国内镜像，v1.23.13指定K8S版本小于v1.24，具体原因参见Kubernetes 1.24 中的移除和弃用。
一、Docker镜像制作 （一）准备一个Java项目 使用spring-web搭建一个简单的web项目，pom文件如下：
&amp;lt;project&amp;gt; ... &amp;lt;dependencies&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;/dependencies&amp;gt; &amp;lt;build&amp;gt; &amp;lt;plugins&amp;gt; &amp;lt;plugin&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-maven-plugin&amp;lt;/artifactId&amp;gt; &amp;lt;/plugin&amp;gt; &amp;lt;/plugins&amp;gt; &amp;lt;/build&amp;gt; ... &amp;lt;/project&amp;gt; 启动类如下：
@SpringBootApplication @RestController public class Application { @RequestMapping(&amp;#34;/index.html&amp;#34;) public String home() throws InterruptedException { return &amp;#34;Hello World&amp;#34;; } public static void main(String[] args) { SpringApplication.run(Application.class, args); } } （二）编写Dockerfile脚本 在项目根目录下新建文件Dockerfile，内容如下：
FROM maven:3.8.4-openjdk-8-slim AS base WORKDIR /app COPY pom.</description></item><item><title>HashMap原理浅析</title><link>https://blog.luanrz.cn/posts/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/hashmap%E5%8E%9F%E7%90%86%E6%B5%85%E6%9E%90/</link><pubDate>Tue, 23 Aug 2022 21:50:20 +0000</pubDate><guid>https://blog.luanrz.cn/posts/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/hashmap%E5%8E%9F%E7%90%86%E6%B5%85%E6%9E%90/</guid><description>&lt;p>HashMap是Java中一种常见的集合实现，在不同的jdk版本中，HashMap的实现也不同。本文将以jdk8为主，从源码层面简单分析一下HashMap的存储结构与读写过程，最后简单介绍一下高并发下HashMap的使用方法。&lt;/p></description></item><item><title>Java线程池简介</title><link>https://blog.luanrz.cn/posts/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%AE%80%E4%BB%8B/</link><pubDate>Sat, 20 Aug 2022 16:54:26 +0000</pubDate><guid>https://blog.luanrz.cn/posts/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%AE%80%E4%BB%8B/</guid><description>&lt;p>一般来说，Java中每一个任务都与其对应的线程共享生命周期，任务执行完毕后其线程也会跟着销毁，随着任务数量的增加，重复创建线程所带来的消耗所产生的性能影响也会更显著。线程池提供了一种复用多个线程的方案，以此避免无谓的线程创建，它通过管理线程们的生命周期和调度方式，为任务的批量执行提供更强的灵活性。&lt;/p>
&lt;p>线程池主要是指&lt;code>ThreadPoolExecutor&lt;/code>类，本文将围绕&lt;code>ThreadPoolExecutor&lt;/code>类及其相关类，展开对线程池的介绍。&lt;/p></description></item><item><title>Java阻塞队列简介</title><link>https://blog.luanrz.cn/posts/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/java%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E7%AE%80%E4%BB%8B/</link><pubDate>Mon, 01 Aug 2022 17:00:00 +0000</pubDate><guid>https://blog.luanrz.cn/posts/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/java%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E7%AE%80%E4%BB%8B/</guid><description>&lt;p>Java阻塞队列是一种可以实现&lt;strong>阻塞插入&lt;/strong>和&lt;strong>阻塞移除&lt;/strong>的特殊队列，它被广泛应用于生产者消费者模式。如在线程池中，可以使用&lt;code>LinkedBlockingQueue&lt;/code>与&lt;code>SynchronousQueue&lt;/code>等阻塞队列来生产与消费线程对象。&lt;/p>
&lt;p>下面将简单介绍Java中常用的几个阻塞队列。&lt;/p></description></item><item><title>Java锁简介</title><link>https://blog.luanrz.cn/posts/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/java%E9%94%81%E7%AE%80%E4%BB%8B/</link><pubDate>Wed, 06 Jul 2022 11:15:36 +0000</pubDate><guid>https://blog.luanrz.cn/posts/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/java%E9%94%81%E7%AE%80%E4%BB%8B/</guid><description>&lt;p>Java锁(Lock)是实现Java线程安全的一种手段，它通过加锁和解锁的过程来实现线程间的同步，以保证多线程在竞争同一个公共资源时数据读写的正确性。&lt;/p>
&lt;p>本文将首先阐明&lt;a href="#%E4%B8%80%E5%89%8D%E8%A8%80">Lock在Java线程安全中的位置&lt;/a>，随后将简单介绍&lt;a href="#%E4%BA%8Clock%E7%B1%BB%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB">&lt;code>Lock&lt;/code>类之间的关系&lt;/a>，最后将简单介绍Java锁的&lt;a href="#%E4%B8%89java%E9%94%81%E7%9A%84%E6%8A%BD%E8%B1%A1%E5%AE%9A%E4%B9%89">抽象定义&lt;/a>与&lt;a href="#%E5%9B%9Bjava%E9%94%81%E7%9A%84%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0">具体实现&lt;/a>。&lt;/p></description></item><item><title>Java内存模型简介</title><link>https://blog.luanrz.cn/posts/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E7%AE%80%E4%BB%8B/</link><pubDate>Fri, 24 Jun 2022 08:50:02 +0000</pubDate><guid>https://blog.luanrz.cn/posts/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E7%AE%80%E4%BB%8B/</guid><description>&lt;p>Java内存模型（Java Memory Model，JMM）是Java多线程读写共享内存中的一种规范，该规范支持了&lt;code>synchronized&lt;/code>、&lt;code>volatile&lt;/code>、&lt;code>final&lt;/code>、&lt;code>Lock&lt;/code>等Java并发工具。&lt;/p>
&lt;p>前面介绍了JVM内存区域，JVM内存区域和Java内存模型是不同层次对内存的划分，Java内存模型侧重描述内存数据在多线程下的读写规则，一般关注&lt;strong>并发&lt;/strong>编程下线程如何正确读写共享数据。&lt;/p></description></item><item><title>JVM内存区域简介</title><link>https://blog.luanrz.cn/posts/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/jvm%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E7%AE%80%E4%BB%8B/</link><pubDate>Thu, 23 Jun 2022 11:24:43 +0000</pubDate><guid>https://blog.luanrz.cn/posts/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/jvm%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E7%AE%80%E4%BB%8B/</guid><description>&lt;p>JVM内存区域（JVM内存结构，JVM内存布局）是Java虚拟机运行时数据的位置划分，其主要包括：程序计数器、虚拟机栈、本地方法栈、堆、方法区。&lt;/p>
&lt;p>后面将介绍Java内存模型，JVM内存区域和Java内存模型是不同层次对内存的划分，JVM内存区域侧重描述内存数据的结构布局，一般关注&lt;strong>垃圾回收&lt;/strong>（GC）及&lt;strong>OOM&lt;/strong>问题。&lt;/p></description></item><item><title>Java技能树</title><link>https://blog.luanrz.cn/posts/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/java%E6%8A%80%E8%83%BD%E6%A0%91/</link><pubDate>Mon, 20 Jun 2022 15:34:51 +0000</pubDate><guid>https://blog.luanrz.cn/posts/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/java%E6%8A%80%E8%83%BD%E6%A0%91/</guid><description>&lt;p>梳理Java开发所需的技能点，用于指导后续的学习路线，并提供系统性的查漏补缺方式。&lt;/p></description></item><item><title>JVM双亲委派模型浅析</title><link>https://blog.luanrz.cn/posts/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/jvm%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B%E6%B5%85%E6%9E%90/</link><pubDate>Thu, 16 Jun 2022 08:51:45 +0000</pubDate><guid>https://blog.luanrz.cn/posts/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/jvm%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B%E6%B5%85%E6%9E%90/</guid><description>&lt;p>&lt;strong>双亲委派&lt;/strong>(Parents Delegation)，一言以蔽之，就是：在Java虚拟机中，将类的加载行为&lt;strong>委派&lt;/strong>给父级(&lt;strong>双亲&lt;/strong>)类加载器的过程。&lt;/p>
&lt;p>接下来将逐一介绍Java8及Java9中的类加载器，并根据类加载器的组织结构，描述双亲委派的实现过程。&lt;/p></description></item><item><title>Maven依赖机制浅析</title><link>https://blog.luanrz.cn/posts/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/maven%E4%BE%9D%E8%B5%96%E6%9C%BA%E5%88%B6%E6%B5%85%E6%9E%90/</link><pubDate>Fri, 22 Apr 2022 13:49:08 +0000</pubDate><guid>https://blog.luanrz.cn/posts/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/maven%E4%BE%9D%E8%B5%96%E6%9C%BA%E5%88%B6%E6%B5%85%E6%9E%90/</guid><description>&lt;p>Maven通过pom文件来管理Java包的依赖关系，多个pom文件组合在一起可以理解为一颗抽象的依赖树，父节点或祖父节点的包会传递给子节点或祖孙节点，这被称作&lt;strong>传递依赖&lt;/strong>(Transitive-Dependencies)。&lt;/p>
&lt;p>传递依赖一般通过两个标签来实现：parent与dependency，其中，parent定义了上级依赖，dependency定义了下级依赖。&lt;/p>
&lt;p>随着项目复杂性的提升，依赖树中包发生冲突的概率也会增加，Maven通过&lt;strong>依赖仲裁&lt;/strong>(Dependency-Mediation)与&lt;strong>依赖管理&lt;/strong>(Dependency-Management)来唯一确定依赖树中包的版本。&lt;/p></description></item><item><title>ThreadLocal原理浅析</title><link>https://blog.luanrz.cn/posts/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/threadlocal%E5%8E%9F%E7%90%86%E6%B5%85%E6%9E%90/</link><pubDate>Mon, 18 Apr 2022 10:01:31 +0000</pubDate><guid>https://blog.luanrz.cn/posts/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/threadlocal%E5%8E%9F%E7%90%86%E6%B5%85%E6%9E%90/</guid><description>&lt;p>ThreadLocal是一种实现线程安全的机制，它提供了访问线程局部变量（thread-local variables）的方法，线程局部变量与普通变量的不同之处在于，线程局部变量在每一个线程中的值都是独立的，这保证了在多线程环境下不会出现线程串用的问题。&lt;/p></description></item><item><title>Java单例模式中的一个多线程问题</title><link>https://blog.luanrz.cn/posts/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/java%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E4%B8%AD%E7%9A%84%E4%B8%80%E4%B8%AA%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%97%AE%E9%A2%98/</link><pubDate>Fri, 15 Apr 2022 14:43:37 +0000</pubDate><guid>https://blog.luanrz.cn/posts/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/java%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E4%B8%AD%E7%9A%84%E4%B8%80%E4%B8%AA%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%97%AE%E9%A2%98/</guid><description>&lt;p>合理使用单例模式可以节约内存资源，但错误的使用可能会导致严重的生产问题，如：多线程下，一个线程可能会覆盖上一个线程的单例属性，导致两次不同的请求得到同样的响应。&lt;/p>
&lt;p>下面将结合一个例子来分析这种情况。&lt;/p></description></item><item><title>Spring的7个使用场景</title><link>https://blog.luanrz.cn/posts/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/spring%E7%9A%847%E4%B8%AA%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/</link><pubDate>Thu, 31 Mar 2022 09:31:48 +0000</pubDate><guid>https://blog.luanrz.cn/posts/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/spring%E7%9A%847%E4%B8%AA%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/</guid><description>&lt;p>&lt;a href="https://spring.io">Spring官网&lt;/a>中描述了Spring能做的7件事，如下所示：&lt;/p>
&lt;pre tabindex="0">&lt;code class="language-plantuml" data-lang="plantuml">@startmindmap
* Spring
* Microservices（微服务）
* Reactive（响应式）
* Cloud（云）
* Web apps（网页应用）
* Serverless（无服务器）
* Event Driven（事件驱动）
* Batch（批处理）
@endmindmap
&lt;/code>&lt;/pre>&lt;p>下面将简单介绍各场景的概念与其关联的项目。&lt;/p></description></item><item><title>JVM性能调优工具汇总</title><link>https://blog.luanrz.cn/posts/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/jvm%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E5%B7%A5%E5%85%B7%E6%B1%87%E6%80%BB/</link><pubDate>Fri, 31 Dec 2021 10:25:57 +0000</pubDate><guid>https://blog.luanrz.cn/posts/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/jvm%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E5%B7%A5%E5%85%B7%E6%B1%87%E6%80%BB/</guid><description>一、命令行工具 序号 名称 功能 1 jps 虚拟机进程状况工具，主要用于查找vmid，是后续命令的基础 2 jstat 虚拟机统计信息监视工具，查找虚拟机进程中类加载、内存、GC等信息 3 jinfo Java配置信息工具，实时查看和调整虚拟机各项参数 4 jmap Java内存映像工具，生成堆转储快照（headump、dump），与jhat配合使用 5 jhat 虚拟机堆转储快照分析工具，分析jmap生成的堆转储快照文件，与jmap配合使用 6 jstack Java堆栈跟踪工具，生成虚拟机当前时刻的线程快照（threaddump、javacore） 7 jcmd Java命令行工具集，整合了上述众多命令 8 clhsdb HotSpot命令行调试器，也整合了上述众多命令，它在JDK9时被纳入了jhsdb 二、可视化工具 序号 名称 功能 1 JHSDB 基于服务性代理的调试工具，JDK内置（从JDK9开始提供） 2 JConsole Java监视与管理控制台，JDK内置 3 VisualVM 多合一故障处理工具，需要单独下载 4 JMC 可持续在线的监控工具，需要单独下载 参考文档
《深入理解Java虚拟机第3版 周志明 著》</description></item><item><title>Java8函数式编程入门</title><link>https://blog.luanrz.cn/posts/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/java8%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/</link><pubDate>Sat, 21 Aug 2021 09:38:30 +0000</pubDate><guid>https://blog.luanrz.cn/posts/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/java8%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/</guid><description>&lt;h2 id="一lambda表达式">一、Lambda表达式&lt;/h2>
&lt;p>什么是Lambda表达式?&lt;/p>
&lt;p>Lambda表达式是一个函数，有入参和出参，它表示一个行为。&lt;/p>
&lt;p>Lambda表达式是一个对象，Java中函数是二等公民，只能依附于类存在，Lambda表达式的目标类型被称之为函数接口。&lt;/p>
&lt;h3 id="一lambda表达式与匿名内部类对象">（一）Lambda表达式与匿名内部类对象&lt;/h3>
&lt;p>Lambda表达式和匿名内部类对象很像，在正式介绍Lambda表达式之前，先看看一个匿名内部类对象的例子。&lt;/p>
&lt;p>一般情况下，接口不可以直接实例化，但可以在new接口的过程中重写接口中的方法来创建一个匿名内部类对象。如下所示：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>Runnable anonymousClassesRunnable &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> Runnable&lt;span style="color:#f92672">()&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Override&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">run&lt;/span>&lt;span style="color:#f92672">()&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">out&lt;/span>&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">println&lt;/span>&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#e6db74">&amp;#34;我是一个匿名类内部类对象&amp;#34;&lt;/span>&lt;span style="color:#f92672">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">};&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>有没有更简单的方式呢？请看下述代码：&lt;/p>
&lt;pre tabindex="0">&lt;code>Runnable lambdaRunnable = () -&amp;gt; System.out.println(&amp;#34;我是一个lambda表达式&amp;#34;);
&lt;/code>&lt;/pre>&lt;p>上述代码中&lt;code>=&lt;/code>右侧的&lt;code>() -&amp;gt; System.out.println(&amp;quot;我是一个lambda表达式&amp;quot;)&lt;/code>是一个&lt;code>Lambda表达式&lt;/code>。&lt;/p>
&lt;p>这个Lambda表达式由三部分组成：&lt;/p>
&lt;ol>
&lt;li>&lt;code>()&lt;/code> : 请求参数，这里为空（对应了上述匿名内部类中run方法的请求参数）&lt;/li>
&lt;li>&lt;code>System.out.println(&amp;quot;我是一个lambda表达式&amp;quot;)&lt;/code>: 方法体（对应了上述匿名内部类中run方法的方法体）&lt;/li>
&lt;li>&lt;code>-&amp;gt;&lt;/code> : Lambda表达式标识符，连接左侧的请求参数和右侧的方法体&lt;/li>
&lt;/ol>
&lt;p>可以看到，Lambda表达式与匿名内部类对象完全等价，它们都在&lt;code>=&lt;/code>右侧，都可以被赋值给&lt;code>=&lt;/code>左侧的接口变量，换言之，&lt;strong>Lambda表达式本质上是一个接口的实例化对象&lt;/strong>（在Java中，万物皆对象，lambda表达式也不例外）。那么，任意接口都可以是Lambda表达式的目标类型吗？&lt;/p></description></item><item><title>Java正则入门</title><link>https://blog.luanrz.cn/posts/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/java%E6%AD%A3%E5%88%99%E5%85%A5%E9%97%A8/</link><pubDate>Wed, 07 Apr 2021 18:01:00 +0000</pubDate><guid>https://blog.luanrz.cn/posts/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/java%E6%AD%A3%E5%88%99%E5%85%A5%E9%97%A8/</guid><description>&lt;p>以String类中的匹配与替换为入口, 简单介绍Java正则匹配与正则替换&lt;/p>
&lt;h2 id="一前言">一、前言&lt;/h2>
&lt;p>正则表达式一般用于字符串的模式&lt;strong>匹配&lt;/strong>与&lt;strong>替换&lt;/strong>，Java通过Pattern类与Matcher类原生支持正则表达式。在此基础上，String类封装了正则的细节，提供了一种更便捷的正则操作的方式。&lt;/p>
&lt;p>本文将从String类说起，通过它的matches与replace系列方法，介绍&lt;a href="#%E4%BA%8Cstring%E5%8C%B9%E9%85%8D%E4%B8%8E%E6%9B%BF%E6%8D%A2">String的匹配与替换&lt;/a>。随后，将介绍Java正则中的&lt;a href="#%E4%B8%89pattern%E4%B8%8Ematcher">Pattern与Matcher&lt;/a>两大核心类的基本使用方法。最后，将从&lt;a href="#%E5%9B%9Bstring%E6%AD%A3%E5%88%99%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90">String类源码&lt;/a>层面，简单分析String类的正则匹配和正则替换是如何通过Pattern类和Matcher类实现的。&lt;/p>
&lt;p>有关正则表达式的前置知识介绍，请参照本文&lt;a href="#%E9%99%84%E5%BD%95">附录&lt;/a>中的&lt;a href="#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E9%80%9A%E7%94%A8%E7%9F%A5%E8%AF%86">正则表达式通用知识&lt;/a>。&lt;/p></description></item><item><title>OpenJDK8u构建指南</title><link>https://blog.luanrz.cn/posts/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/openjdk8u%E6%9E%84%E5%BB%BA%E6%8C%87%E5%8D%97/</link><pubDate>Mon, 20 Jan 2020 17:42:00 +0000</pubDate><guid>https://blog.luanrz.cn/posts/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/openjdk8u%E6%9E%84%E5%BB%BA%E6%8C%87%E5%8D%97/</guid><description>官方OpenJdk8u构建指南个人翻译版本。官方地址为README-builds.html
介绍 这个README文件包含了OpenJDK的构建说明。构建OpenJDK的源码需要一定的专业技术知识。
!!!!!!!!!!!!!!! 这是对这份文档的一次重大改写!!!!!!!!!!!!!!!
概述如下：
当前构建方式是“configure &amp;amp;&amp;amp; make” GNU make的版本应当大于或等于3.81 构建是可伸缩的，比如：可以使用更多的处理器来完成构建过程，以减少构建时间 嵌套与递归的make调用已经明显减少，fork/exec 与子进程生成的总量也相应减少 不再支持 Windows MKS Windows Vistual Studio 的 vsvars*.bat 和 vcvars*.bat 等文件会自动运行 构建OpenJDK时，不再使用Ant 不再支持在配置构建过程时使用 ALT_* 环境变量 目录 介绍
使用Mercurial
获取源码 仓库结构 源码规范 构建
系统设置 Linux Solaris MacOSX Windows Configure Make 测试
附录A：提示和技巧
常见问题解答 构建性能技巧 故障排查 附录B：GNU-Make信息
附录C：构建环境
使用Mercurial OpenJDK源码由版本控制系统 Mercurial 维护，如果你还不熟悉 Mercurial ，请参阅 Beginner Guides 或参考 Mercurial Book 。本书的前几章对“Mercurial是什么“以及“Mercurial如何工作”进行了出色的概述。
获取源码 执行主仓库下的 `get_source.sh 命令，获取 OpenJDK Mercurial 仓库的全部内容。
hg clone http://hg.</description></item><item><title>Java文件流与策略模式的综合运用：用两种方式完成文件读写操作</title><link>https://blog.luanrz.cn/posts/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/java%E6%96%87%E4%BB%B6%E6%B5%81%E4%B8%8E%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%BB%BC%E5%90%88%E8%BF%90%E7%94%A8%E7%94%A8%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F%E5%AE%8C%E6%88%90%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99%E6%93%8D%E4%BD%9C/</link><pubDate>Mon, 20 May 2019 16:44:45 +0000</pubDate><guid>https://blog.luanrz.cn/posts/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/java%E6%96%87%E4%BB%B6%E6%B5%81%E4%B8%8E%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%BB%BC%E5%90%88%E8%BF%90%E7%94%A8%E7%94%A8%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F%E5%AE%8C%E6%88%90%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99%E6%93%8D%E4%BD%9C/</guid><description>&lt;h2 id="前言">前言&lt;/h2>
&lt;p>文件分为文本文件和非文本文件（二进制文件，如音频、图片文件等），此处讨论的主要是文本文件。&lt;/p>
&lt;p>文件的读写操作基于Java的I/O流，Java流分为字节流与字符流，它们都可以实现文件的读写操作。一般而言，字符流专注于处理文本文件，而字节流则更为通用，所有类型的文件均可操作。基于此，文本文件的读写操作有两种不同的策略：字节流文件读写与字符流文件读写。&lt;/p></description></item></channel></rss>